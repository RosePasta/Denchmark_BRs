{"BR": {"BR_id": "535", "BR_author": "eladdidy", "BRopenT": "2019-08-14T18:37:32Z", "BRcloseT": "2019-08-30T20:08:51Z", "BR_text": {"BRsummary": "inner product low performance with s8 in compared to f32", "BRdescription": "\n I have simple test model with 3 FC, 2 BN + Relu\n data type F32 test takes: ~2500 us\n data type S8 test takes: ~14000\n I would expect INT8 to preform better, can someone explain please?\n Attaching code - Just fix the MKLDNNROOT in Make file\n Thanks\n Elad\n <denchmark-link:https://github.com/intel/mkl-dnn/files/3502750/mkl_3fc_test.zip>mkl_3fc_test.zip</denchmark-link>\n \n <denchmark-h:hr></denchmark-h>\n \n <denchmark-h:h3>Environment</denchmark-h>\n \n \n CPU: Xeon(R) Platinum 8176 @2.1Ghz\n OS: SLES12SP2 4.4.41-11-rt (RT extension)\n Compiler:  gcc 4.8.5\n mkldnn release 1.0.0\n \n \t"}, "comments": {"comments_0": {"comment_id": 1, "comment_author": "eladdidy", "commentT": "2019-08-14T18:55:45Z", "comment_text": "\n \t\tPlease note that my mkldnn was build with debug, same phenomena with release\n \t\t"}, "comments_1": {"comment_id": 2, "comment_author": "eladdidy", "commentT": "2019-08-14T19:15:35Z", "comment_text": "\n \t\tHi <denchmark-link:https://github.com/eladdidy>@eladdidy</denchmark-link>\n ,\n I check the verbose and see the following (run on Skylake P8180 in release mode):\n \n \n \n Primitive\n Problem\n f32 time (ms)\n int8 time (ms)\n \n \n \n \n FC\n mb1ic192oc600\n 0.021\n 0.014\n \n \n BatchNorm\n mb1ic600\n 0.012\n 0.023\n \n \n FC\n mb1ic600oc600\n 0.056\n 0.042\n \n \n BatchNorm\n mb1ic600\n 0.012\n 0.023\n \n \n FC\n mb1ic600oc256\n 0.027\n 0.019\n \n \n \n So the INT8 FC is ~1.4x faster than f32 counterpart. That is exactly what is expected on Skylake.\n Now the batch norm is a problem. We run somewhat optimized version for f32 (ncsp_bnorm:any), but the reference implementation for int8. That spoils the results.\n In general, the assumption is that for inference you don't need batch norm at all, you can embed it to the weights of the previous layer. This is also helpful because you wouldn't lose an accuracy due to type conversion (i.e. the batch-normalization would essentially be done in f32 and not if int8).\n Do you think this approach can work for you?\n \t\t"}, "comments_2": {"comment_id": 3, "comment_author": "eladdidy", "commentT": "2019-08-14T19:23:10Z", "comment_text": "\n \t\tP.S. If the time ratios you see in your (release) setup don't match mine ones, could you please post the verbose output that you have?\n \t\t"}, "comments_3": {"comment_id": 4, "comment_author": "eladdidy", "commentT": "2019-08-14T20:10:25Z", "comment_text": "\n \t\tActually, my measurements were done in slightly incorrect environment (my Intel MKL-DNN library was built with Intel MKL, which is mostly for debug purposes). So please disregard the table above. The updated table is:\n \n \n \n Primitive\n Problem\n f32 time (ms)\n s8s8 time (ms)\n u8s8 time (ms)\n \n \n \n \n FC\n mb1ic192oc600\n 0.009\n 0.015\n 0.003\n \n \n BatchNorm\n mb1ic600\n 0.013\n 0.023\n 0.024\n \n \n FC\n mb1ic600oc600\n 0.046\n 0.042\n 0.009\n \n \n BatchNorm\n mb1ic600\n 0.012\n 0.025\n 0.023\n \n \n FC\n mb1ic600oc256\n 0.019\n 0.020\n 0.004\n \n \n Test FC Time\n (program output)\n 3692\n 2863\n 1635\n \n \n \n \n Note s8s8 is the same as original int8 code\n \n So few observations here:\n \n Nothing changes wrt Batch Norm. We will soon promote the implementation for int8 which should improve the situation a bit. But in general, the recommendation is still to try avoiding the BatchNorm altogether in inference.\n In addition to s8s8 FC I added u8s8 FC: in the code, I replaced the source data type from s8 to u8. The reason is that Skylake natively supports u8 * s8 --> s32, while s8 * s8 --> s32 should be emulated. The emulation comes with some overhead. For big matrices the overhead is typically negligible, but for small sizes it might be significant. I will need to dig into that more to understand whether this is a bug on our side, or we can do almost nothing to overcome this overhead for these particular sizes (cast @aaraujom in case he has some insights).\n Forgetting for a moment the difference between s8s8 and u8s8 you can see that FC for u8s8 is much faster than f32. Theoretical peak says the the difference should be ~1.33x, but here the difference is ~5x. I think that is because for u8s8 case the data fit into L2: ~600 KB of data and 1 MB of L2 cache. For f32 the data takes around 2.5 MB which exceeds the L2 cache.\n \n If we fix s8s8 and will get rid of BatchNorm the speed up of using int8 will be almost 4.6x over f32.\n \n \n \n Anyways, I take an AR to see why s8s8 is way worse than u8s8.\n \t\t"}, "comments_4": {"comment_id": 5, "comment_author": "eladdidy", "commentT": "2019-08-15T06:58:18Z", "comment_text": "\n \t\tHi,\n I'm good with fusing BN into FC and i'll have it by next week.\n I'm looking up for the s8s8 fix and will be happy to support dev efforts\n Thanks\n Elad\n \t\t"}}}, "commit": {"commit_id": "3092d7bfa1a984a346a09c0af7056722d4c2baf9", "commit_author": "Fomenko, Evarist M", "commitT": "2019-08-28 23:29:27+00:00", "changed_files": {"file_0": {"file_change_type": "MODIFY", "file_Nmethod": 1, "file_old_name": "src\\cpu\\gemm\\gemm.cpp", "file_new_name": "src\\cpu\\gemm\\gemm.cpp", "hunks": {"hunk_0": {"Ismethod": 1, "added_lines": "219", "deleted_lines": "219,220,221", "method_info": {"method_name": "dnnl::impl::cpu::gemm_s8x8s32", "method_params": "transa,transb,offsetc,M,N,K,alpha,A,LDA,ao,B,LDB,bo,beta,C,LDC,co", "method_startline": "208", "method_endline": "237"}}}}, "file_1": {"file_change_type": "MODIFY", "file_Nmethod": 2, "file_old_name": "src\\cpu\\gemm\\gemm_info.cpp", "file_new_name": "src\\cpu\\gemm\\gemm_info.cpp", "hunks": {"hunk_0": {"Ismethod": 1, "added_lines": "184,185,186,187,415,420,474,475,476,508,512", "deleted_lines": "471", "method_info": {"method_name": "dnnl::impl::cpu::gemm_info_t<a_type,b_type,c_type>::jit_init", "method_params": "void", "method_startline": "155", "method_endline": "516"}}, "hunk_1": {"Ismethod": 1, "added_lines": "535,536", "deleted_lines": "525", "method_info": {"method_name": "dnnl::impl::cpu::gemm_info_t<a_type,b_type,c_type>::hasKernels", "method_params": "void", "method_startline": "524", "method_endline": "569"}}}}, "file_2": {"file_change_type": "MODIFY", "file_Nmethod": 0, "file_old_name": "src\\cpu\\gemm\\gemm_info.hpp", "file_new_name": "src\\cpu\\gemm\\gemm_info.hpp", "hunks": {"hunk_0": {"Ismethod": 0, "added_lines": "91,92,93,94", "deleted_lines": null}}}, "file_3": {"file_change_type": "MODIFY", "file_Nmethod": 7, "file_old_name": "src\\cpu\\gemm\\s8x8s32\\jit_avx512_core_gemv_s8x8s32.cpp", "file_new_name": "src\\cpu\\gemm\\s8x8s32\\jit_avx512_core_gemv_s8x8s32.cpp", "hunks": {"hunk_0": {"Ismethod": 1, "added_lines": "48,49,57,62,83,91,146", "deleted_lines": "46,54,59,80,88,143", "method_info": {"method_name": "dnnl::impl::cpu::gemv_threading_driver", "method_params": "arg", "method_startline": "46", "method_endline": "219"}}, "hunk_1": {"Ismethod": 1, "added_lines": "228,229,230,231,232,233,234,237,238,258,260", "deleted_lines": "229,230,250,252", "method_info": {"method_name": "dnnl::impl::cpu::jump_to_gemv_s8x8s32_impl", "method_params": "arg", "method_startline": "228", "method_endline": "272"}}, "hunk_2": {"Ismethod": 1, "added_lines": "35,36,37,38,39", "deleted_lines": "35,36", "method_info": {"method_name": "dnnl::impl::cpu::gemv_kernel_driver", "method_params": "arg", "method_startline": "35", "method_endline": "43"}}, "hunk_3": {"Ismethod": 1, "added_lines": "225,226,228,229,230,231,232,233,234,237,238,258,260", "deleted_lines": "225,226,229,230,250,252", "method_info": {"method_name": "dnnl::impl::cpu::jump_to_gemv_s8x8s32_impl", "method_params": "arg", "method_startline": "225", "method_endline": "264"}}, "hunk_4": {"Ismethod": 1, "added_lines": "288", "deleted_lines": null, "method_info": {"method_name": "dnnl::impl::cpu::jump_to_gemv_s8x8s32", "method_params": "arg", "method_startline": "287", "method_endline": "289"}}, "hunk_5": {"Ismethod": 1, "added_lines": "35,36,37,38,39", "deleted_lines": "35,36,45,46", "method_info": {"method_name": "dnnl::impl::cpu::gemv_kernel_driver", "method_params": "arg", "method_startline": "35", "method_endline": "46"}}, "hunk_6": {"Ismethod": 1, "added_lines": "49,57,62,83,91,146", "deleted_lines": "54,59,80,88,143,221,222", "method_info": {"method_name": "dnnl::impl::cpu::gemv_threading_driver", "method_params": "arg", "method_startline": "49", "method_endline": "222"}}}}, "file_4": {"file_change_type": "MODIFY", "file_Nmethod": 4, "file_old_name": "src\\cpu\\gemm\\s8x8s32\\jit_avx512_core_kernel_gemv_s8x8s32_kern.cpp", "file_new_name": "src\\cpu\\gemm\\s8x8s32\\jit_avx512_core_kernel_gemv_s8x8s32_kern.cpp", "hunks": {"hunk_0": {"Ismethod": 1, "added_lines": "31,32,34,35,40,41,44,49,50,51,52,53,54", "deleted_lines": "31,43,44", "method_info": {"method_name": "dnnl::impl::cpu::jit_avx512_core_gemv_s8x8s32_kern::vnni", "method_params": "acc,a,b,op", "method_startline": "31", "method_endline": "56"}}, "hunk_1": {"Ismethod": 1, "added_lines": "67,80,81,82,83,84,95,96,97,98,99", "deleted_lines": "69,80", "method_info": {"method_name": "dnnl::impl::cpu::jit_avx512_core_gemv_s8x8s32_kern::n_loop_body", "method_params": "nreg_acc,A,lda,X,use_mask,mask_n", "method_startline": "58", "method_endline": "100"}}, "hunk_2": {"Ismethod": 1, "added_lines": "31,32,34,35,40,41,44", "deleted_lines": "31,43,44", "method_info": {"method_name": "dnnl::impl::cpu::jit_avx512_core_gemv_s8x8s32_kern::vnni", "method_params": "acc,a,b", "method_startline": "31", "method_endline": "46"}}, "hunk_3": {"Ismethod": 1, "added_lines": "179,180,184,185,186,237,238,239,240,241,242,243,244,245,367,368,369,370,371,372,373", "deleted_lines": "214,215,337,338,339,340,341,342", "method_info": {"method_name": "dnnl::impl::cpu::jit_avx512_core_gemv_s8x8s32_kern::generate", "method_params": "use_vnni", "method_startline": "178", "method_endline": "376"}}}}, "file_5": {"file_change_type": "MODIFY", "file_Nmethod": 1, "file_old_name": "src\\cpu\\gemm\\s8x8s32\\jit_avx512_core_kernel_gemv_s8x8s32_kern.hpp", "file_new_name": "src\\cpu\\gemm\\s8x8s32\\jit_avx512_core_kernel_gemv_s8x8s32_kern.hpp", "hunks": {"hunk_0": {"Ismethod": 1, "added_lines": "84", "deleted_lines": null, "method_info": {"method_name": "dnnl::impl::cpu::jit_avx512_core_gemv_s8x8s32_kern::jit_avx512_core_gemv_s8x8s32_kern", "method_params": "", "method_startline": "84", "method_endline": "84"}}}}}}}