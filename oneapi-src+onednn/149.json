{"BR": {"BR_id": "149", "BR_author": "kruus", "BRopenT": "2017-11-10T20:52:24Z", "BRcloseT": "2017-11-20T15:44:08Z", "BR_text": {"BRsummary": "primitive iterator segfaults, if you are lucky.", "BRdescription": "\n <denchmark-h:h3>Description</denchmark-h>\n \n \n mkldnn_primitive_desc_create passes a nullptr argument to ...\n mkldnn_primitive_desc_iterator_create_v2, which passes the address of a temporary stack variable into new primitive_desc_iterator ...\n which is unsafe for the primitives to copy [or use] after returning from ...create_v2\n \n <denchmark-h:h3>Quick-fix (move and modify one line of code)</denchmark-h>\n \n Make the const primitive_attr_t * argument used when nullptr is given to mkldnn_primitive_desc_iterator_create_v2 point to a static default-constructed one at file scope.\n Move the dummy_attr declaration up a few lines:\n static const primitive_attr_t dummy_attr; // (file scope)\n Verified by rerunning valgrind on a test program that uses iterators.\n <denchmark-h:h3>Environment</denchmark-h>\n \n Probably any. (in debug compiles, sometimes it failed to segfault, but valgrind still identifies the bug)\n <denchmark-h:h3>Steps to reproduce</denchmark-h>\n \n You need a test program that uses iterators\n (I have such a basic test in my tests/api.c on the necla-ml/gen-dnn.git fork)\n <denchmark-h:h3>Actual behavior</denchmark-h>\n \n Segfault with default compile, and valgrind reports:\n <denchmark-code>==24519== Conditional jump or move depends on uninitialised value(s)\n ==24519==    at 0x4E5D171: mkldnn::impl::scales_t::set(int, int, float const*) (primitive_attr.cpp:32)\n </denchmark-code>\n \n <denchmark-h:h3>Expected behavior</denchmark-h>\n \n No segfault and no valgrind complaints\n \t"}, "comments": {"comments_0": {"comment_id": 1, "comment_author": "kruus", "commentT": "2017-11-10T21:28:17Z", "comment_text": "\n \t\tThanks for catching that!\n Though i am still not sure i see the exact reason of the problem... primitive_desc copies the attribute, so it should not actually de-reference that stack dummy_attr...\n Am looking into the issue.\n \t\t"}, "comments_1": {"comment_id": 2, "comment_author": "kruus", "commentT": "2017-11-10T21:42:20Z", "comment_text": "\n \t\tThe pointer is copied in the iterator constructor.  There is no new memory allocation. It quickly becomes stale.\n Sure the primitive creates a copy, but this is via the copy constructor of attr, but by then\n the src pointer is invalid.\n Sorry, don't have full valgrind trace available anymore.\n \t\t"}, "comments_2": {"comment_id": 3, "comment_author": "kruus", "commentT": "2017-11-10T21:56:09Z", "comment_text": "\n \t\tNo worries about valgrind traces.\n I got your point. But the thing is that iterator is used with-in the function mkldnn_primitive_desc_iterator_create_v2, so dummy_attr should be alive during this time.\n I definitely miss something... :(\n \t\t"}, "comments_3": {"comment_id": 4, "comment_author": "kruus", "commentT": "2017-11-11T04:39:24Z", "comment_text": "\n \t\t\n You almost have it. And thing are great while within scope of ...create_v2, where the pointer is alive.\n But &dummy_attr the pointer is passed out to mkldnn_primitive_desc_iterator constructor, and stored as mkldnn_primitive_desc_iterator::attr_.\n The iterator creates no primitive (pd_(nullptr)).\n Primitive factory functions are invoked later as mkldnn_primitive_desc_iterator::operator++  moves the iterator forward.\n It is true that ...create_v2 invokes operator++ to find a first valid impl.  &dummy_attr is still OK. You are happy. I am happy.\n \n <denchmark-code>primitive_desc_iterator_t &operator++() {\n   // loop over primitive construction functions\n   auto s = impl_list_[idx_](&pd_, op_desc_, attr_/* oops */, engine_, hint_fwd_pd_);\n   //            attr_     had better still point to valid memory\n   // etc.\n }\n </denchmark-code>\n \n \n So what if we want to iterate with our iterator?\n \n To get the next valid impl, I call mkldnn_primitive_desc_iterator_next, ...\n invoking operator++ and\n attr_ now points to ???. Attribute copy constructors get called. I am sad. You are sad.\n \n \n \n <denchmark-h:hr></denchmark-h>\n \n btw, the double delete destructor bug seems still there. Please set pd_ = nullptr after delete pd_ in operator++ so that ~mkldnn_primitive_desc_iterator doesn't delete it a second time.  This also can segfault if you iterate through every single available impl for a primitive.\n \t\t"}, "comments_4": {"comment_id": 5, "comment_author": "kruus", "commentT": "2017-11-13T19:02:52Z", "comment_text": "\n \t\tArrrh, i am careless... :(\n All that time i thought about mkldnn_primitive_desc_create_v2, not mkldnn_primitive_desc_iterator_create_v2. The latter of course has a bug... :(\n I am reworking this part.\n I also added test that catches the problem. Should've done that earlier.\n Thanks a lot for a quick eye and patience.\n \t\t"}, "comments_5": {"comment_id": 6, "comment_author": "kruus", "commentT": "2017-11-13T21:12:14Z", "comment_text": "\n \t\tTentatively push the fix into my fork of mkl-dnn.\n There is some work happening meanwhile, so the patch will be promoted to the main repo slightly later...\n \t\t"}, "comments_6": {"comment_id": 7, "comment_author": "kruus", "commentT": "2017-11-13T21:18:49Z", "comment_text": "\n \t\tOn my fork, api.c (test4, iirc?) has an iteration demo that has been regularly catching such oversights, but maybe a shorter/separate test/gtest can be cooked up \"in your copious free time\" :)\n \t\t"}, "comments_7": {"comment_id": 8, "comment_author": "kruus", "commentT": "2017-11-13T21:20:59Z", "comment_text": "\n \t\tJust as you <denchmark-link:https://github.com/emfomenk/mkl-dnn/commit/b21425d30973b2b66c7fd11ad630232ca952e942#diff-81a8585a3380fda77805f0d64a945572>wanted</denchmark-link>\n  :)\n \t\t"}}}, "commit": {"commit_id": "46a599230bcdd8e90309d3d0f44298a9df0421f0", "commit_author": "Fomenko, Evarist M", "commitT": "2017-11-14 17:18:19+00:00", "changed_files": {"file_0": {"file_change_type": "MODIFY", "file_Nmethod": 5, "file_old_name": "src\\common\\primitive_iterator.cpp", "file_new_name": "src\\common\\primitive_iterator.cpp", "hunks": {"hunk_0": {"Ismethod": 1, "added_lines": null, "deleted_lines": "88,89,90,91", "method_info": {"method_name": "mkldnn_primitive_desc_iterator_create_v2", "method_params": "iterator,c_op_desc,attr,engine,hint_fwd_pd", "method_startline": "82", "method_endline": "103"}}, "hunk_1": {"Ismethod": 1, "added_lines": "34,35", "deleted_lines": "34,35", "method_info": {"method_name": "mkldnn_primitive_desc_iterator::mkldnn_primitive_desc_iterator", "method_params": "engine,op_desc,attr,hint_fwd_pd", "method_startline": "32", "method_endline": "39"}}, "hunk_2": {"Ismethod": 1, "added_lines": "51,53", "deleted_lines": "51,53", "method_info": {"method_name": "mkldnn_primitive_desc_iterator::operator ++", "method_params": "", "method_startline": "50", "method_endline": "58"}}, "hunk_3": {"Ismethod": 1, "added_lines": null, "deleted_lines": "146,147,148,149", "method_info": {"method_name": "mkldnn_primitive_desc_create_v2", "method_params": "primitive_desc,c_op_desc,attr,engine,hint_fwd_pd", "method_startline": "141", "method_endline": "155"}}, "hunk_4": {"Ismethod": 1, "added_lines": "78", "deleted_lines": "78", "method_info": {"method_name": "mkldnn_primitive_desc_iterator::mkldnn_primitive_desc_iterator", "method_params": "engine,last_idx", "method_startline": "76", "method_endline": "79"}}}}, "file_1": {"file_change_type": "MODIFY", "file_Nmethod": 0, "file_old_name": "tests\\gtests\\CMakeLists.txt", "file_new_name": "tests\\gtests\\CMakeLists.txt", "hunks": {"hunk_0": {"Ismethod": 0, "added_lines": "30", "deleted_lines": null}}}, "file_2": {"file_change_type": "ADD", "file_Nmethod": 0, "file_old_name": "None", "file_new_name": "tests\\gtests\\test_iface_pd_iter.cpp"}}}}