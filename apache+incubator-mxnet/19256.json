{"BR": {"BR_id": "19256", "BR_author": "samskalicky", "BRopenT": "2020-09-30T07:13:03Z", "BRcloseT": "2020-10-02T22:52:31Z", "BR_text": {"BRsummary": "Multiple subgraph properties with single backend issue with optimize_for", "BRdescription": "\n <denchmark-h:h2>Description</denchmark-h>\n \n Theres a difference in the flow between get_backend_symbol and optimize_for when a single backend has multiple subgraph properties that results in the indexed graph not being updated between subgraph properties.\n <denchmark-h:h3>Error Message</denchmark-h>\n \n <denchmark-code>Traceback (most recent call last):\n   File \"test.py\", line 22, in <module>\n     sym_block.optimize_for(mx.nd.zeros((64, 4, 10, 10)), backend='MKLDNN_QUANTIZE')\n   File \"/home/ubuntu/v1.7.x/python/mxnet/gluon/block.py\", line 1089, in optimize_for\n     self._build_cache(x, *args)\n   File \"/home/ubuntu/v1.7.x/python/mxnet/gluon/block.py\", line 979, in _build_cache\n     out = out.optimize_for(self._backend, arg_array, aux_array, ctx, **self._backend_opts)\n   File \"/home/ubuntu/v1.7.x/python/mxnet/symbol/symbol.py\", line 1531, in optimize_for\n     ctypes.byref(new_aux_names)))\n   File \"/home/ubuntu/v1.7.x/python/mxnet/base.py\", line 246, in check_call\n     raise get_last_ffi_error()\n mxnet.base.MXNetError: Traceback (most recent call last):\n   File \"src/operator/subgraph/build_subgraph.cc\", line 80\n MXNetError: Check failed: input_nid < simple_nodes->size() (6 vs. 6) :\n </denchmark-code>\n \n <denchmark-h:h2>To Reproduce</denchmark-h>\n \n <denchmark-code>from mxnet.util import use_np\n from mxnet.gluon import nn, HybridBlock\n import mxnet as mx\n import numpy as np\n attr = {'sg_mkldnn_conv_bn_0' : {'with_bn': 'true'}}\n data = mx.symbol.Variable('data', shape=(64, 4, 10, 10), dtype='float32')\n data2 = mx.symbol.Variable('data2', shape=(64, 64, 10, 10), dtype='float32')\n weight1 = mx.symbol.Variable('conv1_weight', dtype='float32')\n weight2 = mx.symbol.Variable('conv2_weight', dtype='float32', shape=(64,64,1,1))\n conv1 = mx.symbol.Convolution(data=data, weight=weight1, name='conv1', num_filter=64,\n                            kernel=(1, 1), stride=(1, 1), no_bias=True)\n bn1 = mx.symbol.BatchNorm(data=conv1, name=\"bn1\")\n conv2 = mx.symbol.Convolution(data=bn1, weight=weight2, name='conv2', num_filter=64,\n                            kernel=(1, 1), stride=(1, 1), no_bias=True)\n bn2 = mx.symbol.BatchNorm(data=conv2, name=\"bn2\")\n sum = bn2 + data2\n inputs = mx.sym.var('data', dtype='float32')\n sym_block = mx.gluon.SymbolBlock(sum, [inputs])\n for k, v in sym_block.collect_params().items():\n     v.initialize()\n mm = sym_block(mx.nd.zeros((64, 4, 10, 10)))\n sym_block.optimize_for(mx.nd.zeros((64, 4, 10, 10)), backend='MKLDNN_QUANTIZE')\n </denchmark-code>\n \n <denchmark-h:h3>Steps to reproduce</denchmark-h>\n \n \n clone v1.7.x branch and build from source\n run code above\n \n <denchmark-h:h3>Analysis</denchmark-h>\n \n The error is occurring at the  on line 80 where theres a mismatch in the Graph definition (the input of a node is pointing to another node ID that hasnt been seen yet, so this is breaking topological ordering):\n \n \n Some debugging finds that the indexed graph inside of an <denchmark-link:https://github.com/apache/incubator-tvm/blob/master/nnvm/src/core/graph.cc#L31-L36>nnvm::Graph object is only built once</denchmark-link>\n :\n const IndexedGraph& Graph::indexed_graph() const {\n   if (indexed_graph_ == nullptr) {\n     indexed_graph_.reset(new IndexedGraph(*this));\n   }\n   return *indexed_graph_;\n }\n So after subsequent subgraph properties the graph is not updated, causing the error in this issue. Since the indexed_graph_ is private, theres no way to reset it.\n Comparing the get_backend_symbol flow the Graph is created every iteration for each subgraph property and stored in the Symbol between iterations:\n \n \n \n incubator-mxnet/src/c_api/c_api_symbolic.cc\n \n \n         Lines 1302 to 1308\n       in\n       16280ad\n \n \n \n \n \n \n  nnvm::Graph g = Symbol2Graph(*s); \n \n \n \n  property->SetAttr(\"graph\", g); \n \n \n \n  g.attrs[\"subgraph_property\"] = std::make_shared<nnvm::any>(property); \n \n \n \n  g = ApplyPass(std::move(g), \"BuildSubgraph\"); \n \n \n \n  property->RemoveAttr(\"graph\"); \n \n \n \n  g.attrs.erase(\"subgraph_property\"); \n \n \n \n  s->outputs = g.outputs; \n \n \n \n \n \n Where as in the optimize_for flow the Graph is created once:\n \n \n \n incubator-mxnet/src/c_api/c_api_symbolic.cc\n \n \n          Line 1375\n       in\n       16280ad\n \n \n \n \n \n \n  nnvm::Graph g = Symbol2Graph(*s); \n \n \n \n \n \n and then re-used for each subgraph propery:\n \n \n \n incubator-mxnet/src/c_api/c_api_symbolic.cc\n \n \n         Lines 1498 to 1502\n       in\n       16280ad\n \n \n \n \n \n \n  property->PrePartition(g, options_map); \n \n \n \n  g.attrs[\"subgraph_property\"] = std::make_shared<nnvm::any>(property); \n \n \n \n  g = ApplyPass(std::move(g), \"BuildSubgraph\"); \n \n \n \n  g.attrs.erase(\"subgraph_property\"); \n \n \n \n  property->PostPartition(g); \n \n \n \n \n \n So we need to create a new Graph object for each iteration in order to fix this.\n FYI <denchmark-link:https://github.com/mseth10>@mseth10</denchmark-link>\n  <denchmark-link:https://github.com/Kh4L>@Kh4L</denchmark-link>\n  <denchmark-link:https://github.com/ptrendx>@ptrendx</denchmark-link>\n \n \t"}, "comments": {}}, "commit": {"commit_id": "7d3e027846b2767e330d488092e0c12b2d01b36d", "commit_author": "Sam Skalicky", "commitT": "2020-10-02 15:52:30-07:00", "changed_files": {"file_0": {"file_change_type": "MODIFY", "file_Nmethod": 1, "file_old_name": "src\\c_api\\c_api_symbolic.cc", "file_new_name": "src\\c_api\\c_api_symbolic.cc", "hunks": {"hunk_0": {"Ismethod": 1, "added_lines": "1301,1302,1303,1304,1305,1309,1310,1312,1313,1314,1315,1316,1317,1318,1319,1320,1321,1322,1323,1324,1325,1326,1327,1328,1329,1332,1333,1334,1335,1336,1337,1338,1339,1340,1342,1343,1344,1345,1346,1347,1348,1349,1350,1351,1352,1353,1355,1356,1357,1358,1359,1360,1361,1362,1363,1364,1365,1366,1367,1368,1369,1370,1371,1372,1373,1374,1375,1376,1377,1378,1379,1381,1385,1388,1389,1390,1391,1392,1393,1394,1395,1396,1397,1398,1399,1400,1401,1402,1403,1404,1405,1406,1407,1408,1409,1410,1411,1412,1413,1416,1417,1418,1419,1420,1421,1429,1435,1439,1452,1484", "deleted_lines": "1301,1302,1303,1304,1305,1310,1311,1312,1313,1314,1315,1316,1317,1318,1319,1320,1321,1322,1325,1326,1327,1328,1329,1330,1331,1332,1333,1335,1336,1337,1338,1339,1340,1341,1342,1343,1344,1345,1346,1347,1348,1349,1350,1351,1352,1353,1354,1355,1356,1357,1358,1359,1360,1361,1362,1363,1364,1365,1366,1367,1369,1370,1371,1374,1376,1378,1381,1382,1383,1384,1385,1386,1388,1389,1390,1391,1392,1393,1394,1395,1396,1397,1398,1399,1400,1401,1402,1403,1404,1405,1406,1407,1408,1409,1410,1411,1413,1414,1415,1416,1475", "method_info": {"method_name": "MXOptimizeForBackend", "method_params": "sym_handle,backend_name,dev_type,ret_sym_handle,args_len,in_args_handle,aux_len,in_aux_handle,num_options,keys,vals,num_input_shapes,input_shape_names,input_shape_data,input_shape_idx,num_input_dtypes,input_dtype_names,input_dtypes,num_input_stypes,input_stype_names,input_stypes,skip_infer,new_args_cnt,new_args_handle,new_arg_names_handle,new_aux_cnt,new_aux_handle,new_aux_names_handle", "method_startline": "1268", "method_endline": "1487"}}}}}}}