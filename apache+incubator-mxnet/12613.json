{"BR": {"BR_id": "12613", "BR_author": "lovickie", "BRopenT": "2018-09-20T09:55:57Z", "BRcloseT": "2018-09-28T05:39:23Z", "BR_text": {"BRsummary": "Report a bug of Engine::Get()", "BRdescription": "\n GraphExecutor should hold Engine::_GetSharedRef() to a class member engine_ref_, or sometimes Engine might be deconstructed before GraphExecutor was deconstructed. Note that in ~GraphExecutor(), Engine::Get()->DeleteOperator() was called.\n This bug is similar to <denchmark-link:https://github.com/apache/incubator-mxnet/issues/309>#309</denchmark-link>\n  , which has been fixed yet. In this bug, sometimes ObjectPool<ThreadedOpr>, ObjectPool<OprBlock>, ObjectPool<VersionedVarBlock>, common::ObjectPool<ThreadedVar>, might be deconstructed before ThreadedEngine was deconstructed.\n Why this shared_ptr bug appears everywhere? It's a general C++ problem. A simple example as follow:\n engine.h\n <denchmark-code>#pragma once\n \n #include <memory>\n \n class Eng {\n  public:\n   virtual ~Eng() = default;\n   virtual void Print() const = 0;\n };\n \n // src/engine/engine.cc\n class Engine : public Eng {\n  public:\n   Engine();\n   ~Engine();\n \n   static std::shared_ptr<Engine> _GetSharedRef();\n   static Engine* Get();\n \n   void Print() const;\n \n  private:\n   char *name_ = nullptr;\n };\n \n typedef Eng *get_t();\n typedef std::shared_ptr<Engine> get_ref_t();\n </denchmark-code>\n \n engine.cc\n <denchmark-code>#include \"engine.h\"\n \n #include <stdio.h>\n \n Engine::Engine() {\n   name_ = new char[8];\n   snprintf(name_, 8, \"HELLO\");\n }\n \n Engine::~Engine() {\n   printf(\"BEGIN ~Engine\\n\");\n   if (name_)  delete name_;\n   printf(\"  END ~Engine\\n\");\n }\n \n std::shared_ptr<Engine> Engine::_GetSharedRef() {\n   static std::shared_ptr<Engine> sptr(new Engine());\n   return sptr;\n }\n \n Engine* Engine::Get() {\n   static Engine *inst = _GetSharedRef().get();    // Dangerous!\n   return inst;\n }\n \n void Engine::Print() const {\n   printf(\"name=%s\\n\", name_);\n }\n \n extern \"C\" Eng *get() {\n   return Engine::Get();\n }\n \n extern \"C\" std::shared_ptr<Engine> get_ref() {\n   return Engine::_GetSharedRef();\n }\n </denchmark-code>\n \n executor.h\n <denchmark-code>#pragma once\n \n #include <memory>\n \n #include \"engine.h\"\n \n class Executor {\n  public:\n   virtual ~Executor() = default;\n   virtual void Print() = 0;\n };\n \n // src/executor/graph_executor.cc\n class GraphExecutor : public Executor {\n  public:\n   GraphExecutor(void *eng);\n   ~GraphExecutor();\n \n   static std::shared_ptr<GraphExecutor> _GetSharedRef(void *eng);\n   static GraphExecutor* Get(void *eng);\n \n   void Print();\n \n  private:\n   void *eng_;\n   std::shared_ptr<Engine> engine_ref_;  // TODO: important!\n };\n \n typedef Executor *create_t(void *);\n </denchmark-code>\n \n executor.cc\n <denchmark-code>#include \"executor.h\"\n \n #include <dlfcn.h>\n #include <stdio.h>\n \n #include \"engine.h\"\n \n GraphExecutor::GraphExecutor(void *eng) {\n   eng_ = eng;\n \n   get_ref_t *get_ref = (get_ref_t *) dlsym(eng_, \"get_ref\");\n   engine_ref_ = get_ref();  // TODO: important!\n }\n \n GraphExecutor::~GraphExecutor() {\n   printf(\"BEGIN ~GraphExecutor\\n\");\n   Print();\n   printf(\"  END ~GraphExecutor\\n\");\n }\n \n void GraphExecutor::Print() {\n   get_t *get = (get_t *) dlsym(eng_, \"get\");\n   Eng *eng = get();\n   eng->Print();\n }\n \n std::shared_ptr<GraphExecutor> GraphExecutor::_GetSharedRef(void *eng) {\n   static std::shared_ptr<GraphExecutor> sptr(new GraphExecutor(eng));\n   return sptr;\n }\n \n GraphExecutor* GraphExecutor::Get(void *eng) {\n   static GraphExecutor *inst = _GetSharedRef(eng).get();    // Dangerous!\n   return inst;\n }\n \n extern \"C\" Executor *create(void *eng) {\n   return GraphExecutor::Get(eng);\n }\n </denchmark-code>\n \n test.cc\n <denchmark-code>#include \"engine.h\"\n #include \"executor.h\"\n \n #include <dlfcn.h>\n #include <stdio.h>\n \n int main() {\n   void *handle_engine = dlopen(\"libengine.so\", RTLD_LAZY);\n   void *handle = dlopen(\"libexe.so\", RTLD_LAZY);\n \n   create_t *create = (create_t *) dlsym(handle, \"create\");\n   Executor *executor = create(handle_engine);\n   executor->Print();\n \n   //dlclose(handle_engine);\n   //dlclose(handle);\n   return 0;\n }\n </denchmark-code>\n \n Makefile\n <denchmark-code>all:\n \tgcc -std=c++11 -g engine.cc -fPIC -shared -o libengine.so\n \tgcc -std=c++11 -g executor.cc -fPIC -shared -o libexe.so\n \tg++ -std=c++11 -g test.cc -rdynamic -ldl -o b.out\n </denchmark-code>\n \n make\n ./b.out\n You will run well. But if there is no \"engine_ref_ = get_ref();\" in GraphExecutor::GraphExecutor(void *eng), it will coredump. This is the same problem as the bug.\n \t"}, "comments": {"comments_0": {"comment_id": 1, "comment_author": "lovickie", "commentT": "2018-09-20T10:05:38Z", "comment_text": "\n \t\tI don't know how to paste the code elegantly, would anyone teach me please....\n \t\t"}, "comments_1": {"comment_id": 2, "comment_author": "lovickie", "commentT": "2018-09-20T13:26:39Z", "comment_text": "\n \t\t<denchmark-link:https://github.com/lovickie>@lovickie</denchmark-link>\n  You should use   to surround your code.\n AFAIK, destruction order has been a long-standing problem here. Many years ago, when C++ 11 was not that popular, there were naked pointers everywhere...There should have been tons of PRs trying to fix this, but if there is any problem, you are more than welcome to submit a PR.\n \t\t"}, "comments_2": {"comment_id": 3, "comment_author": "lovickie", "commentT": "2018-09-20T16:11:16Z", "comment_text": "\n \t\tThanks for submitting the issue <denchmark-link:https://github.com/lovickie>@lovickie</denchmark-link>\n \n <denchmark-link:https://github.com/mxnet-label-bot>@mxnet-label-bot</denchmark-link>\n  [Bug, Backend, C]\n \t\t"}, "comments_3": {"comment_id": 4, "comment_author": "lovickie", "commentT": "2018-09-21T06:44:07Z", "comment_text": "\n \t\tMore information as follows.\n My project x, use mxnet to do sth, and also provides python api. When import mxnet before import x, the destruction ran well. But if import x before import mxnet, it would coredump when destruction. Finally I found this bug.\n Thank reviewers for checking my PR.\n \t\t"}, "comments_4": {"comment_id": 5, "comment_author": "lovickie", "commentT": "2018-09-26T18:11:31Z", "comment_text": "\n \t\tThe PR has been merged. <denchmark-link:https://github.com/lovickie>@lovickie</denchmark-link>\n  Can this issue be closed?\n \t\t"}, "comments_5": {"comment_id": 6, "comment_author": "lovickie", "commentT": "2018-09-27T20:23:40Z", "comment_text": "\n \t\t<denchmark-link:https://github.com/sandeep-krishnamurthy>@sandeep-krishnamurthy</denchmark-link>\n   Please close this issue.\n <denchmark-link:https://github.com/lovickie>@lovickie</denchmark-link>\n  Please feel free to reopen if this issue has been closed in error.\n \t\t"}}}, "commit": {"commit_id": "d4e202a5d4152b540be970525f2bb91b62ebf148", "commit_author": "lovickie", "commitT": "2018-09-26 10:59:39-07:00", "changed_files": {"file_0": {"file_change_type": "MODIFY", "file_Nmethod": 1, "file_old_name": "src\\executor\\graph_executor.cc", "file_new_name": "src\\executor\\graph_executor.cc", "hunks": {"hunk_0": {"Ismethod": 1, "added_lines": "47", "deleted_lines": null, "method_info": {"method_name": "mxnet::exec::GraphExecutor::GraphExecutor", "method_params": "", "method_startline": "43", "method_endline": "48"}}}}, "file_1": {"file_change_type": "MODIFY", "file_Nmethod": 0, "file_old_name": "src\\executor\\graph_executor.h", "file_new_name": "src\\executor\\graph_executor.h", "hunks": {"hunk_0": {"Ismethod": 0, "added_lines": "263,264", "deleted_lines": null}}}}}}