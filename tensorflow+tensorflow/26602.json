{"BR": {"BR_id": "26602", "BR_author": "vbardiovskyg", "BRopenT": "2019-03-12T10:29:27Z", "BRcloseT": "2019-04-18T08:40:52Z", "BR_text": {"BRsummary": "Partial function specified through keyword on first position in tf.function", "BRdescription": "\n Wrapping in tf.function a partial with first argument specified:\n <denchmark-code>def f(x, y):\n   return x + y\n \n partial_func = functools.partial(f, x=5)\n tf_func = tf.function(partial_func)\n \n print(tf_func(5))\n </denchmark-code>\n \n This does not work in Python2.x, because <denchmark-link:https://github.com/tensorflow/tensorflow/blob/c46d383150564c8b72b05acc65182c16f7221694/tensorflow/python/util/tf_inspect.py#L175>tf_inspect.getfullargspec cannot represent such construct</denchmark-link>\n  using Argspec.\n Unfortunately this also does not work in Python3, where Argspecs are already capable of representing this:\n <denchmark-code>TypeError: tf__f() got multiple values for argument 'x'\n </denchmark-code>\n \n \t"}, "comments": {"comments_0": {"comment_id": 1, "comment_author": "vbardiovskyg", "commentT": "2019-03-12T15:41:35Z", "comment_text": "\n \t\tCan we isolate this issue to misbehavior of getfullargspec instead of tf.function?\n I ask because as far as tf.function is concerned nothing breaks if we just wrap the partial call into a lambda *args, **kwds: partial_call(*args, **kwds) so we should probably just do that at intake time if the user passes a functools.partial function.\n \t\t"}, "comments_1": {"comment_id": 2, "comment_author": "vbardiovskyg", "commentT": "2019-03-14T14:24:48Z", "comment_text": "\n \t\tI am not actually sure that this is a misbehavior of getfullargspec.\n Currently we are using ArgSpec to be able to bind arguments to (partial or normal) function later. We want to represent partial function fully with ArgSpec, but this is not possible with Python2.x: it is not possible to have arguments with defaults before arguments without defaults.\n I would consider this more an integration issue. For example, do we really need to represent partial function using getfullargspec on the inner function (the one with more arguments)? Could we somehow forget about the inner partial and work with the outer only? I haven't tried it myself.\n \t\t"}, "comments_2": {"comment_id": 3, "comment_author": "vbardiovskyg", "commentT": "2019-03-14T15:30:59Z", "comment_text": "\n \t\tI think we should do the latter and forget about the inner partial.\n \n Or we should not rely on argspec for this at all and instead look at the\n arguments as they're presented at calling time (which I much prefer).\n <denchmark-link:#>\u2026</denchmark-link>\n \n \n On Thu, Mar 14, 2019 at 7:30 AM Vojtech Bardiovsky ***@***.***> wrote:\n  I am not actually sure that this is a misbehavior of getfullargspec.\n \n  Currently we are using ArgSpec to be able to bind arguments to (partial or\n  normal) function later. We want to represent partial function fully with\n  ArgSpec, but this is not possible with Python2.x: it is not possible to\n  have arguments with defaults before arguments without defaults.\n \n  I would consider this more an integration issue. For example, do we really\n  need to represent partial function using getfullargspec on the inner\n  function (the one with more arguments)? Could we somehow forget about the\n  inner partial and work with the outer only? I haven't tried it myself.\n \n  \u2014\n  You are receiving this because you commented.\n  Reply to this email directly, view it on GitHub\n  <#26602 (comment)>,\n  or mute the thread\n  <https://github.com/notifications/unsubscribe-auth/AAATxWfus7xJCyx0oit5DEAcSXFRFacdks5vWl0OgaJpZM4bqjiP>\n  .\n \n \n -- \n  - Alex\n \n \t\t"}, "comments_3": {"comment_id": 4, "comment_author": "vbardiovskyg", "commentT": "2019-03-25T23:06:50Z", "comment_text": "\n \t\t<denchmark-link:https://github.com/vbardiovskyg>@vbardiovskyg</denchmark-link>\n  I think you're working on this, right?\n \t\t"}, "comments_4": {"comment_id": 5, "comment_author": "vbardiovskyg", "commentT": "2019-04-18T08:40:52Z", "comment_text": "\n \t\tSince we are now depending on partial to do the argument binding, this becomes infeasible (i.e. we don't want to provide more functionality than partial already does).\n \t\t"}, "comments_5": {"comment_id": 6, "comment_author": "vbardiovskyg", "commentT": "2019-04-18T08:40:53Z", "comment_text": "\n \t\tAre you satisfied with the resolution of your issue?\n <denchmark-link:https://docs.google.com/forms/d/e/1FAIpQLSfaP12TRhd9xSxjXZjcZFNXPGk4kc1-qMdv3gc6bEP90vY1ew/viewform?entry.85265664=Yes&entry.2137816233=26602>Yes</denchmark-link>\n \n <denchmark-link:https://docs.google.com/forms/d/e/1FAIpQLSfaP12TRhd9xSxjXZjcZFNXPGk4kc1-qMdv3gc6bEP90vY1ew/viewform?entry.85265664=No&entry.2137816233=26602>No</denchmark-link>\n \n \t\t"}, "comments_6": {"comment_id": 7, "comment_author": "vbardiovskyg", "commentT": "2020-04-03T23:01:17Z", "comment_text": "\n \t\t<denchmark-link:https://github.com/vbardiovskyg>@vbardiovskyg</denchmark-link>\n   Please see comments in the following code (TF 2.2.0rc2).  Why does the first case succeed and second fail?  Is this a bug?  Thanks.\n import tensorflow as tf\n import functools\n \n def f(x, y):\n     return x + y\n \n bind_x = functools.partial(f, x=1)\n bind_y = functools.partial(f, y=1)\n \n dataset = tf.data.Dataset.range(1)\n \n print(next(iter(dataset.map(bind_y))))  # This works\n print(next(iter(dataset.map(bind_x))))  # TypeError: tf__f() got multiple values for argument 'x'\n \t\t"}, "comments_7": {"comment_id": 8, "comment_author": "vbardiovskyg", "commentT": "2020-04-06T05:12:32Z", "comment_text": "\n \t\tHi <denchmark-link:https://github.com/mmilosav>@mmilosav</denchmark-link>\n ,\n this is due to how partial works. See the following snippet using partial outside of TensorFlow context:\n <denchmark-code>def f(x,y):\n   print(x+y)\n \n bind_x = functools.partial(f, x=1)\n \n bind_x(3)  # TypeError: f() got multiple values for argument 'x'\n </denchmark-code>\n \n \t\t"}}}, "commit": {"commit_id": "4e4943edc3d2409bffb5776f99b941987d6eda82", "commit_author": "Vojtech Bardiovsky", "commitT": "2019-04-10 01:50:12-07:00", "changed_files": {"file_0": {"file_change_type": "MODIFY", "file_Nmethod": 0, "file_old_name": "tensorflow\\core\\protobuf\\saved_object_graph.proto", "file_new_name": "tensorflow\\core\\protobuf\\saved_object_graph.proto", "hunks": {"hunk_0": {"Ismethod": 0, "added_lines": "146,147", "deleted_lines": "144,145,146,147,148,149"}}}, "file_1": {"file_change_type": "MODIFY", "file_Nmethod": 1, "file_old_name": "tensorflow\\python\\eager\\def_function.py", "file_new_name": "tensorflow\\python\\eager\\def_function.py", "hunks": {"hunk_0": {"Ismethod": 1, "added_lines": "319", "deleted_lines": null, "method_info": {"method_name": "_defun_with_scope", "method_params": "self,scope", "method_startline": "293", "method_endline": "319"}}}}, "file_2": {"file_change_type": "MODIFY", "file_Nmethod": 4, "file_old_name": "tensorflow\\python\\eager\\def_function_test.py", "file_new_name": "tensorflow\\python\\eager\\def_function_test.py", "hunks": {"hunk_0": {"Ismethod": 1, "added_lines": "248,249,252,253,254", "deleted_lines": "248,249,252,253,254", "method_info": {"method_name": "test_functools_partial_new_default", "method_params": "self", "method_startline": "248", "method_endline": "254"}}, "hunk_1": {"Ismethod": 1, "added_lines": "249", "deleted_lines": "249", "method_info": {"method_name": "test_functools_partial_new_default.f", "method_params": "x,y", "method_startline": "249", "method_endline": "250"}}, "hunk_2": {"Ismethod": 1, "added_lines": "248,249,252,253,254", "deleted_lines": "248,249,252,253,254,255,256,257,258,259", "method_info": {"method_name": "test_functools_partial_single_keyword", "method_params": "self", "method_startline": "248", "method_endline": "259"}}, "hunk_3": {"Ismethod": 1, "added_lines": "249", "deleted_lines": "249", "method_info": {"method_name": "test_functools_partial_single_keyword.f", "method_params": "x,y", "method_startline": "249", "method_endline": "250"}}}}, "file_3": {"file_change_type": "MODIFY", "file_Nmethod": 2, "file_old_name": "tensorflow\\python\\eager\\function.py", "file_new_name": "tensorflow\\python\\eager\\function.py", "hunks": {"hunk_0": {"Ismethod": 1, "added_lines": null, "deleted_lines": "1100,1101", "method_info": {"method_name": "canonicalize_function_inputs", "method_params": "self,args,kwargs", "method_startline": "1061", "method_endline": "1140"}}, "hunk_1": {"Ismethod": 1, "added_lines": "976,977,978,979,980,981,982,983,984,985,986,987,988,989,990,991,992,993,994,995,996,997,998,999,1000,1001,1002,1003,1004,1005,1006,1007,1008,1009,1010,1011", "deleted_lines": "975,976,977,978,979,980,981,982,983,984,985,986,987,988,989,990,991,992,998,999", "method_info": {"method_name": "from_function_and_signature", "method_params": "python_function,input_signature", "method_startline": "974", "method_endline": "1011"}}}}, "file_4": {"file_change_type": "MODIFY", "file_Nmethod": 4, "file_old_name": "tensorflow\\python\\eager\\function_test.py", "file_new_name": "tensorflow\\python\\eager\\function_test.py", "hunks": {"hunk_0": {"Ismethod": 1, "added_lines": "1762,1763,1765,1767,1768,1769,1770,1771,1772,1773,1774", "deleted_lines": "1762,1763,1764,1765,1768,1769,1770,1771,1772,1773,1774,1775,1776", "method_info": {"method_name": "testInputSignatureWithKeywordArgsFails", "method_params": "self", "method_startline": "1762", "method_endline": "1776"}}, "hunk_1": {"Ismethod": 1, "added_lines": "1765", "deleted_lines": "1764,1765", "method_info": {"method_name": "testInputSignatureWithKeywordArgsFails.foo", "method_params": "a,kwargs", "method_startline": "1764", "method_endline": "1766"}}, "hunk_2": {"Ismethod": 1, "added_lines": "1763,1765", "deleted_lines": "1763,1764,1765", "method_info": {"method_name": "testInputSignatureWithKeywordArgs.foo", "method_params": "a,b,kwargs", "method_startline": "1763", "method_endline": "1765"}}, "hunk_3": {"Ismethod": 1, "added_lines": "1762,1763,1765,1767,1768,1769,1770,1771,1772,1773,1774", "deleted_lines": "1762,1763,1764,1765,1768,1769,1770,1771,1772,1773,1774", "method_info": {"method_name": "testInputSignatureWithKeywordArgs", "method_params": "self", "method_startline": "1762", "method_endline": "1774"}}}}, "file_5": {"file_change_type": "MODIFY", "file_Nmethod": 2, "file_old_name": "tensorflow\\python\\saved_model\\function_deserialization.py", "file_new_name": "tensorflow\\python\\saved_model\\function_deserialization.py", "hunks": {"hunk_0": {"Ismethod": 1, "added_lines": "186,187,188,189", "deleted_lines": null, "method_info": {"method_name": "_defun_with_scope", "method_params": "self,scope", "method_startline": "186", "method_endline": "189"}}, "hunk_1": {"Ismethod": 1, "added_lines": "144,145", "deleted_lines": "141,142,146", "method_info": {"method_name": "_deserialize_function_spec_as_nonmethod", "method_params": "function_spec_proto,coder", "method_startline": "119", "method_endline": "146"}}}}, "file_6": {"file_change_type": "MODIFY", "file_Nmethod": 1, "file_old_name": "tensorflow\\python\\saved_model\\function_serialization.py", "file_new_name": "tensorflow\\python\\saved_model\\function_serialization.py", "hunks": {"hunk_0": {"Ismethod": 1, "added_lines": null, "deleted_lines": "35,36,37,38", "method_info": {"method_name": "_serialize_function_spec", "method_params": "function_spec,coder", "method_startline": "26", "method_endline": "41"}}}}, "file_7": {"file_change_type": "MODIFY", "file_Nmethod": 10, "file_old_name": "tensorflow\\python\\saved_model\\load_test.py", "file_new_name": "tensorflow\\python\\saved_model\\load_test.py", "hunks": {"hunk_0": {"Ismethod": 1, "added_lines": "1231", "deleted_lines": null, "method_info": {"method_name": "test_partial_with_passed_fn_as_default", "method_params": "self,cycles", "method_startline": "1231", "method_endline": "1245"}}, "hunk_1": {"Ismethod": 1, "added_lines": "1213,1214,1215,1216,1217,1218,1219,1220,1221,1222,1223,1224,1225,1226,1227,1228,1229", "deleted_lines": null, "method_info": {"method_name": "test_partial_keyword_hiding_default", "method_params": "self,cycles", "method_startline": "1213", "method_endline": "1229"}}, "hunk_2": {"Ismethod": 1, "added_lines": "1174", "deleted_lines": "1160,1161,1162", "method_info": {"method_name": "test_partial", "method_params": "self,cycles", "method_startline": "1159", "method_endline": "1174"}}, "hunk_3": {"Ismethod": 1, "added_lines": "1174", "deleted_lines": null, "method_info": {"method_name": "test_partial_with_non_tensor_defaults.f", "method_params": "x,y", "method_startline": "1174", "method_endline": "1175"}}, "hunk_4": {"Ismethod": 1, "added_lines": "1199,1200,1201,1202,1203", "deleted_lines": "1190,1191,1192", "method_info": {"method_name": "test_partial_with_positional", "method_params": "self,cycles", "method_startline": "1189", "method_endline": "1203"}}, "hunk_5": {"Ismethod": 1, "added_lines": "1199,1200,1201,1202,1203,1204,1205,1206,1207,1208,1209,1210,1211", "deleted_lines": "1205,1206,1207", "method_info": {"method_name": "test_partial_with_positional_captured_tensors", "method_params": "self,cycles", "method_startline": "1199", "method_endline": "1211"}}, "hunk_6": {"Ismethod": 1, "added_lines": "1174", "deleted_lines": "1177", "method_info": {"method_name": "test_partial_with_non_tensor_defaults", "method_params": "self,cycles", "method_startline": "1173", "method_endline": "1184"}}, "hunk_7": {"Ismethod": 1, "added_lines": null, "deleted_lines": "1177", "method_info": {"method_name": "test_partial_with_non_tensor_defaults.f", "method_params": "x,y", "method_startline": "1177", "method_endline": "1178"}}, "hunk_8": {"Ismethod": 1, "added_lines": "1200,1201", "deleted_lines": null, "method_info": {"method_name": "test_partial_with_positional_captured_tensors.f", "method_params": "x,y", "method_startline": "1200", "method_endline": "1201"}}, "hunk_9": {"Ismethod": 1, "added_lines": "1214,1215,1216,1217,1218", "deleted_lines": null, "method_info": {"method_name": "test_partial_keyword_hiding_default.f", "method_params": "x,training,y", "method_startline": "1214", "method_endline": "1218"}}}}}}}