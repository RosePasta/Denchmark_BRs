{"BR": {"BR_id": "15891", "BR_author": "ghost(ghost)", "BRopenT": "2018-01-05T21:51:29Z", "BRcloseT": "2018-02-06T18:29:02Z", "BR_text": {"BRsummary": "Dependencies of tensors created within a tf.while_loop() might not be executed", "BRdescription": "\n <denchmark-h:h3>System information</denchmark-h>\n \n \n Have I written custom code (as opposed to using a stock example script provided in TensorFlow): Yes. See test case below.\n OS Platform and Distribution (e.g., Linux Ubuntu 16.04): macOS 'Sierra' Version 10.12.6 (16G1114)\n TensorFlow installed from (source or binary): Both. I have compiled TensorFlow at 136697e with my small change in PR #15823. I have also tried using the pip package.\n TensorFlow version (use command below): ('v1.4.0-19-ga52c8d9b01', '1.4.1') (pip package)\n Python version: 2.7.10\n Bazel version (if compiling from source): 0.9.0-homebrew\n GCC/Compiler version (if compiling from source): Apple LLVM version 8.1.0 (clang-802.0.42)\n CUDA/cuDNN version: CUDA 9.0.176_mac, cuDNN 9.0-osx-x64-v7\n GPU model and memory: NVIDIA GeForce GT 750M with 2048 MB device memory (CUDA Compute Capability 3.0)\n Exact command to reproduce:\n \n python repro.py\n .. where repro.py contains the test case to reproduce, listed below.\n <denchmark-h:h3>Describe the problem</denchmark-h>\n \n Here is my test case:\n # Part I\n from __future__ import division, print_function\n import numpy as np\n import tensorflow as tf\n from tensorflow.python.ops import resource_variable_ops as rr\n \n rs = np.random.RandomState(seed = 2)\n A = rs.normal(size = (10, 10,))\n print('singular values of A: %s' % (np.linalg.svd(A, compute_uv = False),))\n B = rs.normal(size = (10, 10,))\n print('singular values of B: %s' % (np.linalg.svd(B, compute_uv = False),))\n \n \n \n # Part II\n A_var = tf.Variable(B)\n init_A_var_op = tf.assign(A_var, A)\n A_dep = tf.constant(10, tf.int32)\n \n with tf.control_dependencies([init_A_var_op]):\n     A_dep = A_dep + 1\n \n with tf.control_dependencies([A_dep]):\n     var_s = tf.svd(A_var, compute_uv = False)\n with tf.Session() as session:\n     session.run(tf.global_variables_initializer())\n     computed_s, computed_A_dep = session.run([var_s, A_dep])\n print('computed_s = %s, computed_A_dep = %d' % (computed_s, computed_A_dep,))\n \n \n \n # Part III\n A_var = tf.Variable(B)\n init_A_var_op = tf.assign(A_var, A)\n A_dep = tf.constant(9, tf.int32)\n \n def loop_condition(j, A_dep):\n     return j < 1\n def loop_body(j, A_dep):\n     with tf.control_dependencies([init_A_var_op]):\n         A_dep = A_dep + 1\n     return j + 1, A_dep\n \n _, A_dep = tf.while_loop(loop_condition,\n                          loop_body,\n                          loop_vars = [tf.constant(0, tf.int32), A_dep],\n                          parallel_iterations = 1,\n                          back_prop = False)\n \n with tf.control_dependencies([A_dep]):\n     var_s = tf.svd(A_var, compute_uv = False)\n with tf.Session() as session:\n     session.run(tf.global_variables_initializer())\n     computed_s, computed_A_dep = session.run([var_s, A_dep])\n print('computed_s = %s, computed_A_dep = %d' % (computed_s, computed_A_dep,))\n \n \n \n # Part IV\n A_var = rr.ResourceVariable(B)\n init_A_var_op = A_var.assign(A)\n A_dep = tf.constant(8, tf.int32)\n \n def loop_condition(j, A_dep):\n     return j < 1\n def loop_body(j, A_dep):\n     with tf.control_dependencies([init_A_var_op]):\n         A_dep = A_dep + 1\n     return j + 1, A_dep\n \n _, A_dep = tf.while_loop(loop_condition,\n                          loop_body,\n                          loop_vars = [tf.constant(0, tf.int32), A_dep],\n                          parallel_iterations = 1,\n                          back_prop = False)\n \n with tf.control_dependencies([A_dep]):\n     var_s = tf.svd(A_var.read_value(), compute_uv = False)\n with tf.Session() as session:\n     session.run(tf.global_variables_initializer())\n     computed_s, computed_A_dep = session.run([var_s, A_dep])\n print('computed_s = %s, computed_A_dep = %d' % (computed_s, computed_A_dep,))\n Part I is basic setup. I create two random 10\u00d710 matrices and compute their singular values:\n singular values of A: [ 5.65906715  4.9420261   4.40626739  3.73506125  2.70703249  2.57429488\n   1.73387162  1.16000494  0.58836563  0.39101954]\n singular values of B: [ 7.0283055   4.65840063  4.48502098  3.25319445  2.94667168  2.74267484\n   1.86004291  1.6626967   0.63884034  0.27131664]\n \n Part II shows usage of control_dependencies() to guarantee that A has been assigned to A_var before the singular values of A_var are computed. The output from this part is:\n computed_s = [ 5.65906715  4.9420261   4.40626739  3.73506125  2.70703249  2.57429488\n   1.73387162  1.16000494  0.58836563  0.39101954], computed_A_dep = 11\n \n (This is the expected result for Part II.)\n In Part III, I have introduced use of a tf.while_loop(). Now, tf.svd() is returning the singular values of B:\n computed_s = [ 7.0283055   4.65840063  4.48502098  3.25319445  2.94667168  2.74267484\n   1.86004291  1.6626967   0.63884034  0.27131664], computed_A_dep = 10\n \n (This is not the expected result for Part III. I expect that the singular values of A would be printed.)\n In Part IV, based on reading <denchmark-link:https://github.com/tensorflow/tensorflow/issues/4663#issuecomment-336609536>#4663 (comment)</denchmark-link>\n  , I switched to using . However, the output is still the same (the singular values of ):\n computed_s = [ 7.0283055   4.65840063  4.48502098  3.25319445  2.94667168  2.74267484\n   1.86004291  1.6626967   0.63884034  0.27131664], computed_A_dep = 9\n \n (This is not the expected result for Part IV. I expect that the singular values of A would be printed.)\n It appears the issue is that tf.control_dependencies() on tensors created by tf.while_loop() might not execute the tensors' own dependencies.\n This used to work okay (around TensorFlow 1.1, if I recall correctly).\n While searching for a previous report of this issue, I found <denchmark-link:https://github.com/tensorflow/tensorflow/issues/6087>#6087</denchmark-link>\n  which appears related, in that the sample code there has a tf.while_loop() that creates tensors with dependencies. When I run the sample code, I consistently get result = 10. This is an unexpected result, in my opinion. What is happening is that  runs exactly once, so for each of the 5 loop iterations,  has the value 2.\n I tried rewriting the sample code to use a ResourceVariable, but the output is the same:\n from __future__ import division, print_function\n import tensorflow as tf\n from tensorflow.python.ops import resource_variable_ops as rr\n \n with tf.variable_scope('state'):\n     x = rr.ResourceVariable(tf.constant(1, dtype=tf.float32))\n     update_x = x.assign(x.read_value() + 1)\n \n def iter_fun(i, y):\n     # comment the line below, the program will run without any error\n     # but I need control_dependencies, or at least some way to replace it...\n     with tf.control_dependencies([update_x]):\n         y = y + tf.Print(x.read_value(), ['i = ', i, 'y = ', y, 'x = ', x.read_value()])\n     return (i+1, y,)\n \n with tf.variable_scope('iteration'):\n     num_iterations = 5\n     initial_i = tf.constant(0, dtype=tf.int32)\n     initial_y = tf.constant(0, dtype=tf.float32)\n     _, result = tf.while_loop(\n         cond=lambda i, *_: i < num_iterations,\n         body=iter_fun,\n         loop_vars=(initial_i, initial_y))\n \n init_op = tf.global_variables_initializer()\n \n with tf.Session() as sess:\n     sess.run(init_op)\n     print(sess.run(result))\n \t"}, "comments": {"comments_0": {"comment_id": 1, "comment_author": "ghost(ghost)", "commentT": "2018-01-11T21:54:17Z", "comment_text": "\n \t\t<denchmark-link:https://github.com/ebrevdo>@ebrevdo</denchmark-link>\n  Do you have any thoughts on this or know who would know it best?\n \t\t"}, "comments_1": {"comment_id": 2, "comment_author": "ghost(ghost)", "commentT": "2018-01-11T22:03:58Z", "comment_text": "\n \t\tCan you write a much smaller minimal failing test?\n \t\t"}, "comments_2": {"comment_id": 3, "comment_author": "ghost(ghost)", "commentT": "2018-01-11T22:04:25Z", "comment_text": "\n \t\toh wait; i see you did!\n \t\t"}, "comments_3": {"comment_id": 4, "comment_author": "ghost(ghost)", "commentT": "2018-01-11T22:05:22Z", "comment_text": "\n \t\tTry passing parallel_iterations=1 to your while_loop call.\n \t\t"}, "comments_4": {"comment_id": 5, "comment_author": "ghost(ghost)", "commentT": "2018-01-11T22:16:57Z", "comment_text": "\n \t\tI just now tried adding  to my adapted <denchmark-link:https://github.com/tensorflow/tensorflow/issues/6087>#6087</denchmark-link>\n  test case, but this didn't fix the problem.\n As for the first test case, you can take Parts I and III separately to reproduce the issue:\n from __future__ import division, print_function\n import numpy as np\n import tensorflow as tf\n from tensorflow.python.ops import resource_variable_ops as rr\n \n rs = np.random.RandomState(seed = 2)\n A = rs.normal(size = (10, 10,))\n print('singular values of A: %s' % (np.linalg.svd(A, compute_uv = False),))\n B = rs.normal(size = (10, 10,))\n print('singular values of B: %s' % (np.linalg.svd(B, compute_uv = False),))\n \n A_var = tf.Variable(B)\n init_A_var_op = tf.assign(A_var, A)\n A_dep = tf.constant(9, tf.int32)\n \n def loop_condition(j, A_dep):\n     return j < 1\n def loop_body(j, A_dep):\n     with tf.control_dependencies([init_A_var_op]):\n         A_dep = A_dep + 1\n     return j + 1, A_dep\n \n _, A_dep = tf.while_loop(loop_condition,\n                          loop_body,\n                          loop_vars = [tf.constant(0, tf.int32), A_dep],\n                          parallel_iterations = 1,\n                          back_prop = False)\n \n with tf.control_dependencies([A_dep]):\n     var_s = tf.svd(A_var, compute_uv = False)\n with tf.Session() as session:\n     session.run(tf.global_variables_initializer())\n     computed_s, computed_A_dep = session.run([var_s, A_dep])\n print('computed_s = %s, computed_A_dep = %d' % (computed_s, computed_A_dep,))\n (Alternatively, take Parts I and IV separately.)\n computed_s is the vector of singular values of B, whereas I am expecting that it will be the singular values of A.\n \t\t"}, "comments_5": {"comment_id": 6, "comment_author": "ghost(ghost)", "commentT": "2018-01-23T23:06:34Z", "comment_text": "\n \t\tA member of the TensorFlow organization has replied after the stat:awaiting tensorflower label was applied.\n \t\t"}, "comments_6": {"comment_id": 7, "comment_author": "ghost(ghost)", "commentT": "2018-01-30T00:30:57Z", "comment_text": "\n \t\t/CC <denchmark-link:https://github.com/alextp>@alextp</denchmark-link>\n  can you take a look?\n \t\t"}, "comments_7": {"comment_id": 8, "comment_author": "ghost(ghost)", "commentT": "2018-01-30T00:38:47Z", "comment_text": "\n \t\tCan you add a print(tf.get_default_graph().as_graph_def()) so I can understand how we're generating the wrong graph? (i.e. are control dependencies missing, mangled, or ignored because of weird variable stuff)\n \t\t"}, "comments_8": {"comment_id": 9, "comment_author": "ghost(ghost)", "commentT": "2018-01-30T02:09:17Z", "comment_text": "\n \t\tI created a gist for the graph def: <denchmark-link:https://gist.github.com/dtrebbien/f917cb2891e0b141b9fa6323a3c55239>https://gist.github.com/dtrebbien/f917cb2891e0b141b9fa6323a3c55239</denchmark-link>\n \n Here is the exact modified test case that I used to print the graph def:\n from __future__ import division, print_function\n import numpy as np\n import tensorflow as tf\n \n rs = np.random.RandomState(seed = 2)\n A = rs.normal(size = (10, 10,))\n print('singular values of A: %s' % (np.linalg.svd(A, compute_uv = False),))\n B = rs.normal(size = (10, 10,))\n print('singular values of B: %s' % (np.linalg.svd(B, compute_uv = False),))\n \n graph = tf.Graph()\n with graph.as_default():\n     A_var = tf.Variable(B, name = 'A_var')\n     init_A_var_op = tf.assign(A_var, A, name = 'init_A_var_op')\n     A_dep = tf.constant(9, tf.int32, name = 'initial_A_dep')\n \n     def loop_condition(j, A_dep):\n         return j < 1\n     def loop_body(j, A_dep):\n         with tf.control_dependencies([init_A_var_op]):\n             A_dep = tf.add(A_dep, 1, name = 'increment_A_dep')\n         return j + 1, A_dep\n \n     _, A_dep = tf.while_loop(loop_condition,\n                              loop_body,\n                              loop_vars = [tf.constant(0, tf.int32), A_dep],\n                              parallel_iterations = 1,\n                              back_prop = False)\n \n     with tf.control_dependencies([A_dep]):\n         var_s = tf.svd(A_var, compute_uv = False)\n \n print(graph.as_graph_def())\n \n with tf.Session(graph = graph) as session:\n     session.run(tf.global_variables_initializer())\n     computed_A_dep, computed_s, computed_A_dep2 = session.run([A_dep, var_s, A_dep])\n     assert computed_A_dep == computed_A_dep2\n print('computed_s = %s, computed_A_dep = %d' % (computed_s, computed_A_dep,))\n By the way, is there a utility that can graphically display this?\n \t\t"}, "comments_9": {"comment_id": 10, "comment_author": "ghost(ghost)", "commentT": "2018-01-30T02:56:02Z", "comment_text": "\n \t\tLooking at the graph def, it looks like no node has control input \"^init_A_var_op\".\n Contrasting that with the following working script\u2014which does not use a tf.while_loop()\u2014the \"increment_A_dep/y\" node corresponding to the const second argument to the \"increment_A_dep\" tf.add() op has control input \"^init_A_var_op\":\n from __future__ import division, print_function\n import numpy as np\n import tensorflow as tf\n \n rs = np.random.RandomState(seed = 2)\n A = rs.normal(size = (10, 10,))\n print('singular values of A: %s' % (np.linalg.svd(A, compute_uv = False),))\n B = rs.normal(size = (10, 10,))\n print('singular values of B: %s' % (np.linalg.svd(B, compute_uv = False),))\n \n graph = tf.Graph()\n with graph.as_default():\n     A_var = tf.Variable(B, name = 'A_var')\n     init_A_var_op = tf.assign(A_var, A, name = 'init_A_var_op')\n     A_dep = tf.constant(9, tf.int32, name = 'initial_A_dep')\n \n     with tf.control_dependencies([init_A_var_op]):\n         A_dep = tf.add(A_dep, 1, name = 'increment_A_dep')\n \n     with tf.control_dependencies([A_dep]):\n         var_s = tf.svd(A_var, compute_uv = False)\n \n print(graph.as_graph_def())\n \n with tf.Session(graph = graph) as session:\n     session.run(tf.global_variables_initializer())\n     computed_A_dep, computed_s, computed_A_dep2 = session.run([A_dep, var_s, A_dep])\n     assert computed_A_dep == computed_A_dep2\n print('computed_s = %s, computed_A_dep = %d' % (computed_s, computed_A_dep,))\n Here is an excerpt from the working script's graph def:\n <denchmark-code>node {\n   name: \"initial_A_dep\"\n   op: \"Const\"\n   attr {\n     key: \"dtype\"\n     value {\n       type: DT_INT32\n     }\n   }\n   attr {\n     key: \"value\"\n     value {\n       tensor {\n         dtype: DT_INT32\n         tensor_shape {\n         }\n         int_val: 9\n       }\n     }\n   }\n }\n node {\n   name: \"increment_A_dep/y\"\n   op: \"Const\"\n   input: \"^init_A_var_op\"\n   attr {\n     key: \"dtype\"\n     value {\n       type: DT_INT32\n     }\n   }\n   attr {\n     key: \"value\"\n     value {\n       tensor {\n         dtype: DT_INT32\n         tensor_shape {\n         }\n         int_val: 1\n       }\n     }\n   }\n }\n node {\n   name: \"increment_A_dep\"\n   op: \"Add\"\n   input: \"initial_A_dep\"\n   input: \"increment_A_dep/y\"\n   attr {\n     key: \"T\"\n     value {\n       type: DT_INT32\n     }\n   }\n }\n node {\n   name: \"Svd\"\n   op: \"Svd\"\n   input: \"A_var/read\"\n   input: \"^increment_A_dep\"\n   attr {\n     key: \"T\"\n     value {\n       type: DT_DOUBLE\n     }\n   }\n   attr {\n     key: \"compute_uv\"\n     value {\n       b: false\n     }\n   }\n   attr {\n     key: \"full_matrices\"\n     value {\n       b: false\n     }\n   }\n }\n </denchmark-code>\n \n The non-working graph's \"while/increment_A_dep/y\" node has control input \"^while/Identity\" but not \"^init_A_var_op\".\n \t\t"}, "comments_10": {"comment_id": 11, "comment_author": "ghost(ghost)", "commentT": "2018-01-30T17:39:48Z", "comment_text": "\n \t\tOk, so this is a real bug. <denchmark-link:https://github.com/asimshankar>@asimshankar</denchmark-link>\n  who do you think we should assign this to?\n There's a bug somewhere in the control dependency processing logic of WhileContext, somewhere around here most likely: \n \n \n tensorflow/tensorflow/python/ops/control_flow_ops.py\n \n \n          Line 2414\n       in\n       ba64f53\n \n \n \n \n \n \n  def _MaybeAddControlDependency(self, op): \n \n \n \n \n \n \t\t"}, "comments_11": {"comment_id": 12, "comment_author": "ghost(ghost)", "commentT": "2018-01-30T19:28:41Z", "comment_text": "\n \t\t<denchmark-link:https://github.com/skye>@skye</denchmark-link>\n  was looking into something similar, I think.\n <denchmark-link:https://github.com/skye>@skye</denchmark-link>\n  - let me know if I'm mistaken and will try to find someone else.\n \t\t"}}}, "commit": {"commit_id": "f8f921c828fb2c97da7c7b80c01390ccec90ae40", "commit_author": "Alexandre Passos", "commitT": "2018-02-05 13:08:15-08:00", "changed_files": {"file_0": {"file_change_type": "MODIFY", "file_Nmethod": 4, "file_old_name": "tensorflow\\python\\kernel_tests\\control_flow_ops_py_test.py", "file_new_name": "tensorflow\\python\\kernel_tests\\control_flow_ops_py_test.py", "hunks": {"hunk_0": {"Ismethod": 1, "added_lines": "707,708,709,710,711,712,713,714,715,716,717,718,719,720", "deleted_lines": null, "method_info": {"method_name": "testWhileExternalControlDependencies", "method_params": "self", "method_startline": "707", "method_endline": "720"}}, "hunk_1": {"Ismethod": 1, "added_lines": "722,723,724,725,726,727,728,729,730,731,732,733,734,735", "deleted_lines": null, "method_info": {"method_name": "testWhileExternalControlDependenciesNoInput", "method_params": "self", "method_startline": "722", "method_endline": "735"}}, "hunk_2": {"Ismethod": 1, "added_lines": "713,714,715", "deleted_lines": null, "method_info": {"method_name": "testWhileExternalControlDependencies.body_fn", "method_params": "i", "method_startline": "713", "method_endline": "715"}}, "hunk_3": {"Ismethod": 1, "added_lines": "728,729,730", "deleted_lines": null, "method_info": {"method_name": "testWhileExternalControlDependenciesNoInput.body_fn", "method_params": "unused_i", "method_startline": "728", "method_endline": "730"}}}}, "file_1": {"file_change_type": "MODIFY", "file_Nmethod": 2, "file_old_name": "tensorflow\\python\\ops\\control_flow_ops.py", "file_new_name": "tensorflow\\python\\ops\\control_flow_ops.py", "hunks": {"hunk_0": {"Ismethod": 1, "added_lines": "1634,1636,1637,1640", "deleted_lines": "1637", "method_info": {"method_name": "_RemoveExternalControlEdges", "method_params": "self,op", "method_startline": "1621", "method_endline": "1640"}}, "hunk_1": {"Ismethod": 1, "added_lines": "2438,2439,2443,2456,2457,2458,2459,2465,2466,2467,2468,2469", "deleted_lines": "2435,2436,2437,2438,2442,2455,2456,2457", "method_info": {"method_name": "_AddOpInternal", "method_params": "self,op", "method_startline": "2435", "method_endline": "2476"}}}}}}}