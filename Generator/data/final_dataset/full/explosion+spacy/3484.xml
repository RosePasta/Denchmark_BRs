<bug_data>
<bug id='3484' author='rfriel' open_date='2019-03-26T02:00:51Z' closed_time='2019-05-04T16:16:04Z'>
 	<summary>Inconsistent lemmatization across different python sessions</summary>
 	<description>
 &lt;denchmark-h:h2&gt;How to reproduce the behaviour&lt;/denchmark-h&gt;
 
 The following will either produce the output ['dose'] or ['dos'].  The output will be the same in multiple runs during the same python session, but if you start a new python session you may instead see the other of the two (which is then consistent within that session).
 import spacy
 nlp = spacy.load("en")
 
 print([tok.lemma_ for tok in nlp('doses')])
 After some poking around, I think I've traced the issue to &lt;denchmark-link:https://github.com/explosion/spaCy/blob/9e14b2b69fa1e8a065eb451a06141a1dcdb0d902/spacy/lemmatizer.py#L122&gt;this line&lt;/denchmark-link&gt;
  the function  defined in .  Based on the comment there, it seems like the assumption is being made that calling  with an argument of  type will produce a sorted list.  As far as I understand, this is not true (at least in Python 3.6.4) and instead the returned list has an arbitrary order.
 Further up the call stack, the list reaches &lt;denchmark-link:https://github.com/explosion/spaCy/blob/146dc2766a069c8fe9e91c801f9695c2e262f742/spacy/morphology.pyx#L180&gt;this line&lt;/denchmark-link&gt;
  in , which selects the first element of the returned list.  This seems sufficient to explain the behavior.
 &lt;denchmark-h:h2&gt;Your Environment&lt;/denchmark-h&gt;
 
 
 spaCy version: 2.1.3
 Platform: Darwin-18.2.0-x86_64-i386-64bit
 Python version: 3.6.4
 Models: en
 
 	</description>
 	<comments>
 		<comment id='1' author='rfriel' date='2019-04-13T15:16:43Z'>
 		I noticed the same thing why creating the pyinflect extension.  The inconsistency is particularly problematic because it means I can't create exceptions for it.
 I addition to the inconsistency, lemmas are often wrong.  For instance...
 &lt;denchmark-code&gt;spared -&gt; [spare, spar]
 hating -&gt; [hate, hat]
 &lt;/denchmark-code&gt;
 
 When spaCy produces the incorrect lemma, pyinflect gives the wrong inflection back to the user.
 I'm interested in seeing this get fixed, although I think there's more to do than just sort the list of forms.  Ideally we'd fix some of the underlying issues, either with exceptions or a change to the heuristics.  Is there a plan to make changes?  I'm willing to do this or at least help but I'd like to know if you already have plans so I don't take a different path than you want or duplicate an ongoing effort.
 		</comment>
 		<comment id='2' author='rfriel' date='2019-04-14T02:10:50Z'>
 		For a test I ran the portion of the Gutenberg corpus that's in NLTK (2.6M words) through spaCy and recorded the set of words that produced more than one form of lemma (via a small hack in spaCy's code).  This file &lt;denchmark-link:https://github.com/explosion/spaCy/files/3076934/spacy_multiple_forms.txt&gt;spacy_multiple_forms.txt&lt;/denchmark-link&gt;
  has about 1200 entries where multiple lemmas were present.
 Just reviewing the list, it's usually fairly obvious which form is correct (and it's often not form[0]).  Lots of the words are spelling errors, but even for most of those it's obvious which one to choose.  I haven't looked close enough yet to see if there's a simple update to the rules that we can make, but at a minimum we could hand select the correct answers for the dictionary words and put them in an exceptions file.
 		</comment>
 		<comment id='3' author='rfriel' date='2019-04-17T09:33:45Z'>
 		For Python 3.7+, we can use dict keys as a proxy for sorted sets. This is even advised by a Python core developer &lt;denchmark-link:https://stackoverflow.com/a/39835527/1150683&gt;here&lt;/denchmark-link&gt;
 .
 &lt;denchmark-code&gt;&gt;&gt;&gt; list(dict.fromkeys('abracadabra'))
 ['a', 'b', 'r', 'c', 'd']
 &lt;/denchmark-code&gt;
 
 But of course that is too new and not supported in older versions. There are a number of packages out there that try to mimic an ordered set, but looking at development spaCy is trying to get rid of as much third-party dependencies as possible. Therefore, the best solution might be the OrderedDict's keys for older versions, and regular dict's keys for 3.7+.
 		</comment>
 		<comment id='4' author='rfriel' date='2019-04-17T12:55:14Z'>
 		It sounds like you're suggesting the applied rules should have a an order of preference.  Is this the case?  I haven't seen this myself.  If not, I think just sorting the few cases where there is more than one form at the end is probably the simplest.  There's usually only 2 or 3 on the list to sort so it would be reasonably quick.
 Just experimenting with this for a few minutes, I think there are some simple rules we could apply that would help select the correct form when multiples are return from the lemmatize method.  For instance, wordnet._morphy uses min(sorted(infl.forms), key=len) as a heuristic.  I didn't see spaCy using this.  Additionally we could supply a set of simple metrics to pick out common word forms.  For instance...
 &lt;denchmark-code&gt;    choice = min(sorted(infl.forms), key=len)
     for form in infl.forms:
        # A common pattern is __[aiou]_e but not __ye and not __ione
         if len(form)&gt;3 and form[-1]=='e' and form[-3] in 'aiou' and form[-2] != 'y' and form[-4:-1] != 'ion':
             choice = form
         # A common pattern is '__nce'
         if len(form)&gt;3 and form[-1]=='e' and form[-3:-1] == 'nc':
             choice = form
     return choice
 &lt;/denchmark-code&gt;
 
 The above significantly reduces the incorrect forms from the list of ambiguous forms posted above.  It's probably not the correct solution (use regular expressions, add more rules, etc..) but with a little thinking/experimenting we could probably come up with a reasonable set of heuristics.
 Keep in mind, this is really only an issue with OOV words and words that happen to have multiple spellings in the dictionary.  Removing some of the oddball alternate spellings from the word list would also help.
 		</comment>
 		<comment id='5' author='rfriel' date='2019-04-17T16:52:06Z'>
 		This is all very interesting.  In my opinion, the first priority is just to make the behavior deterministic, even if it deterministically chooses the wrong thing sometimes.  This won't be ideal, but won't be any worse than current behavior, and will make it easier to develop with spacy.  (I originally found this bug because I have some scripts that I need to be deterministic, and they use the lemmatizer.)
 This could be done as a one-line change to use OrderedDict instead of set for deduplication, as BramVanroy suggests.  I could write this PR unless someone else wants to.
 Then, there is the issue of selecting the right form.  I don't know how this is done in other lemmatizers, and wouldn't want to reinvent the wheel.  bjascob, it sounds like you know more than I do about this topic, so I'll defer to you on how exactly to do this part.  (Also, I wonder if there's anything like this already in development?  Or if spacy has a solution for some languages, just not English?  I'd recommend looking into these questions first.)
 		</comment>
 		<comment id='6' author='rfriel' date='2019-04-17T19:31:18Z'>
 		Unfortunately there's no perfect way to select the correct form for words that are OOV when basic rules are applied (at least that I'm aware of).  The suggested heuristic is really a band-aid that would correct some errors but you'd still be left with others.
 I agree the most important thing is to make the process deterministic, at least for now.  If you're willing to do a PR for this that would be great.  A few notes though..
 I see two places where order can get messed up.  Both are in lemmatizer.py::lemmatize(string,..)
 
 The parameter rules is a standard dictionary and has no ordering (OderedDict would fix this)
 A few lines below, after converting forms to a set and them back to a list, any order is lost.  This line could probably be eliminated by simply checking if not form in forms and the other line if form not in oov_forms
 
 My suggestion would be, just to keep the logic simple, to simply return sorted(forms, key=len).  Spacy's lemmatizer is basically the same as the NLTK / wornet.morphy lemmatizer.  I looked at the NLTK code and when they have multiple forms to deal with they return the shortest one.  This could be achieved by having lemmatizer return sorted(forms, key=len) so list is sorted by length instead of alphabetically.  Given that NLTK does it this way, that seems to me like a good approach to me.
 .. and after thinking about it a minute, since the forms only differ by a few characters at the end, sorting the list alphabetically would return the shortest form in most cases too.
 		</comment>
 		<comment id='7' author='rfriel' date='2019-06-03T16:45:23Z'>
 		This thread has been automatically locked since there has not been any recent activity after it was closed. Please open a new issue for related bugs.
 		</comment>
 	</comments>
 </bug>
<commit id='955b95cb8ba5185525e736089f7c81743f32efa0' author='Brad Jascob' date='2019-05-04 18:16:03+02:00'>
 	<dmm_unit complexity='None' interfacing='None' size='None'></dmm_unit>
 	<modification change_type='MODIFY' old_name='spacy\lemmatizer.py' new_name='spacy\lemmatizer.py'>
 		<file_info nloc='108' complexity='46' token_count='730'></file_info>
 		<method name='lemmatize' parameters='string,index,exceptions,rules'>
 				<method_info nloc='23' complexity='10' token_count='152' nesting_level='0' start_line='108' end_line='135'></method_info>
 			<added_lines>122,123</added_lines>
 			<deleted_lines>121,122</deleted_lines>
 		</method>
 		<modified_lines>
 			<added_lines>3</added_lines>
 			<deleted_lines></deleted_lines>
 		</modified_lines>
 	</modification>
 </commit>
</bug_data>
