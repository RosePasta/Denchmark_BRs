<bug id='157' author='tvst' open_date='2019-09-20T22:13:48Z' closed_time='2020-02-13T22:31:01Z'>
	<summary>st.cache always shows a warning for mutated inputs, even if ignore_hash is True</summary>
	<description>
&lt;denchmark-h:h1&gt;Steps to reproduce&lt;/denchmark-h&gt;

Get some data files:
&lt;denchmark-code&gt;python -m spacy download en_core_web_sm
&lt;/denchmark-code&gt;

Then run this:
&lt;denchmark-code&gt;import streamlit as st
import spacy

@st.cache(ignore_hash=True)
def load_model(name):
    return spacy.load(name)

@st.cache(ignore_hash=True)
def process_text(nlp, text):
    return nlp(text)  # This mutates the nlp object. So we raise a warning.

nlp = spacy.load("en_core_web_sm")
doc = process_text(nlp, "Hello world")
&lt;/denchmark-code&gt;

What you see:

Cached function mutated its input arguments
When decorating a function with @st.cache, the arguments should not be mutated inside the function body, as that breaks the caching mechanism. Please update the code of process_text to bypass the mutation.
See the Streamlit docs for more info.

Expected
It's OK if we have a warning for this case, but there should be a way to turn it off too.
&lt;denchmark-h:h1&gt;Debug info&lt;/denchmark-h&gt;


Streamlit version: 0.45.0

&lt;denchmark-h:h1&gt;Possible solutions&lt;/denchmark-h&gt;


Add kwarg allow_input_mutation=True that suppresses this warning and doesn't check inputs when pulling from the cache.
This should actually be a different feature request, but if we added kwargs clone_inputs=True and clone_output=True, which allows mutation.

Addendum: should we rename or change the semantics of ignore_hash? There are different hashes in st.cache, and ignore_hash only ignores one of them.
	</description>
	<comments>
		<comment id='1' author='tvst' date='2019-09-21T21:20:24Z'>
		I'd like to use this bug as a forum to discuss an extended API to solve this and &lt;denchmark-link:https://github.com/streamlit/streamlit/issues/153&gt;other newly uncovered limitations of st.cache&lt;/denchmark-link&gt;
.
A couple thoughts:
&lt;denchmark-h:h2&gt;Is this a problem with ignore_hash?&lt;/denchmark-h&gt;

No. The goal of ignore_hash is to expand the range of objects that can be stored in the cache by allowing objects which are unhashable (like Tensorflow Sessions and Websocket connections).
 which, confusingly, seems like what we should turn on to solve the problem described above. (You can see a more "pure python" example of this problem in &lt;denchmark-link:https://github.com/streamlit/streamlit/issues/153&gt;#153&lt;/denchmark-link&gt;
.)
&lt;denchmark-h:h3&gt;Possible Solution: allow_output_mutation&lt;/denchmark-h&gt;

Deprecate the name ignore_hash and switch to allow_output_mutation which I think captures the correct semantics.
&lt;denchmark-h:h2&gt;So then would the solution be allow_input_mutation?&lt;/denchmark-h&gt;

I don't think so. The point of the cache is that it's like a symbol table parameterized by the input arguments. For example, if you have
@st.cache
def f(x, y):
  ...
and you call
z1 = f(X1, Y1)
z2 = f(X2, Y2)
then the cache is like a symbol table containing
&lt;denchmark-code&gt;hash(f, X1, Y1, ...) -&gt; z1
hash(f, X2, Y2, ...) -&gt; z2
&lt;/denchmark-code&gt;

If you allow input mutations, then it's the &lt;denchmark-link:http://effbot.org/pyfaq/why-must-dictionary-keys-be-immutable.htm&gt;same basic problem as having mutable keys in a dictionary&lt;/denchmark-link&gt;
: you loose the ability to recall earlier symbols. For example if  after calling , then the value of  has irretrievably be "lost" in the cache!
Neither shoud we completely skip "check[ing] inputs when pulling from the cache". You need to hash something to parameterize the caches "symbol table."
For example, at minimum you might want to hash the funnction name, but that is not how hashing works right now, so we're introducing completely new semantics, and probably not hashing what the user expects.
&lt;denchmark-h:h3&gt;Possible Solution: hash_by_id&lt;/denchmark-h&gt;

Really the issue here is that the object isn't hash code can't be trusted.
Normally, this would involve &lt;denchmark-link:https://docs.python.org/3/reference/datamodel.html#object.__hash__&gt;overriding __hash__ and __eq__ methods&lt;/denchmark-link&gt;
 but &lt;denchmark-link:https://github.com/streamlit/streamlit/blob/1d7f6cff6acc7643a6b1f24f2c502f365c4af193/lib/streamlit/hashing.py#L238&gt;Streamlit doesn't use Python's built-in hashing API&lt;/denchmark-link&gt;
. Instead, this would involve overring the &lt;denchmark-link:https://jakevdp.github.io/blog/2014/05/05/introduction-to-the-python-buffer-protocol/&gt;Buffer API&lt;/denchmark-link&gt;
 which I don't understand. Maybe &lt;denchmark-link:https://github.com/domoritz&gt;@domoritz&lt;/denchmark-link&gt;
 can chime in here?
The fully general solution here would be to allow the user to define a custom buffer function post facto, but that's too general for now.
Instead I think we should define a set of types which are hashed by their memory location either because

they are immutable anyway, so this is a optimization
we trust the user to know what they're doing

Call this list hash_by_id. We could specify which types should be thusly hashed as an argument to st.cache. So the code above would look like:
@st.cache(cache_by_id=[spacy.lang.en.English])
def process_text(nlp, text):
    ...
or we could even offer a method to cache by argument name:
@st.cache(cache_args_by_id=['nlp'])
def process_text(nlp, text):
    ...
&lt;denchmark-h:h3&gt;A big side benefit: less ignore_hash=True&lt;/denchmark-h&gt;

A potential side benefit of this approach would be hard code Tensorflow Sessions and some other type in the global hash_by_id set, which would then mean that we could avoid the need for ignore_hash=True in many cases.
&lt;denchmark-h:h2&gt;Summary&lt;/denchmark-h&gt;

I think the way forward is to:

Treat implicit and explicit inputs equally.
Deprecated ignore_hash and replace it with allow_output_mutation.
Add a hash_by_id argument to st.cache which would apply to all hashing operations, explicit input, implicit input, and output.

I would welcome &lt;denchmark-link:https://github.com/tvst&gt;@tvst&lt;/denchmark-link&gt;
 and &lt;denchmark-link:https://github.com/domoritz&gt;@domoritz&lt;/denchmark-link&gt;
's thoughts on this proposal.
		</comment>
		<comment id='2' author='tvst' date='2019-10-01T23:24:25Z'>
		Just chiming in to  this. I tried to get Ines' &lt;denchmark-link:https://gist.github.com/ines/b320cb8441b590eedf19137599ce6685&gt;spaCy example&lt;/denchmark-link&gt;
 running and all I see is a lot of  yellow boxes, and this TypeError:
&lt;denchmark-link:https://user-images.githubusercontent.com/47401552/66007543-b3c04f00-e467-11e9-8500-5bd01e8a59d6.png&gt;&lt;/denchmark-link&gt;

One thing that would be helpful is if the failed to hash messages gave you a line number? The current warning is very hard to act on.
&lt;denchmark-link:https://user-images.githubusercontent.com/47401552/66007595-e702de00-e467-11e9-8c39-c9d2b78d1eff.png&gt;&lt;/denchmark-link&gt;

		</comment>
		<comment id='3' author='tvst' date='2019-10-01T23:41:22Z'>
		Ok, the issue was with the code - this version works: &lt;denchmark-link:https://github.com/explosion/spaCy/blob/master/examples/streamlit_spacy.py&gt;https://github.com/explosion/spaCy/blob/master/examples/streamlit_spacy.py&lt;/denchmark-link&gt;

However, I stand by my request for more information in the failed to hash warning boxes.
		</comment>
		<comment id='4' author='tvst' date='2019-10-01T23:49:08Z'>
		&lt;denchmark-link:https://github.com/sam-qordoba&gt;@sam-qordoba&lt;/denchmark-link&gt;
 That's interesting â€“ I just double-checked again and the only difference between the two files are the unicode declarations (that should only be necessary for Python 2, so I didn't bother adding them to my initial example). So I guess there's something else going on here.
		</comment>
		<comment id='5' author='tvst' date='2019-10-02T00:02:13Z'>
		I tried pointing `streamlit run` to the raw gist ( &lt;denchmark-link:https://gist.githubusercontent.com/ines/b320cb8441b590eedf19137599ce6685/raw/6e0ead5a442fd9c5e3f621a76fba94241cc847ce/streamlit_spacy.py&gt;https://gist.githubusercontent.com/ines/b320cb8441b590eedf19137599ce6685/raw/6e0ead5a442fd9c5e3f621a76fba94241cc847ce/streamlit_spacy.py&lt;/denchmark-link&gt;
 ). This also worked... So I guess my issue is "files which run remotely don't work when copy/pasted locally"
		</comment>
		<comment id='6' author='tvst' date='2019-10-09T20:26:14Z'>
		Hello everyone, I didn't want to open a new issue, because I read all of them related to  and it seems to be a known one. So I just want to add that if I run the (amazing, by the way) examples of &lt;denchmark-link:https://github.com/ines&gt;@ines&lt;/denchmark-link&gt;
 locally, it doesn't work, but if I choose the Network URL it runs without any warnings. I will follow this 'bug' with attention and try to fix it if it's related to my configuration.
Thank you anyway for this tool who will improve my productivity a lot ! (And sorry if my comment doesn't help at all or sounds amateurish, these are my baby steps in the open source world).
		</comment>
		<comment id='7' author='tvst' date='2019-10-09T21:07:59Z'>
		&lt;denchmark-link:https://github.com/sam-qordoba&gt;@sam-qordoba&lt;/denchmark-link&gt;
 : I believe &lt;denchmark-link:https://github.com/streamlit/streamlit/issues/167&gt;this is the issue&lt;/denchmark-link&gt;
 you're seeing.
		</comment>
		<comment id='8' author='tvst' date='2020-02-13T22:31:01Z'>
		This bug is now pretty out of date vis-a-vis the current state of Streamlit, since we've heavily restructured how cacheing works.  The repro code used now results in an UnhashableTypeError -- which is expected.
&lt;denchmark-link:https://user-images.githubusercontent.com/98836/74484407-54d70180-4e6d-11ea-9816-4ac49b0a346f.png&gt;&lt;/denchmark-link&gt;

		</comment>
	</comments>
</bug>