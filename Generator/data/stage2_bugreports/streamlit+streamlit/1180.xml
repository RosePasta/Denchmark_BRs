<bug id='1180' author='tconkling' open_date='2020-03-04T19:37:31Z' closed_time='2020-03-24T16:56:20Z'>
	<summary>Need hash_func for type _io.StringIO</summary>
	<description>
This should work out of the box:
&lt;denchmark-code&gt;@st.cache
def do_a_thing_with_uploaded_file(value):
    pass

uploaded_file = st.file_uploader("Label")
do_a_thing_with_uploaded_file(uploaded_file)
&lt;/denchmark-code&gt;

&lt;denchmark-link:https://discuss.streamlit.io/t/hash-function-error-for-uploaded-text-file/2058/7?u=tim&gt;https://discuss.streamlit.io/t/hash-function-error-for-uploaded-text-file/2058/7?u=tim&lt;/denchmark-link&gt;

	</description>
	<comments>
		<comment id='1' author='tconkling' date='2020-03-06T18:24:34Z'>
		Ian Calvert &lt;denchmark-link:https://discuss.streamlit.io/t/hash-function-error-for-uploaded-text-file/2058/7?u=adrien_treuille&gt;made the following suggestion&lt;/denchmark-link&gt;
:
def hash_io(input_io):
    data = input_io.read()
    input_io.seek(0)
    if isinstance(data, str):
        data = data.encode("utf-8")
    return hashlib.md5(data).hexdigest()


@st.cache(hash_funcs={io.BytesIO: hash_io, io.StringIO: hash_io})
def load_data(file_data):
    try:
        return pd.read_csv(file_data)
    except:
        return pd.read_excel(file_data)
However, I'm not sure this works in general because


It usese read() and seek() to go back to the zero position, which may not be where we started. We should consider using peek() instead.


We return a hexdigest() of the data, but hash_funcs doesn't require that the user perform their own hash. hash_funcs only requries that the return value be more primitive than the input. Therefore, we should just return the bytes themselves; Streamlit will figure out to hash the bytes in a subsequent iteration.


&lt;denchmark-link:https://github.com/tconkling&gt;@tconkling&lt;/denchmark-link&gt;
 : Can you please propose a revised  before we integrate int the codebase?
		</comment>
		<comment id='2' author='tconkling' date='2020-03-06T23:20:44Z'>
		I can test this out with my real world data with peek and ignoring the hashing, I didn't realise there was a layer inside hashing the returned data.
Peek may not be quite right though, a stream of 1234 at position 2 is not the same a stream of 34. Would peek return the same for both?
Get value and the current position might do it?
		</comment>
		<comment id='3' author='tconkling' date='2020-03-07T22:05:54Z'>
		Both StringIO and BytesIO implement getvalue - though they don't inherit from a common thing that does unfortunately.
Using getvalue doesn't mess up the position in the stream you might be, and tell should mean that two calls with different positions in the stream shouldn't be cached the same.
&lt;denchmark-code&gt;def hash_io(input_io):
    return (input_io.getvalue(), input_io.tell())


@st.cache(hash_funcs={io.BytesIO: hash_io, io.StringIO: hash_io})
def load_data(file_data):
    try:
        return pd.read_csv(file_data)
    except:
        return pd.read_excel(file_data)
&lt;/denchmark-code&gt;

		</comment>
		<comment id='4' author='tconkling' date='2020-03-24T16:56:20Z'>
		Hey &lt;denchmark-link:https://github.com/IanCal&gt;@IanCal&lt;/denchmark-link&gt;
,
Thanks for the assistance on this one . Going to close out this issue since &lt;denchmark-link:https://github.com/streamlit/streamlit/pull/1204&gt;1204 was merged&lt;/denchmark-link&gt;
.
		</comment>
	</comments>
</bug>