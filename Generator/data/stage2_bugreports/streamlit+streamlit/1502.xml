<bug id='1502' author='sgttwld' open_date='2020-05-26T19:55:58Z' closed_time='2020-06-16T15:38:30Z'>
	<summary>Evaluating a cached function at multiple integer-like floats only runs once</summary>
	<description>
&lt;denchmark-h:h1&gt;Summary&lt;/denchmark-h&gt;

When looping a cached function (decorated with st.cache) over a parameter vector represented by a list (or numpy array) of floats, e.g. created with np.linspace, then only the first integer-like value (1.0,2.0,...) is executed, for all following integer-like values, the cached result is used. This only happens when the values are integer-valued floats, afaik. For example, lists, np.arange, range, etc.. do not have this issue when returning true integers, but lists, np.arange, and np.linspace do when they return integers as floats. This bug does not appear when not caching, or when caching the sweep function instead of the basis function.
&lt;denchmark-h:h1&gt;Steps to reproduce&lt;/denchmark-h&gt;

What are the steps we should take to reproduce the bug:
&lt;denchmark-h:h3&gt;Example 1:&lt;/denchmark-h&gt;

&lt;denchmark-code&gt;import streamlit as st

@st.cache
def f(x,s=''):
    print(s)
    return x**2

st.write('floats',f(2.0,'floats'),f(3.0,'floats'),f(4.0,'floats'))  ## bug
st.write('ints',f(2,'ints'),f(3,'ints'),f(4,'ints'))                ## correct
st.write('non-int floats',f(2.001,'non-int'),f(3.001,'non-int'),f(4.001,'non-int')) ## correct
&lt;/denchmark-code&gt;

&lt;denchmark-h:h3&gt;Example 2:&lt;/denchmark-h&gt;

&lt;denchmark-code&gt;import numpy as np
import streamlit as st
import pandas as pd

@st.cache
def f(x,s=''):
    print(s)
    return x**2

def sweep(f,rng,s=''):
    r = []
    for x in rng:
        r.append(f(x,s=s))
    return pd.DataFrame(zip([rng,r]),columns=['x','x**2'])


r = sweep(f,[1.0,2.0,3.0,4.0],'list of floats')
st.write('list of floats',r)      ## bug

r = sweep(f,[1.0001,2.0001,3.0001,4.0001],'list of floats (non-int)')
st.write('list of floats (non-int)',r)      ## correct

r = sweep(f,[1,2,3,4],'list of ints')
st.write('list of ints',r)     ## correct

r = sweep(f,range(1,5),'range')
st.write('range',r)     ## correct
&lt;/denchmark-code&gt;

&lt;denchmark-h:h2&gt;Expected behavior:&lt;/denchmark-h&gt;

1.0^2 = 1.0, 2.0^2 = 4.0, 3.0^2 = 9.0, 4.0^2 = 16.0
&lt;denchmark-h:h2&gt;Actual behavior:&lt;/denchmark-h&gt;

2.0^2 = 4, 3.0^2 = 4, 4.0^2 = 4
&lt;denchmark-link:https://user-images.githubusercontent.com/28790437/82985959-3dbfb800-9ff5-11ea-901f-a6cd71442708.png&gt;&lt;/denchmark-link&gt;

1.0^2 = 1, 2.0^2 = 1, 3.0^2 = 1, 4.0^2 = 1
&lt;denchmark-link:https://user-images.githubusercontent.com/28790437/82984451-7d38d500-9ff2-11ea-9f95-94049376aa8b.png&gt;&lt;/denchmark-link&gt;

&lt;denchmark-h:h1&gt;Debug info&lt;/denchmark-h&gt;


Streamlit version: 0.60.0
Python version: 3.7.5
Numpy version: 1.18.4
Using Conda? PipEnv? PyEnv? Pex? No

&lt;denchmark-h:h1&gt;Additional information&lt;/denchmark-h&gt;

By printing to console at each run, one can see that the cached function is only used once when the inputs are integer-like floats:
&lt;denchmark-link:https://user-images.githubusercontent.com/28790437/82986360-fede3200-9ff5-11ea-98af-98f6760ff1aa.png&gt;&lt;/denchmark-link&gt;

A workaround is to input numpy arrays instead of numbers (lists do not work), e.g.
&lt;denchmark-code&gt;st.write(f(np.array([2.0])),f(np.array([3.0]))
&lt;/denchmark-code&gt;

does correctly evaluate both arguments.
	</description>
	<comments>
		<comment id='1' author='sgttwld' date='2020-06-16T15:35:34Z'>
		Dup of &lt;denchmark-link:https://github.com/streamlit/streamlit/issues/1166&gt;#1166&lt;/denchmark-link&gt;
?
		</comment>
		<comment id='2' author='sgttwld' date='2020-06-16T16:07:53Z'>
		Yes! Sorry I wasn't able to find it.
		</comment>
	</comments>
</bug>