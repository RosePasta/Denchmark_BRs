<bug id='470' author='xuwaters' open_date='2019-12-14T23:33:00Z' closed_time='2019-12-22T14:04:34Z'>
	<summary>Run UnitTest Failed on GraphDef comparing</summary>
	<description>
&lt;denchmark-code&gt;X Graph [61ms]
  Error Message:
   Assert.AreEqual failed. Expected:&lt;{ "node": [ { "name": "feed", "op": "Placeholder", "attr": { "dtype": { "type": "DT_INT32" }, "shape": { "shape": { "unknownRank": true } } } }, { "name": "scalar", "op": "Const", "attr": { "value": { "tensor": { "dtype": "DT_INT32", "tensorShape": { }, "intVal": [ 3 ] } }, "dtype": { "type": "DT_INT32" } } }, { "name": "add", "op": "AddN", "input": [ "feed", "scalar" ], "attr": { "N": { "i": "2" }, "T": { "type": "DT_INT32" } } }, { "name": "neg", "op": "Neg", "input": [ "add" ], "attr": { "T": { "type": "DT_INT32" } } } ], "library": { }, "versions": { "producer": 134 } }&gt;. Actual:&lt;{ "node": [ { "name": "feed", "op": "Placeholder", "attr": { "shape": { "shape": { "unknownRank": true } }, "dtype": { "type": "DT_INT32" } } }, { "name": "scalar", "op": "Const", "attr": { "value": { "tensor": { "dtype": "DT_INT32", "tensorShape": { }, "intVal": [ 3 ] } }, "dtype": { "type": "DT_INT32" } } }, { "name": "add", "op": "AddN", "input": [ "feed", "scalar" ], "attr": { "T": { "type": "DT_INT32" }, "N": { "i": "2" } } }, { "name": "neg", "op": "Neg", "input": [ "add" ], "attr": { "T": { "type": "DT_INT32" } } } ], "library": { }, "versions": { "producer": 134 } }&gt;.
  Stack Trace:
     at TensorFlowNET.UnitTest.CApiTest.EXPECT_EQ(Object expected, Object actual) in /data/will/workspace/learn/tf/TensorFlow.NET/test/TensorFlowNET.UnitTest/CApiTest.cs:line 18
   at TensorFlowNET.UnitTest.GraphTest.Graph() in /data/will/workspace/learn/tf/TensorFlow.NET/test/TensorFlowNET.UnitTest/GraphTest.cs:line 142

&lt;/denchmark-code&gt;

The two GraphDef are actually the same, but JSON strings are not equal.
{ "node": [ { "name": "feed", "op": "Placeholder", "attr": { "dtype": { "type": "DT_INT32" }, "shape": { "shape": { "unknownRank": true } } } }, { "name": "scalar", "op": "Const", "attr": { "value": { "tensor": { "dtype": "DT_INT32", "tensorShape": { }, "intVal": [ 3 ] } }, "dtype": { "type": "DT_INT32" } } }, { "name": "add", "op": "AddN", "input": [ "feed", "scalar" ], "attr": { "N": { "i": "2" }, "T": { "type": "DT_INT32" } } }, { "name": "neg", "op": "Neg", "input": [ "add" ], "attr": { "T": { "type": "DT_INT32" } } } ], "library": { }, "versions": { "producer": 134 } }

{ "node": [ { "name": "feed", "op": "Placeholder", "attr": { "shape": { "shape": { "unknownRank": true } }, "dtype": { "type": "DT_INT32" } } }, { "name": "scalar", "op": "Const", "attr": { "value": { "tensor": { "dtype": "DT_INT32", "tensorShape": { }, "intVal": [ 3 ] } }, "dtype": { "type": "DT_INT32" } } }, { "name": "add", "op": "AddN", "input": [ "feed", "scalar" ], "attr": { "T": { "type": "DT_INT32" }, "N": { "i": "2" } } }, { "name": "neg", "op": "Neg", "input": [ "add" ], "attr": { "T": { "type": "DT_INT32" } } } ], "library": { }, "versions": { "producer": 134 } }
	</description>
	<comments>
		<comment id='1' author='xuwaters' date='2019-12-14T23:51:14Z'>
		&lt;denchmark-link:https://github.com/xuwaters&gt;@xuwaters&lt;/denchmark-link&gt;
 Do you know why the fields order are different? The Json serializer randomly pickup property to process? &lt;denchmark-link:https://github.com/henon&gt;@henon&lt;/denchmark-link&gt;
 Are you familiar with Newton.Json? It also bothers me when I try to serialize two graphs to comapre difference. &lt;denchmark-link:https://github.com/Nucs&gt;@Nucs&lt;/denchmark-link&gt;
 .
		</comment>
		<comment id='2' author='xuwaters' date='2019-12-14T23:54:32Z'>
		I think we can just use EXPECT_EQ(graph_def, graph_def2); instead of comparing the JSON string.
Since GraphDef is generated by protobuf, and implements IEquatable, aslo bool Equals(object other) has already been generated.
		</comment>
		<comment id='3' author='xuwaters' date='2019-12-15T16:32:27Z'>
		
@henon Are you familiar with Newton.Json? It also bothers me when I try to serialize two graphs to comapre difference.

Yes I am familiar with the problem. You need to order the properties alphabetically when serializing. Here is a link that describes how: &lt;denchmark-link:https://stackoverflow.com/questions/56933494/how-to-sort-properties-alphabetically-when-serializing-json-using-netwonsoft-lib&gt;https://stackoverflow.com/questions/56933494/how-to-sort-properties-alphabetically-when-serializing-json-using-netwonsoft-lib&lt;/denchmark-link&gt;

		</comment>
	</comments>
</bug>