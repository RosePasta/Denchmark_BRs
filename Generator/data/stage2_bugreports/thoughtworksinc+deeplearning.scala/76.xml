<bug id='76' author='izhangzhihao' open_date='2017-05-08T05:41:46Z' closed_time='2017-05-08T10:07:20Z'>
	<summary>Type infer error at implement of Poly1 in differentiable-indarray</summary>
	<description>
That should compile
    implicit def optimizer: Optimizer = new LearningRate {
      def currentLearningRate() = 1
    }

    val weight: Do[Borrowing[Tape.Aux[INDArray, INDArray]]]   = (Nd4j.ones(4, 4) * 10).toWeight

    def myNetwork(input: INDArray) : Do[Borrowing[Tape.Aux[INDArray, INDArray]]] = {
      abs(weight)
    }
but actually not:
&lt;denchmark-code&gt;Error:(429, 11) type mismatch;
 found   : weight.type (with underlying type com.thoughtworks.raii.asynchronous.Do[com.thoughtworks.raii.ownership.Borrowing[com.thoughtworks.deeplearning.Tape.Aux[org.nd4j.linalg.api.ndarray.INDArray,org.nd4j.linalg.api.ndarray.INDArray]]])
 required: com.thoughtworks.deeplearning.PolyFunctions.abs.ProductCase.Aux[shapeless.HNil,?]
    (which expands to)  shapeless.poly.Case[com.thoughtworks.deeplearning.PolyFunctions.abs.type,shapeless.HNil]{type Result = ?}
      abs(weight)
&lt;/denchmark-code&gt;

a workaround:
    implicit def optimizer: Optimizer = new LearningRate {
      def currentLearningRate() = 1
    }

    val weight: Do[Borrowing[Tape.Aux[INDArray, INDArray]]]   = (Nd4j.ones(4, 4) * 10).toWeight

    def myNetwork(input: INDArray)  = {
      abs(weight)
    }
or :
    implicit def optimizer: Optimizer = new LearningRate {
      def currentLearningRate() = 1
    }

    val weight: Do[Borrowing[Tape.Aux[INDArray, INDArray]]]   = (Nd4j.ones(4, 4) * 10).toWeight

    def myNetwork(input: INDArray) : Do[Borrowing[Tape.Aux[INDArray, INDArray]]] = {
      val result = abs(weight)
      result
    }
possible solution:
add
&lt;denchmark-code&gt;def abs(a: AnyRef)(implicit c: abs.Case[a.type]): c.Result = c[a.type](a)
&lt;/denchmark-code&gt;

to PolyFunctions, and make Do be a type Do[A] &lt;:AnyRef
	</description>
	<comments>
	</comments>
</bug>