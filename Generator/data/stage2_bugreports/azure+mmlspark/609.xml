<bug id='609' author='emnajaoua' open_date='2019-07-08T13:21:36Z' closed_time='2019-10-09T03:27:09Z'>
	<summary>java.net.ConnectException: Connection refused (Connection refused) with LightGBMClassifier in Databricks</summary>
	<description>
I am trying to run this example with my own dataset on databricks.
&lt;denchmark-link:url&gt;https://github.com/microsoft/recommenders/blob/master/notebooks/02_model/mmlspark_lightgbm_criteo.ipynb&lt;/denchmark-link&gt;

My cluster configuration is from 2 until 10 worker nodes. Worker Type is 28.GB Memory, 8 cores.
In the beginning of my notebook I set the following properties


but it seems that it doesn't effect the notebook environment.
I am using for the LightGBMClassifier , the library Azure:mmlspark:0.16.
My dataset has 1.502.306 rows and 9 columns. It is a spark dataframe, result of 3 joins between 3 SQL Tables (transformed to spark dataframes with the command spark.sql())
I apply feature_processor step to encode the categorical columns. Then after setting the LightGBMClassifier parameter, I train the model.
My LightGBMClassifier parameters are :
`NUM_LEAVES = 8
NUM_ITERATIONS = 20
LEARNING_RATE = 0.1
FEATURE_FRACTION = 0.8
EARLY_STOPPING_ROUND = 5
&lt;denchmark-h:h1&gt;Model name&lt;/denchmark-h&gt;

MODEL_NAME = 'lightgbm_criteo.mml'
lgbm = LightGBMClassifier(
labelCol="kategorie1",
featuresCol="features",
objective="multiclass",
isUnbalance=True,
boostingType="gbdt",
boostFromAverage=True,
baggingSeed=3, #früher 42
numLeaves=NUM_LEAVES,
numIterations=NUM_ITERATIONS,
learningRate=LEARNING_RATE,
featureFraction=FEATURE_FRACTION,
earlyStoppingRound=EARLY_STOPPING_ROUND,
timeout=1200.0
#parallelism='data_parallel'
)I applied the repartition trick as well before training the modeltrain = train.repartition(50)
train.rdd.getNumPartitions()Then when I runmodel = lgbm.fit(train)then I get the following error Py4JJavaError: An error occurred while calling o1125.fit.
: org.apache.spark.SparkException: Job aborted due to stage failure: Task 10 in stage 36.0 failed 4 times, most recent failure: Lost task 10.3 in stage 36.0 (TID 3493, 10.139.64.10, executor 7): java.net.ConnectException: Connection refused (Connection refused)
at java.net.PlainSocketImpl.socketConnect(Native Method)
at java.net.AbstractPlainSocketImpl.doConnect(AbstractPlainSocketImpl.java:350)
at java.net.AbstractPlainSocketImpl.connectToAddress(AbstractPlainSocketImpl.java:206)
at java.net.AbstractPlainSocketImpl.connect(AbstractPlainSocketImpl.java:188)
at java.net.SocksSocketImpl.connect(SocksSocketImpl.java:392)
at java.net.Socket.connect(Socket.java:589)
at java.net.Socket.connect(Socket.java:538)
at java.net.Socket.(Socket.java:434)
at java.net.Socket.(Socket.java:211)
at com.microsoft.ml.spark.TrainUtils$.getNodes(TrainUtils.scala:178)
at com.microsoft.ml.spark.TrainUtils$$anonfun$5.apply(TrainUtils.scala:211)
at com.microsoft.ml.spark.TrainUtils$$anonfun$5.apply(TrainUtils.scala:205)
at com.microsoft.ml.spark.StreamUtilities$.using(StreamUtilities.scala:29)
at com.microsoft.ml.spark.TrainUtils$.trainLightGBM(TrainUtils.scala:204)
at com.microsoft.ml.spark.LightGBMClassifier$$anonfun$3.apply(LightGBMClassifier.scala:83)
at com.microsoft.ml.spark.LightGBMClassifier$$anonfun$3.apply(LightGBMClassifier.scala:83)
at org.apache.spark.sql.execution.MapPartitionsExec$$anonfun$5.apply(objects.scala:200)
at org.apache.spark.sql.execution.MapPartitionsExec$$anonfun$5.apply(objects.scala:197)
at org.apache.spark.rdd.RDD$$anonfun$mapPartitionsInternal$1$$anonfun$apply$24.apply(RDD.scala:852)
at org.apache.spark.rdd.RDD$$anonfun$mapPartitionsInternal$1$$anonfun$apply$24.apply(RDD.scala:852)
at org.apache.spark.rdd.MapPartitionsRDD.compute(MapPartitionsRDD.scala:60)
at org.apache.spark.rdd.RDD.computeOrReadCheckpoint(RDD.scala:340)
at org.apache.spark.rdd.RDD.iterator(RDD.scala:304)
at org.apache.spark.rdd.MapPartitionsRDD.compute(MapPartitionsRDD.scala:60)
at org.apache.spark.rdd.RDD.computeOrReadCheckpoint(RDD.scala:340)
at org.apache.spark.rdd.RDD.iterator(RDD.scala:304)
at org.apache.spark.scheduler.ResultTask.runTask(ResultTask.scala:90)
at org.apache.spark.scheduler.Task.doRunTask(Task.scala:139)
at org.apache.spark.scheduler.Task.run(Task.scala:112)
at org.apache.spark.executor.Executor$TaskRunner$$anonfun$13.apply(Executor.scala:497)
at org.apache.spark.util.Utils$.tryWithSafeFinally(Utils.scala:1481)
at org.apache.spark.executor.Executor$TaskRunner.run(Executor.scala:503)
at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
at java.lang.Thread.run(Thread.java:748)
Driver stacktrace:
at org.apache.spark.scheduler.DAGScheduler.org$apache$spark$scheduler$DAGScheduler$$failJobAndIndependentStages(DAGScheduler.scala:2355)
at org.apache.spark.scheduler.DAGScheduler$$anonfun$abortStage$1.apply(DAGScheduler.scala:2343)
at org.apache.spark.scheduler.DAGScheduler$$anonfun$abortStage$1.apply(DAGScheduler.scala:2342)
at scala.collection.mutable.ResizableArray$class.foreach(ResizableArray.scala:59)
at scala.collection.mutable.ArrayBuffer.foreach(ArrayBuffer.scala:48)
at org.apache.spark.scheduler.DAGScheduler.abortStage(DAGScheduler.scala:2342)
at org.apache.spark.scheduler.DAGScheduler$$anonfun$handleTaskSetFailed$1.apply(DAGScheduler.scala:1096)
at org.apache.spark.scheduler.DAGScheduler$$anonfun$handleTaskSetFailed$1.apply(DAGScheduler.scala:1096)
at scala.Option.foreach(Option.scala:257)
at org.apache.spark.scheduler.DAGScheduler.handleTaskSetFailed(DAGScheduler.scala:1096)
at org.apache.spark.scheduler.DAGSchedulerEventProcessLoop.doOnReceive(DAGScheduler.scala:2574)
at org.apache.spark.scheduler.DAGSchedulerEventProcessLoop.onReceive(DAGScheduler.scala:2522)
at org.apache.spark.scheduler.DAGSchedulerEventProcessLoop.onReceive(DAGScheduler.scala:2510)
at org.apache.spark.util.EventLoop$$anon$1.run(EventLoop.scala:49)
at org.apache.spark.scheduler.DAGScheduler.runJob(DAGScheduler.scala:893)
at org.apache.spark.SparkContext.runJob(SparkContext.scala:2240)
at org.apache.spark.SparkContext.runJob(SparkContext.scala:2338)
at org.apache.spark.rdd.RDD$$anonfun$reduce$1.apply(RDD.scala:1051)
at org.apache.spark.rdd.RDDOperationScope$.withScope(RDDOperationScope.scala:151)
at org.apache.spark.rdd.RDDOperationScope$.withScope(RDDOperationScope.scala:112)
at org.apache.spark.rdd.RDD.withScope(RDD.scala:379)
at org.apache.spark.rdd.RDD.reduce(RDD.scala:1033)
at org.apache.spark.sql.Dataset$$anonfun$reduce$1.apply(Dataset.scala:1650)
at org.apache.spark.sql.Dataset$$anonfun$withNewRDDExecutionId$1.apply(Dataset.scala:3409)
at org.apache.spark.sql.execution.SQLExecution$$anonfun$withCustomExecutionEnv$1.apply(SQLExecution.scala:99)
at org.apache.spark.sql.execution.SQLExecution$.withSQLConfPropagated(SQLExecution.scala:228)
at org.apache.spark.sql.execution.SQLExecution$.withCustomExecutionEnv(SQLExecution.scala:85)
at org.apache.spark.sql.execution.SQLExecution$.withNewExecutionId(SQLExecution.scala:158)
at org.apache.spark.sql.Dataset.withNewRDDExecutionId(Dataset.scala:3405)
at org.apache.spark.sql.Dataset.reduce(Dataset.scala:1649)
at com.microsoft.ml.spark.LightGBMClassifier.train(LightGBMClassifier.scala:85)
at com.microsoft.ml.spark.LightGBMClassifier.train(LightGBMClassifier.scala:27)
at org.apache.spark.ml.Predictor.fit(Predictor.scala:118)
at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
at java.lang.reflect.Method.invoke(Method.java:498)
at py4j.reflection.MethodInvoker.invoke(MethodInvoker.java:244)
at py4j.reflection.ReflectionEngine.invoke(ReflectionEngine.java:380)
at py4j.Gateway.invoke(Gateway.java:295)
at py4j.commands.AbstractCommand.invokeMethod(AbstractCommand.java:132)
at py4j.commands.CallCommand.execute(CallCommand.java:79)
at py4j.GatewayConnection.run(GatewayConnection.java:251)
at java.lang.Thread.run(Thread.java:748)
Caused by: java.net.ConnectException: Connection refused (Connection refused)
at java.net.PlainSocketImpl.socketConnect(Native Method)
at java.net.AbstractPlainSocketImpl.doConnect(AbstractPlainSocketImpl.java:350)
at java.net.AbstractPlainSocketImpl.connectToAddress(AbstractPlainSocketImpl.java:206)
at java.net.AbstractPlainSocketImpl.connect(AbstractPlainSocketImpl.java:188)
at java.net.SocksSocketImpl.connect(SocksSocketImpl.java:392)
at java.net.Socket.connect(Socket.java:589)
at java.net.Socket.connect(Socket.java:538)
at java.net.Socket.(Socket.java:434)
at java.net.Socket.(Socket.java:211)
at com.microsoft.ml.spark.TrainUtils$.getNodes(TrainUtils.scala:178)
at com.microsoft.ml.spark.TrainUtils$$anonfun$5.apply(TrainUtils.scala:211)
at com.microsoft.ml.spark.TrainUtils$$anonfun$5.apply(TrainUtils.scala:205)
at com.microsoft.ml.spark.StreamUtilities$.using(StreamUtilities.scala:29)
at com.microsoft.ml.spark.TrainUtils$.trainLightGBM(TrainUtils.scala:204)
at com.microsoft.ml.spark.LightGBMClassifier$$anonfun$3.apply(LightGBMClassifier.scala:83)
at com.microsoft.ml.spark.LightGBMClassifier$$anonfun$3.apply(LightGBMClassifier.scala:83)
at org.apache.spark.sql.execution.MapPartitionsExec$$anonfun$5.apply(objects.scala:200)
at org.apache.spark.sql.execution.MapPartitionsExec$$anonfun$5.apply(objects.scala:197)
at org.apache.spark.rdd.RDD$$anonfun$mapPartitionsInternal$1$$anonfun$apply$24.apply(RDD.scala:852)
at org.apache.spark.rdd.RDD$$anonfun$mapPartitionsInternal$1$$anonfun$apply$24.apply(RDD.scala:852)
at org.apache.spark.rdd.MapPartitionsRDD.compute(MapPartitionsRDD.scala:60)
at org.apache.spark.rdd.RDD.computeOrReadCheckpoint(RDD.scala:340)
at org.apache.spark.rdd.RDD.iterator(RDD.scala:304)
at org.apache.spark.rdd.MapPartitionsRDD.compute(MapPartitionsRDD.scala:60)
at org.apache.spark.rdd.RDD.computeOrReadCheckpoint(RDD.scala:340)
at org.apache.spark.rdd.RDD.iterator(RDD.scala:304)
at org.apache.spark.scheduler.ResultTask.runTask(ResultTask.scala:90)
at org.apache.spark.scheduler.Task.doRunTask(Task.scala:139)
at org.apache.spark.scheduler.Task.run(Task.scala:112)
at org.apache.spark.executor.Executor$TaskRunner$$anonfun$13.apply(Executor.scala:497)
at org.apache.spark.util.Utils$.tryWithSafeFinally(Utils.scala:1481)
at org.apache.spark.executor.Executor$TaskRunner.run(Executor.scala:503)
at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
... 1 more
`
I really want to understand the reason behind this error and try the suggestions that you offer. I have been stuck on this problem since 2 weeks. I have read many similar errors, implemented some suggestions like increasing the cluster memory, configuring spark.executor.memory, repartitioning the data but still I cannot train the LightGBMClassifier with my input data.
	</description>
	<comments>
		<comment id='1' author='emnajaoua' date='2019-07-08T13:39:30Z'>
		Couple questions, are you running this on Databricks or a managed cluster service? The reason I ask is you will need to make sure the auto-scaling options are disabled for this algorithm to work properly.
Also, have you tried MMLSpark version 0.17? There were improvements to the efficiency of LightGBM that might help.
&lt;denchmark-link:https://github.com/imatiach-msft&gt;@imatiach-msft&lt;/denchmark-link&gt;
 any other ideas for debugging?
		</comment>
		<comment id='2' author='emnajaoua' date='2019-07-08T14:24:48Z'>
		Hi, thank you for your reply. I am running this on Databricks.
Concerning the auto-scaling option I didn't find as an option here in the lightgbm classifier &lt;denchmark-link:url&gt;https://mmlspark.azureedge.net/docs/pyspark/LightGBMClassifier.html&lt;/denchmark-link&gt;

I will try again with MMLSpark version 0.17
		</comment>
		<comment id='3' author='emnajaoua' date='2019-07-08T14:27:32Z'>
		hi &lt;denchmark-link:https://github.com/emnajaoua&gt;@emnajaoua&lt;/denchmark-link&gt;
 , sorry about the trouble you are having,
&lt;denchmark-code&gt;from 2 until 10 worker nodes
&lt;/denchmark-code&gt;

please make sure to disable dynamic allocation, as that is not supported yet
		</comment>
		<comment id='4' author='emnajaoua' date='2019-07-08T14:35:31Z'>
		Sorry for the confusion, I meant auto-scaling as an option on the Databricks cluster. See info here: &lt;denchmark-link:https://docs.databricks.com/user-guide/clusters/sizing.html&gt;https://docs.databricks.com/user-guide/clusters/sizing.html&lt;/denchmark-link&gt;

Make sure Enable Auto-Scaling is disabled.
		</comment>
		<comment id='5' author='emnajaoua' date='2019-07-08T15:36:43Z'>
		I did exactly as you recommended. Auto-scaling is disabled. Now I am working with 10 worker nodes and I have updated also MMLSpark to version 0.17.
the model is training since 45 minutes and I am still waiting for the result:
&lt;denchmark-link:https://user-images.githubusercontent.com/26082645/60822931-b253f300-a1a6-11e9-90c3-cf0318a52e39.png&gt;&lt;/denchmark-link&gt;

It is stuck in this step. My question is my repartioning correct ?
the train data had previously 200 partitions and then I decreased to 40 partitions.
Also, is 10 worker nodes with 28 GB memory for each is enough in my case ?
Thank you in advance :)
		</comment>
		<comment id='6' author='emnajaoua' date='2019-07-08T15:42:48Z'>
		&lt;denchmark-link:https://github.com/emnajaoua&gt;@emnajaoua&lt;/denchmark-link&gt;
 you have only 10 executors or tasks?  It looks like you have 40 tasks.  How many rows/columns do you have?  What is the current lightgbm debug output in the log4j logs - has it gotten past the network init stage?  If it hasn't gotten past network init then it may be stuck and time out (the driver might be waiting to get all of the workers and there may be fewer workers than it is expecting).
		</comment>
		<comment id='7' author='emnajaoua' date='2019-07-08T15:44:33Z'>
		Lightgbm repartitions the data to the number of possible workers/tasks on the cluster, so if you have 200 partitions it will repartition the data before doing training.
		</comment>
		<comment id='8' author='emnajaoua' date='2019-07-08T15:58:34Z'>
		&lt;denchmark-link:https://github.com/imatiach-msft&gt;@imatiach-msft&lt;/denchmark-link&gt;
 since I have 10 worker nodes I assume that I have 10 executors. or is not the case ?
I have  (9 features and the column feature according to the feature_process) and   in my train data.
Concerning the driver logs, you will find attached the log file, these are the last logs I am getting
19/07/08 15:32:29 INFO ContextCleaner: Cleaned accumulator 1096 (name: number of output rows)
19/07/08 15:32:29 INFO ContextCleaner: Cleaned accumulator 1061 (name: number of files read)
19/07/08 15:32:29 INFO ContextCleaner: Cleaned accumulator 1370 (name: internal.metrics.output.bytesWritten)
19/07/08 15:32:29 INFO ContextCleaner: Cleaned accumulator 1100 (name: collision rate (min, med, max))
19/07/08 15:32:29 INFO ContextCleaner: Cleaned accumulator 1308 (name: internal.metrics.input.sampledBytesRead)
19/07/08 15:32:29 INFO ContextCleaner: Cleaned accumulator 1063 (name: dynamic partition pruning time total (min, med, max))
19/07/08 15:32:29 INFO ContextCleaner: Cleaned accumulator 1032 (name: spill write time total (min, med, max))
19/07/08 15:32:29 INFO ContextCleaner: Cleaned accumulator 1079 (name: number of output rows)
19/07/08 15:32:29 INFO ContextCleaner: Cleaned accumulator 1271 (name: internal.metrics.shuffle.read.recordsRead)
19/07/08 15:32:29 INFO BlockManagerInfo: Removed broadcast_33_piece0 on 10.139.64.4:36295 in memory (size: 46.3 KB, free: 9.4 GB)
19/07/08 15:32:29 INFO ContextCleaner: Cleaned shuffle 38
19/07/08 15:32:29 INFO ContextCleaner: Cleaned accumulator 1003 (name: dynamic partition pruning time total (min, med, max))
19/07/08 15:32:29 INFO ContextCleaner: Cleaned accumulator 1176 (name: internal.metrics.shuffle.read.localBlocksFetched)
19/07/08 15:32:29 INFO ContextCleaner: Cleaned accumulator 1141 (name: internal.metrics.peakExecutionMemory)
19/07/08 15:32:29 INFO BlockManagerInfo: Removed broadcast_33_piece0 on 10.139.64.5:46621 in memory (size: 46.3 KB, free: 9.4 GB)
19/07/08 15:32:29 INFO BlockManagerInfo: Removed broadcast_33_piece0 on 10.139.64.7:34257 in memory (size: 46.3 KB, free: 9.4 GB)
19/07/08 15:32:29 INFO BlockManagerInfo: Removed broadcast_33_piece0 on 10.139.64.15:36649 in memory (size: 46.3 KB, free: 9.4 GB)
19/07/08 15:32:29 INFO BlockManagerInfo: Removed broadcast_33_piece0 on 10.139.64.9:38729 in memory (size: 46.3 KB, free: 9.4 GB)
19/07/08 15:37:26 INFO HiveMetaStore: 2: get_database: default
19/07/08 15:37:26 INFO audit: ugi=root	ip=unknown-ip-addr	cmd=get_database: default
19/07/08 15:37:26 INFO DriverCorral: Metastore health check ok
19/07/08 15:37:26 INFO DriverCorral: DBFS health check ok
19/07/08 15:42:26 INFO HiveMetaStore: 2: get_database: default
19/07/08 15:42:26 INFO audit: ugi=root	ip=unknown-ip-addr	cmd=get_database: default
19/07/08 15:42:26 INFO DriverCorral: Metastore health check ok
19/07/08 15:42:26 INFO DriverCorral: DBFS health check ok
19/07/08 15:47:26 INFO HiveMetaStore: 2: get_database: default
19/07/08 15:47:26 INFO audit: ugi=root	ip=unknown-ip-addr	cmd=get_database: default
19/07/08 15:47:26 INFO DriverCorral: Metastore health check ok
19/07/08 15:47:26 INFO DriverCorral: DBFS health check ok
19/07/08 15:52:26 INFO HiveMetaStore: 2: get_database: default
19/07/08 15:52:26 INFO audit: ugi=root	ip=unknown-ip-addr	cmd=get_database: default
19/07/08 15:52:26 INFO DriverCorral: Metastore health check ok
19/07/08 15:52:26 INFO DriverCorral: DBFS health check ok
		</comment>
		<comment id='9' author='emnajaoua' date='2019-07-08T16:00:39Z'>
		I apologize I don't know exactly how to attach the log file that I got from driver logs but I think that it is not stuck at the init process.
Concerning the repartitioning thing, do you think then that it is useless to repartition the train data before training the model ?
		</comment>
		<comment id='10' author='emnajaoua' date='2019-07-08T16:07:39Z'>
		&lt;denchmark-link:https://github.com/emnajaoua&gt;@emnajaoua&lt;/denchmark-link&gt;
 how many CPUs do you have per worker?  Can you make sure it is set to 1?  That was a bug fixed on latest master (to allow multiple CPUs per task).  Are you running binary or multiclass classification and how many classes?  Does each partition have at least one of each label?
		</comment>
		<comment id='11' author='emnajaoua' date='2019-07-08T16:10:30Z'>
		&lt;denchmark-link:https://github.com/emnajaoua&gt;@emnajaoua&lt;/denchmark-link&gt;
 you can also try running the build from latest master which has several fixes:
--packages
com.microsoft.ml.spark:mmlspark_2.11:0.17.dev27
and --repositories
&lt;denchmark-link:https://mmlspark.azureedge.net/maven&gt;https://mmlspark.azureedge.net/maven&lt;/denchmark-link&gt;

You can also try using barrier execution mode as I recommended here:
&lt;denchmark-link:https://github.com/Azure/mmlspark/issues/600&gt;#600&lt;/denchmark-link&gt;

&lt;denchmark-code&gt;you can set .setUseBarrierExecutionMode(true) in scala or useBarrierExecutionMode=True in python.
&lt;/denchmark-code&gt;

see doc for more info on barrier execution mode:
&lt;denchmark-link:https://github.com/Azure/mmlspark/blob/master/docs/lightgbm.md#barrier-execution-mode&gt;https://github.com/Azure/mmlspark/blob/master/docs/lightgbm.md#barrier-execution-mode&lt;/denchmark-link&gt;

Which was introduced in spark 2.4.
		</comment>
		<comment id='12' author='emnajaoua' date='2019-07-08T16:17:50Z'>
		&lt;denchmark-link:https://github.com/imatiach-msft&gt;@imatiach-msft&lt;/denchmark-link&gt;
  Thank you for your help.
I don't know exactly how many CPUs per worker but I would like to know. Here is an image of my cluster configuration
&lt;denchmark-link:https://user-images.githubusercontent.com/26082645/60825521-25ac3380-a1ac-11e9-996b-7f165b705b88.png&gt;&lt;/denchmark-link&gt;

I am not sure how to set 1 CPU per worker. is it like spark.conf.set property ?
I am running a multiclass classification: 13 classes. To be honest I am not sure that each partition have at least one label/class but I would like to know how to do it or if you have any example for that.
		</comment>
		<comment id='13' author='emnajaoua' date='2019-07-08T16:21:50Z'>
		&lt;denchmark-link:https://github.com/emnajaoua&gt;@emnajaoua&lt;/denchmark-link&gt;
  it looks like you are using databricks, which by default has 1 CPU per task, so I think you are good unless you explicitly set
&lt;denchmark-code&gt;spark.task.cpus 2
&lt;/denchmark-code&gt;

eg:
&lt;denchmark-link:https://user-images.githubusercontent.com/24683184/60825994-f4673f80-a17a-11e9-9adc-d26b76a7dd77.png&gt;&lt;/denchmark-link&gt;

		</comment>
		<comment id='14' author='emnajaoua' date='2019-07-08T16:23:10Z'>
		
@emnajaoua you can also try running the build from latest master which has several fixes:
--packages
com.microsoft.ml.spark:mmlspark_2.11:0.17.dev27
and --repositories
https://mmlspark.azureedge.net/maven
You can also try using barrier execution mode as I recommended here:
#600
you can set .setUseBarrierExecutionMode(true) in scala or useBarrierExecutionMode=True in python.

see doc for more info on barrier execution mode:
https://github.com/Azure/mmlspark/blob/master/docs/lightgbm.md#barrier-execution-mode
Which was introduced in spark 2.4.

I will try again with the useBarrierExecutionMode=True and the build from the last master. I will let you know tomorrow how did it go :)
		</comment>
		<comment id='15' author='emnajaoua' date='2019-07-08T16:24:26Z'>
		
@emnajaoua it looks like you are using databricks, which by default has 1 CPU per task, so I think you are good unless you explicitly set
spark.task.cpus 2

eg:


in my Spark config there is no specification for spark.task.cpus so I guess it is one CPU per task.
		</comment>
		<comment id='16' author='emnajaoua' date='2019-07-08T16:24:54Z'>
		can you also do a count of the distinct classes:
&lt;denchmark-link:https://stackoverflow.com/questions/30218140/spark-how-to-translate-countdistinctvalue-in-dataframe-apis&gt;https://stackoverflow.com/questions/30218140/spark-how-to-translate-countdistinctvalue-in-dataframe-apis&lt;/denchmark-link&gt;

you can use countDistinct as one way to find out how many of each class you have, but not per partition
		</comment>
		<comment id='17' author='emnajaoua' date='2019-07-09T08:01:53Z'>
		&lt;denchmark-link:https://github.com/imatiach-msft&gt;@imatiach-msft&lt;/denchmark-link&gt;
 I have implemented the countDistinct on the raw data (before feature_processor) to know the number of classes as you recommended. as I mentioned before here are the 13 classes
&lt;denchmark-link:https://user-images.githubusercontent.com/26082645/60870147-91d07b00-a230-11e9-92bc-5b3da593b2b7.png&gt;&lt;/denchmark-link&gt;

		</comment>
		<comment id='18' author='emnajaoua' date='2019-07-09T08:21:21Z'>
		&lt;denchmark-link:https://github.com/imatiach-msft&gt;@imatiach-msft&lt;/denchmark-link&gt;
 as you recommended to me, I installed the latest repo for mmlspark and I set useBarrierExecutionMode=True.
The model is still training (it has been 3 hours on this step):
&lt;denchmark-link:https://user-images.githubusercontent.com/26082645/60871543-4370ab80-a233-11e9-9a20-e276716d7b6d.png&gt;&lt;/denchmark-link&gt;

according to the logs (stdout) for one worker, it is still training
&lt;denchmark-link:https://user-images.githubusercontent.com/26082645/60871765-b0844100-a233-11e9-8103-b0c09a2747f3.png&gt;&lt;/denchmark-link&gt;

		</comment>
		<comment id='19' author='emnajaoua' date='2019-07-09T11:08:11Z'>
		&lt;denchmark-link:https://github.com/emnajaoua&gt;@emnajaoua&lt;/denchmark-link&gt;
 if you have gotten to that point then you must be training and you have gotten past the network initialization stage, which is where you were getting the connection refused error.  When you look at the workers, did any of them have status failure or success?  Sometimes a worker may exit earlier, I've seen that happen when a partition only has one label, but I think that is unlikely in your scenario. Also, with 13 classes training might take longer than usual, but based on your dataset size I don't think it should take 3 hours.  Are you seeing iterations progress in the debug?  I think it might be easier to just discuss over skype or teams, I was able to resolve an issue like that yesterday.  I can send you a teams link.
		</comment>
		<comment id='20' author='emnajaoua' date='2019-07-09T11:17:16Z'>
		I wonder if the multiclass classifier is having issues with different numbers of labels on different partitions, since some of the labels have very few instances (eg 1 or 2).  Maybe I can add a test and see if I can reproduce this issue.
		</comment>
		<comment id='21' author='emnajaoua' date='2019-07-09T11:43:44Z'>
		&lt;denchmark-link:https://github.com/imatiach-msft&gt;@imatiach-msft&lt;/denchmark-link&gt;
 concerning whether the workers have failure or success status, I stopped the training now but if it is okey with you we can schedule today a skype meeting and before that I will run my notebook again so we can check the worker statues and depending on that, we will adjust :)
		</comment>
		<comment id='22' author='emnajaoua' date='2019-07-09T15:27:51Z'>
		&lt;denchmark-link:https://github.com/emnajaoua&gt;@emnajaoua&lt;/denchmark-link&gt;

here is a teams link if that works for you:
&lt;denchmark-link:https://teams.microsoft.com/l/meetup-join/19%3ameeting_NmU1NjgyODEtYjBkNS00YTg2LTk2MDYtNzdkNTc2NWUxZDU2%40thread.v2/0?context=%7b%22Tid%22%3a%2272f988bf-86f1-41af-91ab-2d7cd011db47%22%2c%22Oid%22%3a%227ac33778-88d2-407b-bfe1-d64366fff0e4%22%7d&gt;https://teams.microsoft.com/l/meetup-join/19%3ameeting_NmU1NjgyODEtYjBkNS00YTg2LTk2MDYtNzdkNTc2NWUxZDU2%40thread.v2/0?context=%7b%22Tid%22%3a%2272f988bf-86f1-41af-91ab-2d7cd011db47%22%2c%22Oid%22%3a%227ac33778-88d2-407b-bfe1-d64366fff0e4%22%7d&lt;/denchmark-link&gt;

&lt;denchmark-h:hr&gt;&lt;/denchmark-h&gt;

Join Microsoft Teams Meeting
+1 347-991-7781   United States, New York City (Toll)
(866) 641-7188   (Toll-free)
Conference ID: 703 977 44#
Local numbers | Reset PIN | Learn more about Teams | Meeting options
&lt;denchmark-h:hr&gt;&lt;/denchmark-h&gt;

when would you prefer to discuss?
		</comment>
		<comment id='23' author='emnajaoua' date='2019-07-09T15:38:24Z'>
		&lt;denchmark-link:https://github.com/imatiach-msft&gt;@imatiach-msft&lt;/denchmark-link&gt;
 I trained the algorithm again without using repartitioning for the training data.
this is what I got as an error:
org.apache.spark.scheduler.BarrierJobUnsupportedRDDChainException: [SPARK-24820][SPARK-24821]: Barrier execution mode does not allow the following pattern of RDD chain within a barrier stage:
&lt;denchmark-h:hr&gt;&lt;/denchmark-h&gt;

Py4JJavaError                             Traceback (most recent call last)
 in ()
----&gt; 1 model = lgbm.fit(train)
/databricks/spark/python/pyspark/ml/base.py in fit(self, dataset, params)
130                 return self.copy(params)._fit(dataset)
131             else:
--&gt; 132                 return self._fit(dataset)
133         else:
134             raise ValueError("Params must be either a param map or a list/tuple of param maps, "
/databricks/spark/python/pyspark/ml/wrapper.py in _fit(self, dataset)
293
294     def _fit(self, dataset):
--&gt; 295         java_model = self._fit_java(dataset)
296         model = self._create_model(java_model)
297         return self._copyValues(model)
/databricks/spark/python/pyspark/ml/wrapper.py in _fit_java(self, dataset)
290         """
291         self._transfer_params_to_java()
--&gt; 292         return self._java_obj.fit(dataset._jdf)
293
294     def _fit(self, dataset):
/databricks/spark/python/lib/py4j-0.10.7-src.zip/py4j/java_gateway.py in call(self, *args)
1255         answer = self.gateway_client.send_command(command)
1256         return_value = get_return_value(
-&gt; 1257             answer, self.gateway_client, self.target_id, self.name)
1258
1259         for temp_arg in temp_args:
/databricks/spark/python/pyspark/sql/utils.py in deco(*a, **kw)
61     def deco(*a, **kw):
62         try:
---&gt; 63             return f(*a, **kw)
64         except py4j.protocol.Py4JJavaError as e:
65             s = e.java_exception.toString()
/databricks/spark/python/lib/py4j-0.10.7-src.zip/py4j/protocol.py in get_return_value(answer, gateway_client, target_id, name)
326                 raise Py4JJavaError(
327                     "An error occurred while calling {0}{1}{2}.\n".
--&gt; 328                     format(target_id, ".", name), value)
329             else:
330                 raise Py4JError(
Py4JJavaError: An error occurred while calling o433.fit.
: org.apache.spark.scheduler.BarrierJobUnsupportedRDDChainException: [SPARK-24820][SPARK-24821]: Barrier execution mode does not allow the following pattern of RDD chain within a barrier stage:

Ancestor RDDs that have different number of partitions from the resulting RDD (eg. union()/coalesce()/first()/take()/PartitionPruningRDD). A workaround for first()/take() can be barrierRdd.collect().head (scala) or barrierRdd.collect()[0] (python).
An RDD that depends on multiple barrier RDDs (eg. barrierRdd1.zip(barrierRdd2)).
at org.apache.spark.scheduler.DAGScheduler.checkBarrierStageWithRDDChainPattern(DAGScheduler.scala:510)
at org.apache.spark.scheduler.DAGScheduler.createResultStage(DAGScheduler.scala:585)
at org.apache.spark.scheduler.DAGScheduler.handleJobSubmitted(DAGScheduler.scala:1132)
at org.apache.spark.scheduler.DAGSchedulerEventProcessLoop.doOnReceive(DAGScheduler.scala:2531)
at org.apache.spark.scheduler.DAGSchedulerEventProcessLoop.onReceive(DAGScheduler.scala:2522)
at org.apache.spark.scheduler.DAGSchedulerEventProcessLoop.onReceive(DAGScheduler.scala:2510)
at org.apache.spark.util.EventLoop$$anon$1.run(EventLoop.scala:49)
at org.apache.spark.scheduler.DAGScheduler.runJob(DAGScheduler.scala:893)
at org.apache.spark.SparkContext.runJob(SparkContext.scala:2240)
at org.apache.spark.SparkContext.runJob(SparkContext.scala:2338)
at org.apache.spark.rdd.RDD$$anonfun$reduce$1.apply(RDD.scala:1051)
at org.apache.spark.rdd.RDDOperationScope$.withScope(RDDOperationScope.scala:151)
at org.apache.spark.rdd.RDDOperationScope$.withScope(RDDOperationScope.scala:112)
at org.apache.spark.rdd.RDD.withScope(RDD.scala:379)
at org.apache.spark.rdd.RDD.reduce(RDD.scala:1033)
at com.microsoft.ml.spark.LightGBMBase$class.innerTrain(LightGBMBase.scala:87)
at com.microsoft.ml.spark.LightGBMClassifier.innerTrain(LightGBMClassifier.scala:24)
at com.microsoft.ml.spark.LightGBMBase$class.train(LightGBMBase.scala:37)
at com.microsoft.ml.spark.LightGBMClassifier.train(LightGBMClassifier.scala:24)
at com.microsoft.ml.spark.LightGBMClassifier.train(LightGBMClassifier.scala:24)
at org.apache.spark.ml.Predictor.fit(Predictor.scala:118)
at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
at java.lang.reflect.Method.invoke(Method.java:498)
at py4j.reflection.MethodInvoker.invoke(MethodInvoker.java:244)
at py4j.reflection.ReflectionEngine.invoke(ReflectionEngine.java:380)
at py4j.Gateway.invoke(Gateway.java:295)
at py4j.commands.AbstractCommand.invokeMethod(AbstractCommand.java:132)
at py4j.commands.CallCommand.execute(CallCommand.java:79)
at py4j.GatewayConnection.run(GatewayConnection.java:251)
at java.lang.Thread.run(Thread.java:748)

		</comment>
		<comment id='24' author='emnajaoua' date='2019-07-09T15:44:13Z'>
		
@emnajaoua
here is a teams link if that works for you:
https://teams.microsoft.com/l/meetup-join/19%3ameeting_NmU1NjgyODEtYjBkNS00YTg2LTk2MDYtNzdkNTc2NWUxZDU2%40thread.v2/0?context=%7b%22Tid%22%3a%2272f988bf-86f1-41af-91ab-2d7cd011db47%22%2c%22Oid%22%3a%227ac33778-88d2-407b-bfe1-d64366fff0e4%22%7d
Join Microsoft Teams Meeting
+1 347-991-7781 United States, New York City (Toll)
(866) 641-7188 (Toll-free)
Conference ID: 703 977 44#
Local numbers | Reset PIN | Learn more about Teams | Meeting options
when would you prefer to discuss?

I am available now if you like :)
		</comment>
		<comment id='25' author='emnajaoua' date='2019-07-09T15:44:44Z'>
		&lt;denchmark-link:https://github.com/emnajaoua&gt;@emnajaoua&lt;/denchmark-link&gt;
  sure we can meet right now
		</comment>
		<comment id='26' author='emnajaoua' date='2019-07-09T16:49:18Z'>
		debugged on call, this issue looks similar to &lt;denchmark-link:https://github.com/Azure/mmlspark/issues/569&gt;#569&lt;/denchmark-link&gt;
 , the workers seem to be getting out of sync.  I wonder if it is due to unbalanced classes, since for some classes there are only 1 or 2 instances.
		</comment>
		<comment id='27' author='emnajaoua' date='2019-07-10T16:30:30Z'>
		as disussed yesterday, I will try the first solution which is removing classes that have less instances.
This is the list of classes that I have
&lt;denchmark-link:https://user-images.githubusercontent.com/26082645/60986872-b9af0400-a340-11e9-9b30-e5768a5b6683.png&gt;&lt;/denchmark-link&gt;

they have more or less instances comparing to the previous dataframe.
So the classes now have more instances than before. I have used the same configuration as discussed yesterday in the meeting but I received the connection refused error again.
Here are screenshots from the worker stderr:
&lt;denchmark-link:https://user-images.githubusercontent.com/26082645/60986316-81f38c80-a33f-11e9-8f53-014d66adda0d.png&gt;&lt;/denchmark-link&gt;

&lt;denchmark-link:https://user-images.githubusercontent.com/26082645/60986413-b5361b80-a33f-11e9-9a68-f5d526d4cf67.png&gt;&lt;/denchmark-link&gt;

I doubt that this is due to another notebook in databricks using the same resources or this cannot be the reason ? I will test again tomorrow and will update you here.
		</comment>
		<comment id='28' author='emnajaoua' date='2019-07-10T16:37:38Z'>
		&lt;denchmark-link:https://github.com/emnajaoua&gt;@emnajaoua&lt;/denchmark-link&gt;

"due to another notebook in databricks using the same resources or this cannot be the reason"
I don't think that would be the reason.
The iterations are in order here though, which looks much better than when we looked at it.  How many iterations did you set, and how long did you run it for?  Also, did you shuffle the dataset beforehand (I believe the classes should be distributed across all partitions such that on each partition at least one instance of each class should appear, but I could be wrong)?
		</comment>
		<comment id='29' author='emnajaoua' date='2019-07-10T16:54:17Z'>
		also if you remove classes 12, 3, 5, 7 - do you still see the connection refused error?  What if you just have classes 2 and 4 and use binary classification?  Also, are you using string indexer on the label column - the labels need to start from 0 to n.  I'm also wondering if you could try using multiclassova objective, although it would be much slower, it's worth trying it out: &lt;denchmark-link:https://github.com/microsoft/LightGBM/blob/master/docs/Parameters.rst#objective&gt;https://github.com/microsoft/LightGBM/blob/master/docs/Parameters.rst#objective&lt;/denchmark-link&gt;

		</comment>
		<comment id='30' author='emnajaoua' date='2019-07-11T02:41:42Z'>
		hi &lt;denchmark-link:https://github.com/emnajaoua&gt;@emnajaoua&lt;/denchmark-link&gt;
 I was able to reproduce the issue for multiclass classifier, I've put the test case in a branch:
&lt;denchmark-link:https://github.com/imatiach-msft/mmlspark/commit/c2568b11ab6e4f74a7f349d84cb8358437eed2b2&gt;imatiach-msft@c2568b1&lt;/denchmark-link&gt;

I've confirmed the following:
1.) If the labels on a partition skip a value, eg [0 to j] inclusive, and [j+2 to k], lightgbm multiclass classifier gets stuck
2.) if parititions have different labels but some have fewer than others, eg one has 0 to k and another has 0 to k+1, lightgbm multiclass classifier finishes
My recommendation is to ensure that all partitions have all labels from 0 to total number of labels.
In your image above you have labels 12, 1, 3, 5, 4, 8, 7, 2 - but you are missing label 0, 6, 9, 10, 11.
Can you try running StringIndexer or ValueIndexer, as I do in the multiclass lightgbm tests:
&lt;denchmark-code&gt;import com.microsoft.ml.spark.featurize.ValueIndexer
val labelizer = new ValueIndexer().setInputCol(labelColumnName).setOutputCol(labelColumnName).fit(tmpTrainData)
    val labelizedData = labelizer.transform(tmpTrainData)
&lt;/denchmark-code&gt;

		</comment>
		<comment id='31' author='emnajaoua' date='2019-07-13T17:39:16Z'>
		&lt;denchmark-link:https://github.com/emnajaoua&gt;@emnajaoua&lt;/denchmark-link&gt;
 I did some testing of my StatifiedRepartition transformer and I've found several surprising things that I misunderstood:
1.) sampleByKey and sampleByKeyExact only samples values within a partition by key
2.) The ratios samples for each key, so they don't need to add up to 1.  The ratios can also be larger than 1.
I still don't see a way to do a shuffle that absolutely guarantees that the labels will be "stratified" across all partitions equally.  That's the part that I am still trying to figure out.
		</comment>
		<comment id='32' author='emnajaoua' date='2019-07-14T04:04:14Z'>
		&lt;denchmark-link:https://github.com/emnajaoua&gt;@emnajaoua&lt;/denchmark-link&gt;
 great news, I was able to:
1.) create a transformer that you can use to do the stratified repartitioning of the data
2.) throw an early termination error within lightgbm multiclass classifier if any labels are skipped - I also added the test that I mentioned above and I was able to validate that lightgbm no longer gets stuck and terminates early
I created a PR here:
&lt;denchmark-link:https://github.com/Azure/mmlspark/pull/618&gt;#618&lt;/denchmark-link&gt;

will let you know when a build is ready so you can try it out
		</comment>
		<comment id='33' author='emnajaoua' date='2019-07-15T07:13:32Z'>
		&lt;denchmark-link:https://github.com/imatiach-msft&gt;@imatiach-msft&lt;/denchmark-link&gt;
  Thank you so much for your support so far. I am still working on balancing the dataset. I think by that time your PR will be merged :)
		</comment>
		<comment id='34' author='emnajaoua' date='2019-07-15T11:14:18Z'>
		&lt;denchmark-link:https://github.com/emnajaoua&gt;@emnajaoua&lt;/denchmark-link&gt;
 I've got a build for my PR here:
--packages
com.microsoft.ml.spark:mmlspark:0.17+79-2d5b4dda
and --repositories
&lt;denchmark-link:https://mmlspark.azureedge.net/maven&gt;https://mmlspark.azureedge.net/maven&lt;/denchmark-link&gt;

would you be able to try it out?  Specifically, you will need to use ValueIndexer followed by StratifiedRepartition, which should do the balancing for you (but it will make the dataset much larger).  It will make all labels have the same number of instances.  I may need to test it a bit more, and maybe update the interface, but it should work for you unless you go out of memory due to the larger number of instances on your cluster.
I also added an exception to LightGBM, so it would terminate much faster with a good error message, instead of getting stuck when some labels are missing on some partitions.
		</comment>
		<comment id='35' author='emnajaoua' date='2019-07-15T11:18:03Z'>
		you will just need to call in pyspark:
from mmlspark.stages import StratifiedRepartition
stratifiedTrainData = StratifiedRepartition(labelCol="my_label").transform(trainData)
the pyspark bindings for the PR should be automatically generated
		</comment>
		<comment id='36' author='emnajaoua' date='2019-07-15T11:23:34Z'>
		also, if it does go out of memory, you can just call it with "original" instead of "equal" fraction parameter, but you will need to make sure the number of instances for each label is at least as many as the number of partitions (and hopefully several times more).
		</comment>
		<comment id='37' author='emnajaoua' date='2019-07-15T11:29:18Z'>
		&lt;denchmark-link:https://github.com/imatiach-msft&gt;@imatiach-msft&lt;/denchmark-link&gt;
 I am kind of stuck in the process of balancing the dataset. Before when I tried the ValueIndexer and StratifiedSampler it didn't work with this those labels
&lt;denchmark-link:https://user-images.githubusercontent.com/26082645/61213157-81267600-a704-11e9-973f-95f3b8f30f15.png&gt;&lt;/denchmark-link&gt;

when I worked before with only those classes [11, 0, 2, 4, 3, 7, 6, 1], the training was completed.
		</comment>
		<comment id='38' author='emnajaoua' date='2019-07-15T11:30:54Z'>
		&lt;denchmark-link:https://github.com/emnajaoua&gt;@emnajaoua&lt;/denchmark-link&gt;
 the StratifiedRepartition transformer I added will balance the labels by default, so you will have the same count for each label
		</comment>
		<comment id='39' author='emnajaoua' date='2019-07-15T12:15:12Z'>
		
@emnajaoua the StratifiedRepartition transformer I added will balance the labels by default, so you will have the same count for each label

This is the labels screenshot after using the stratifiedTransformer
&lt;denchmark-link:https://user-images.githubusercontent.com/26082645/61215327-d9f90d00-a70a-11e9-875e-edb83d192f50.png&gt;&lt;/denchmark-link&gt;

As sais previsouly , this is the code I am using for stratified sampling
fractions = labelizedData.select("kategorie1").distinct().withColumn("fraction", lit(0.3)).rdd.collectAsMap()
sampled_df = labelizedData.stat.sampleBy("kategorie1", fractions, seed=12)
I will remove label 10 and merge label 8 and 9 together.
		</comment>
		<comment id='40' author='emnajaoua' date='2019-07-15T13:20:23Z'>
		I have an idea to use weightCol parameter in the LightGBMClassifier, may be it will help balancing the data.
&lt;denchmark-link:https://mmlspark.azureedge.net/docs/pyspark/LightGBMClassifier.html&gt;https://mmlspark.azureedge.net/docs/pyspark/LightGBMClassifier.html&lt;/denchmark-link&gt;

		</comment>
		<comment id='41' author='emnajaoua' date='2019-07-15T13:42:33Z'>
		Sorry, what does the code look like with stratified repartition?  Can you make sure to not use any sampling logic like above and get the count after stratified repartition?  Also, maybe we can meet over teams, as I'm a bit confused that after running the stratified repartition you are not getting the same counts for all labels.

Get Outlook for Android&lt;&lt;denchmark-link:https://aka.ms/ghei36&gt;https://aka.ms/ghei36&lt;/denchmark-link&gt;
&gt;
&lt;denchmark-link:#&gt;…&lt;/denchmark-link&gt;


________________________________
From: emnajaoua &lt;notifications@github.com&gt;
Sent: Monday, July 15, 2019 9:20:29 AM
To: Azure/mmlspark &lt;mmlspark@noreply.github.com&gt;
Cc: Ilya Matiach &lt;ilmat@microsoft.com&gt;; Mention &lt;mention@noreply.github.com&gt;
Subject: Re: [Azure/mmlspark] java.net.ConnectException: Connection refused (Connection refused) with LightGBMClassifier in Databricks (#609)


I have an idea to use weightCol parameter in the LightGBMClassifier, may be it will help balancing the data.
https://mmlspark.azureedge.net/docs/pyspark/LightGBMClassifier.html&lt;https://nam06.safelinks.protection.outlook.com/?url=https%3A%2F%2Fmmlspark.azureedge.net%2Fdocs%2Fpyspark%2FLightGBMClassifier.html&amp;data=02%7C01%7Cilmat%40microsoft.com%7C09857e6343c14d24c95b08d70927355a%7C72f988bf86f141af91ab2d7cd011db47%7C1%7C0%7C636987936316068436&amp;sdata=AZW7brGm4IID6AnOIQDRqndk3dfKIPHczDeM4Anc0ZU%3D&amp;reserved=0&gt;

—
You are receiving this because you were mentioned.
Reply to this email directly, view it on GitHub&lt;https://nam06.safelinks.protection.outlook.com/?url=https%3A%2F%2Fgithub.com%2FAzure%2Fmmlspark%2Fissues%2F609%3Femail_source%3Dnotifications%26email_token%3DAF4KFMFKTR7AOZF7EP36GMLP7R2R3A5CNFSM4H63URZ2YY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGODZ5VHRI%23issuecomment-511398853&amp;data=02%7C01%7Cilmat%40microsoft.com%7C09857e6343c14d24c95b08d70927355a%7C72f988bf86f141af91ab2d7cd011db47%7C1%7C0%7C636987936316078441&amp;sdata=90d0ZYM%2FKKrAx6pPGlulVjUvB8sMkIIIMdbT5Mlyxa8%3D&amp;reserved=0&gt;, or mute the thread&lt;https://nam06.safelinks.protection.outlook.com/?url=https%3A%2F%2Fgithub.com%2Fnotifications%2Funsubscribe-auth%2FAF4KFMFGODAN3SGV3DE5L6LP7R2R3ANCNFSM4H63URZQ&amp;data=02%7C01%7Cilmat%40microsoft.com%7C09857e6343c14d24c95b08d70927355a%7C72f988bf86f141af91ab2d7cd011db47%7C1%7C0%7C636987936316078441&amp;sdata=f%2B668NwDK7lnyhG%2BNODegOxpi3v0MNBbBa9rVhn1Tiw%3D&amp;reserved=0&gt;.

		</comment>
		<comment id='42' author='emnajaoua' date='2019-07-15T15:34:30Z'>
		
, may

I also don't know why it is not getting the same counts for all labels after using straftified repartition. The only thing that I am using before stratified partition is the Value Indexer.
So basically this is my data processing code before training the model
raw_train, raw_test = spark_random_split(projectYFeaturesTransformed_df.filter(col("kategorie1") != 10), ratio=0.8, seed=42)
columns = [c for c in projectYFeaturesTransformed_df.columns if c != 'kategorie1']
feature_processor = FeatureHasher(inputCols=columns, outputCol='features')
train = feature_processor.transform(raw_train)
test = feature_processor.transform(raw_test)
#ensure that all partitions have all labels
labelizer = ValueIndexer(inputCol="kategorie1", outputCol="kategorie1").fit(train)
labelizedData = labelizer.transform(train)
sampled_df = labelizedData.stat.sampleBy('kategorie1', {0: .60, 1: .50, 2: .90, 3: .60, 4: 1, 5: 1, 6: 1, 7: .90, 8: 1, 9: 1, 10: 1, 11: 1})
if you have time, we can discuss over Teams as this issue is taking so much time
		</comment>
		<comment id='43' author='emnajaoua' date='2019-07-15T15:40:45Z'>
		&lt;denchmark-link:https://github.com/emnajaoua&gt;@emnajaoua&lt;/denchmark-link&gt;
 that code won't work because you are sampling each label, the ratios actually need to be &gt;1 for some of your labels, and none should be less than 1.  You can use the StratifiedRepartition transformer I wrote in my PR by using the build I send you and it should handle this.  Specifically, this code won't work as you are expecting:
&lt;denchmark-code&gt;sampled_df = labelizedData.stat.sampleBy('kategorie1', {0: .60, 1: .50, 2: .90, 3: .60, 4: 1, 5: 1, 6: 1, 7: .90, 8: 1, 9: 1, 10: 1, 11: 1})
&lt;/denchmark-code&gt;

I think I was confused myself before and I may have confused you as well.  The ratios are for sampling by each label.  For example, if you have ratio .26 and 100 instances of label k, this will sample label k to 26 instances.
		</comment>
		<comment id='44' author='emnajaoua' date='2019-07-15T15:41:12Z'>
		here is a teams link if that works for you:
&lt;denchmark-link:https://teams.microsoft.com/l/meetup-join/19%3ameeting_NmU1NjgyODEtYjBkNS00YTg2LTk2MDYtNzdkNTc2NWUxZDU2%40thread.v2/0?context=%7b%22Tid%22%3a%2272f988bf-86f1-41af-91ab-2d7cd011db47%22%2c%22Oid%22%3a%227ac33778-88d2-407b-bfe1-d64366fff0e4%22%7d&gt;https://teams.microsoft.com/l/meetup-join/19%3ameeting_NmU1NjgyODEtYjBkNS00YTg2LTk2MDYtNzdkNTc2NWUxZDU2%40thread.v2/0?context=%7b%22Tid%22%3a%2272f988bf-86f1-41af-91ab-2d7cd011db47%22%2c%22Oid%22%3a%227ac33778-88d2-407b-bfe1-d64366fff0e4%22%7d&lt;/denchmark-link&gt;

Join Microsoft Teams Meeting
+1 347-991-7781 United States, New York City (Toll)
(866) 641-7188 (Toll-free)
Conference ID: 703 977 44#
Local numbers | Reset PIN | Learn more about Teams | Meeting options
when would you prefer to discuss?
		</comment>
		<comment id='45' author='emnajaoua' date='2019-07-15T15:45:11Z'>
		
@emnajaoua that code won't work because you are sampling each label, the ratios actually need to be &gt;1 for some of your labels, and none should be less than 1. You can use the StratifiedRepartition transformer I wrote in my PR by using the build I send you and it should handle this. Specifically, this code won't work as you are expecting:
sampled_df = labelizedData.stat.sampleBy('kategorie1', {0: .60, 1: .50, 2: .90, 3: .60, 4: 1, 5: 1, 6: 1, 7: .90, 8: 1, 9: 1, 10: 1, 11: 1})

I think I was confused myself before and I may have confused you as well. The ratios are for sampling by each label. For example, if you have ratio .26 and 100 instances of label k, this will sample label k to 26 instances.

If I change the ratios to more than 1, I get this error
IllegalArgumentException: 'requirement failed: Fractions must be in [0, 1], but got Map(0 -&gt; 1.5, 5 -&gt; 1.0, 10 -&gt; 1.0, 1 -&gt; 1.5, 6 -&gt; 1.0, 9 -&gt; 1.0, 2 -&gt; 1.9, 7 -&gt; 1.9, 3 -&gt; 1.6, 11 -&gt; 1.0, 8 -&gt; 1.0, 4 -&gt; 1.0).'
I will use your build then tomorrow and we will discuss over Teams. Do you have time tomorrow at 15:00 (German Time)
		</comment>
		<comment id='46' author='emnajaoua' date='2019-07-15T15:54:24Z'>
		&lt;denchmark-link:https://github.com/emnajaoua&gt;@emnajaoua&lt;/denchmark-link&gt;
 you are using the wrong function, you should use the StratifiedRepartition transformer I wrote in my PR instead of calling samplyBy in pyspark, it looks sampleBy is different from the method I am using and doesn't have this restriction, see this implementation of sampleBy which you are using that throws the error:
&lt;denchmark-link:https://github.com/apache/spark/blob/master/sql/core/src/main/scala/org/apache/spark/sql/DataFrameStatFunctions.scala#L420&gt;https://github.com/apache/spark/blob/master/sql/core/src/main/scala/org/apache/spark/sql/DataFrameStatFunctions.scala#L420&lt;/denchmark-link&gt;

there is no such restriction on the method I am using:
&lt;denchmark-link:https://github.com/apache/spark/blob/master/core/src/main/scala/org/apache/spark/rdd/PairRDDFunctions.scala#L287&gt;https://github.com/apache/spark/blob/master/core/src/main/scala/org/apache/spark/rdd/PairRDDFunctions.scala#L287&lt;/denchmark-link&gt;

		</comment>
		<comment id='47' author='emnajaoua' date='2019-07-15T16:03:13Z'>
		"Do you have time tomorrow at 15:00 (German Time)"
&lt;denchmark-link:https://github.com/emnajaoua&gt;@emnajaoua&lt;/denchmark-link&gt;
 that is 9 am EST, I'm usually at work 10 am - 6/7 pm.  Does 16:00 (German Time) work for you?  Thanks!
		</comment>
		<comment id='48' author='emnajaoua' date='2019-07-15T21:48:51Z'>
		&lt;denchmark-link:https://github.com/emnajaoua&gt;@emnajaoua&lt;/denchmark-link&gt;
 actually, I think I may be able to meet at 9 am to debug this with you
		</comment>
		<comment id='49' author='emnajaoua' date='2019-07-16T06:59:53Z'>
		
@emnajaoua actually, I think I may be able to meet at 9 am to debug this with you

So we will discuss the issue 9 a.m means 15.00 (german time)
I am afraid to tell you that I couldn't install the latest build that you sent me on databricks.
&lt;denchmark-link:https://user-images.githubusercontent.com/26082645/61273478-ee401700-a7a9-11e9-98e6-fbc030d34090.png&gt;&lt;/denchmark-link&gt;

		</comment>
		<comment id='50' author='emnajaoua' date='2019-07-16T13:02:12Z'>
		&lt;denchmark-link:https://github.com/imatiach-msft&gt;@imatiach-msft&lt;/denchmark-link&gt;
 I am online, waiting for you
		</comment>
		<comment id='51' author='emnajaoua' date='2019-07-16T13:13:51Z'>
		&lt;denchmark-link:https://github.com/emnajaoua&gt;@emnajaoua&lt;/denchmark-link&gt;
 sorry joined a bit late, online right now
		</comment>
		<comment id='52' author='emnajaoua' date='2019-07-19T03:57:49Z'>
		&lt;denchmark-link:https://github.com/emnajaoua&gt;@emnajaoua&lt;/denchmark-link&gt;
 I've updated the PR such that, if you set generateMissingLabels=True, lightgbm will automatically generate any missing labels during train, thereby guaranteeing that it won't get stuck or fail:
&lt;denchmark-link:https://github.com/Azure/mmlspark/pull/618&gt;#618&lt;/denchmark-link&gt;

In that scenario, you won't need StratifiedRepartition.  I also added another mode (renamed the fraction param to mode) to StratifiedRepartition, mode="mixed", so that the majority class would be downsampled and the minority oversampled for all classes.
Please try out the new build with:
1.) Running lightgbm without StratifiedRepartition and with generateMissingLabels param
2.) Using StratifiedRepartition with new mixed mode
		</comment>
		<comment id='53' author='emnajaoua' date='2019-07-19T04:15:33Z'>
		&lt;denchmark-link:https://github.com/emnajaoua&gt;@emnajaoua&lt;/denchmark-link&gt;
 the new build should be:
--packages
com.microsoft.ml.spark:mmlspark_2.11:0.17+83-11237da2
and --repositories
&lt;denchmark-link:https://mmlspark.azureedge.net/maven&gt;https://mmlspark.azureedge.net/maven&lt;/denchmark-link&gt;

		</comment>
		<comment id='54' author='emnajaoua' date='2019-08-05T06:39:46Z'>
		User class threw exception: org.apache.spark.SparkException: Job aborted due to stage failure: Task 23 in stage 6.0 failed 4 times, most recent failure: Lost task 23.3 in stage 6.0 (TID 684, zjy-hadoop-prc-st19.bj, executor 18): java.net.ConnectException: Connection refused (Connection refused)
at java.net.PlainSocketImpl.socketConnect(Native Method)
at java.net.AbstractPlainSocketImpl.doConnect(AbstractPlainSocketImpl.java:350)
at java.net.AbstractPlainSocketImpl.connectToAddress(AbstractPlainSocketImpl.java:206)
at java.net.AbstractPlainSocketImpl.connect(AbstractPlainSocketImpl.java:188)
at java.net.SocksSocketImpl.connect(SocksSocketImpl.java:392)
at java.net.Socket.connect(Socket.java:589)
at java.net.Socket.connect(Socket.java:538)
at java.net.Socket.(Socket.java:434)
at java.net.Socket.(Socket.java:211)
at com.microsoft.ml.spark.TrainUtils$.getNetworkInitNodes(TrainUtils.scala:240)
at com.microsoft.ml.spark.TrainUtils$$anonfun$7.apply(TrainUtils.scala:303)
at com.microsoft.ml.spark.TrainUtils$$anonfun$7.apply(TrainUtils.scala:298)
at com.microsoft.ml.spark.StreamUtilities$.using(StreamUtilities.scala:29)
at com.microsoft.ml.spark.TrainUtils$.trainLightGBM(TrainUtils.scala:297)
at com.microsoft.ml.spark.LightGBMBase$$anonfun$4.apply(LightGBMBase.scala:49)
at com.microsoft.ml.spark.LightGBMBase$$anonfun$4.apply(LightGBMBase.scala:49)
at org.apache.spark.sql.execution.MapPartitionsExec$$anonfun$6.apply(objects.scala:186)
at org.apache.spark.sql.execution.MapPartitionsExec$$anonfun$6.apply(objects.scala:183)
at org.apache.spark.rdd.RDD$$anonfun$mapPartitionsInternal$1$$anonfun$apply$25.apply(RDD.scala:844)
at org.apache.spark.rdd.RDD$$anonfun$mapPartitionsInternal$1$$anonfun$apply$25.apply(RDD.scala:844)
at org.apache.spark.rdd.MapPartitionsRDD.compute(MapPartitionsRDD.scala:38)
at org.apache.spark.rdd.RDD.computeOrReadCheckpoint(RDD.scala:323)
at org.apache.spark.rdd.RDD.iterator(RDD.scala:287)
at org.apache.spark.rdd.MapPartitionsRDD.compute(MapPartitionsRDD.scala:38)
at org.apache.spark.rdd.RDD.computeOrReadCheckpoint(RDD.scala:323)
at org.apache.spark.rdd.RDD.iterator(RDD.scala:287)
at org.apache.spark.scheduler.ResultTask.runTask(ResultTask.scala:87)
at org.apache.spark.scheduler.Task.run(Task.scala:100)
at org.apache.spark.executor.Executor$TaskRunner.run(Executor.scala:335)
at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
at java.lang.Thread.run(Thread.java:748)
Driver stacktrace:
at org.apache.spark.scheduler.DAGScheduler.org$apache$spark$scheduler$DAGScheduler$$failJobAndIndependentStages(DAGScheduler.scala:1515)
at org.apache.spark.scheduler.DAGScheduler$$anonfun$abortStage$1.apply(DAGScheduler.scala:1503)
at org.apache.spark.scheduler.DAGScheduler$$anonfun$abortStage$1.apply(DAGScheduler.scala:1502)
at scala.collection.mutable.ResizableArray$class.foreach(ResizableArray.scala:59)
at scala.collection.mutable.ArrayBuffer.foreach(ArrayBuffer.scala:48)
at org.apache.spark.scheduler.DAGScheduler.abortStage(DAGScheduler.scala:1502)
at org.apache.spark.scheduler.DAGScheduler$$anonfun$handleTaskSetFailed$1.apply(DAGScheduler.scala:816)
at org.apache.spark.scheduler.DAGScheduler$$anonfun$handleTaskSetFailed$1.apply(DAGScheduler.scala:816)
at scala.Option.foreach(Option.scala:257)
at org.apache.spark.scheduler.DAGScheduler.handleTaskSetFailed(DAGScheduler.scala:816)
at org.apache.spark.scheduler.DAGSchedulerEventProcessLoop.doOnReceive(DAGScheduler.scala:1740)
at org.apache.spark.scheduler.DAGSchedulerEventProcessLoop.onReceive(DAGScheduler.scala:1695)
at org.apache.spark.scheduler.DAGSchedulerEventProcessLoop.onReceive(DAGScheduler.scala:1684)
at org.apache.spark.util.EventLoop$$anon$1.run(EventLoop.scala:48)
at org.apache.spark.scheduler.DAGScheduler.runJob(DAGScheduler.scala:641)
at org.apache.spark.SparkContext.runJob(SparkContext.scala:1957)
at org.apache.spark.SparkContext.runJob(SparkContext.scala:2020)
at org.apache.spark.rdd.RDD$$anonfun$reduce$1.apply(RDD.scala:1059)
at org.apache.spark.rdd.RDDOperationScope$.withScope(RDDOperationScope.scala:151)
at org.apache.spark.rdd.RDDOperationScope$.withScope(RDDOperationScope.scala:112)
at org.apache.spark.rdd.RDD.withScope(RDD.scala:362)
at org.apache.spark.rdd.RDD.reduce(RDD.scala:1041)
at org.apache.spark.sql.Dataset.reduce(Dataset.scala:1426)
at com.microsoft.ml.spark.LightGBMBase$class.train(LightGBMBase.scala:51)
at com.microsoft.ml.spark.LightGBMClassifier.train(LightGBMClassifier.scala:23)
at com.microsoft.ml.spark.LightGBMClassifier.train(LightGBMClassifier.scala:23)
at org.apache.spark.ml.Predictor.fit(Predictor.scala:96)
at org.apache.spark.ml.Predictor.fit(Predictor.scala:72)
at com.microsoft.ml.spark.TrainClassifier.fit(TrainClassifier.scala:171)
at com.xiaomi.yuanjie.push.ModelWZ$.main(ModelWZ.scala:51)
at com.xiaomi.yuanjie.push.ModelWZ.main(ModelWZ.scala)
at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
at java.lang.reflect.Method.invoke(Method.java:498)
at org.apache.spark.deploy.yarn.ApplicationMaster$$anon$3.run(ApplicationMaster.scala:682)
Caused by: java.net.ConnectException: Connection refused (Connection refused)
at java.net.PlainSocketImpl.socketConnect(Native Method)
at java.net.AbstractPlainSocketImpl.doConnect(AbstractPlainSocketImpl.java:350)
at java.net.AbstractPlainSocketImpl.connectToAddress(AbstractPlainSocketImpl.java:206)
at java.net.AbstractPlainSocketImpl.connect(AbstractPlainSocketImpl.java:188)
at java.net.SocksSocketImpl.connect(SocksSocketImpl.java:392)
at java.net.Socket.connect(Socket.java:589)
at java.net.Socket.connect(Socket.java:538)
at java.net.Socket.(Socket.java:434)
at java.net.Socket.(Socket.java:211)
at com.microsoft.ml.spark.TrainUtils$.getNetworkInitNodes(TrainUtils.scala:240)
at com.microsoft.ml.spark.TrainUtils$$anonfun$7.apply(TrainUtils.scala:303)
at com.microsoft.ml.spark.TrainUtils$$anonfun$7.apply(TrainUtils.scala:298)
at com.microsoft.ml.spark.StreamUtilities$.using(StreamUtilities.scala:29)
at com.microsoft.ml.spark.TrainUtils$.trainLightGBM(TrainUtils.scala:297)
at com.microsoft.ml.spark.LightGBMBase$$anonfun$4.apply(LightGBMBase.scala:49)
at com.microsoft.ml.spark.LightGBMBase$$anonfun$4.apply(LightGBMBase.scala:49)
at org.apache.spark.sql.execution.MapPartitionsExec$$anonfun$6.apply(objects.scala:186)
at org.apache.spark.sql.execution.MapPartitionsExec$$anonfun$6.apply(objects.scala:183)
at org.apache.spark.rdd.RDD$$anonfun$mapPartitionsInternal$1$$anonfun$apply$25.apply(RDD.scala:844)
at org.apache.spark.rdd.RDD$$anonfun$mapPartitionsInternal$1$$anonfun$apply$25.apply(RDD.scala:844)
at org.apache.spark.rdd.MapPartitionsRDD.compute(MapPartitionsRDD.scala:38)
at org.apache.spark.rdd.RDD.computeOrReadCheckpoint(RDD.scala:323)
at org.apache.spark.rdd.RDD.iterator(RDD.scala:287)
at org.apache.spark.rdd.MapPartitionsRDD.compute(MapPartitionsRDD.scala:38)
at org.apache.spark.rdd.RDD.computeOrReadCheckpoint(RDD.scala:323)
at org.apache.spark.rdd.RDD.iterator(RDD.scala:287)
at org.apache.spark.scheduler.ResultTask.runTask(ResultTask.scala:87)
at org.apache.spark.scheduler.Task.run(Task.scala:100)
at org.apache.spark.executor.Executor$TaskRunner.run(Executor.scala:335)
at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
at java.lang.Thread.run(Thread.java:748)
		</comment>
		<comment id='55' author='emnajaoua' date='2019-08-26T00:31:26Z'>
		&lt;denchmark-link:https://github.com/imatiach-msft&gt;@imatiach-msft&lt;/denchmark-link&gt;
 - I have a large number of classes (&gt;100) which are highly imbalanced. I followed the discussion above and tried:

Removing classes with less than 500 samples.
Using ValueIndexer followed by StratifiedRepartition (both using mode="original" and mode="mixed which generates a HUGE dataset).
Using ValueIndexer by itself.
I also tried using pyspark StringIndexer and creating an increasing ID column myself.

    value_indexer = ValueIndexer(inputCol="CLASS", outputCol="label").fit(train)
    train = value_indexer.transform(train)
    test = value_indexer.transform(test)
    stratifiedTrainData = StratifiedRepartition(labelCol="label", mode="original").transform(train_limited)
    model = LightGBMClassifier(objective='multiclass', labelCol ="label", featuresCol="features").fit(stratifiedTrainData)
error is the same:
&lt;denchmark-code&gt;org.apache.spark.SparkException: Job aborted due to stage failure: Task 20 in stage 131.0 failed 4 
times, most recent failure: Lost task 20.3 in stage 131.0 (TID 6318, 10.179.68.6, executor 3): 
java.net.ConnectException: Connection refused (Connection refused)
&lt;/denchmark-code&gt;

Features is a very large vector featurised as per PySpark requirements (it contains one hot encoded ngrams + other features).
Cluster is: 5.5 (includes Apache Spark 2.4.3, Scala 2.11)
3 Workers + 1 Master
(does not auto scale)
MMLSpark: com.microsoft.ml.spark:mmlspark_2.11:0.18.1
Also tried with: com.microsoft.ml.spark:mmlspark_2.11:0.17+83-11237da2
Any ideas here?
edit:
relevant error seems to be:

19/08/26 01:06:53 INFO TaskSetManager: Starting task 17.1 in stage 38.0 (TID 960, 10.179.68.4, executor 2, partition 17, NODE_LOCAL, 5528 bytes)
19/08/26 01:06:53 WARN TaskSetManager: Lost task 19.0 in stage 38.0 (TID 940, 10.179.68.4, executor 2): java.lang.Exception: For classification, label values must start from 0 and increase by 1 to n for each partition.  Missing label 0, unique labels 31,32,35,55,73,86,99,113,114,116,133,166

Edit --&gt; Working when re-partitioned. I'm assuming re-partitioning occurs randomly for the labels? How can I re-partition while still benefiting from parallelism?
		</comment>
		<comment id='56' author='emnajaoua' date='2019-09-14T19:09:40Z'>
		
Lightgbm repartitions the data to the number of possible workers/tasks on the cluster, so if you have 200 partitions it will repartition the data before doing training.
This is good in the case when you have only one model training at a time. If I am training multiple models, this makes it a bit slower because of the increase in the total number of tasks including all different training datas. Was this considered to make lightGBM efficient? And any tips on this will be helpful.

		</comment>
		<comment id='57' author='emnajaoua' date='2019-10-09T03:27:09Z'>
		the unbalanced data issue causing lightgbm to be stuck should be fixed with the latest update to native lightgbm 2.3.1:
&lt;denchmark-link:https://github.com/Azure/mmlspark/pull/705&gt;#705&lt;/denchmark-link&gt;

the error message has now been removed, lightgbm can now work on data with missing labels in both multiclass and binary case
		</comment>
	</comments>
</bug>