<bug id='36' author='yorickdevries' open_date='2020-03-02T08:01:14Z' closed_time='2020-10-03T07:52:55Z'>
	<summary>Embedding of a directed graph</summary>
	<description>
The algorithm outputs poor quality embeddings when a directed graph is given as input. This is likely due the fact that the random walks only go one way along edge and give biased neighborhoods for that reason.
Shouldn't there be a warning when putting in directed graphs? Or perhaps an automatic conversion to an undirected graph?
	</description>
	<comments>
		<comment id='1' author='yorickdevries' date='2020-03-05T08:37:56Z'>
		"Poor quality" this is really task related
Node2vec is node2vec, it is an algorithm which operates as is on directed / undirected graph, it is up to the user to use it correctly so its outputs will have value for him. I've seen uses on directed graph for link prediction that worked as expected.
Embeddings' quality should not be measured in void, but jointly with a downstream task - if the results are not for your liking, try adjusting your graph, maybe removing the direction or playing with the hyperparameters
		</comment>
		<comment id='2' author='yorickdevries' date='2020-09-24T09:25:39Z'>
		&lt;denchmark-link:https://github.com/eliorc&gt;@eliorc&lt;/denchmark-link&gt;
 Thank you for your answer. Does the user need to specify that it is a directed graph in Node2Vec function?
		</comment>
		<comment id='3' author='yorickdevries' date='2020-09-24T09:54:53Z'>
		&lt;denchmark-link:https://github.com/chengjun&gt;@chengjun&lt;/denchmark-link&gt;
 simply put the answer is no - but eventually what you are passing to  constructor is an instance of a  graph, and in  when you build your graph and specify the edges your essentially deciding if it is a directed or any other graph variation.
So to repeat - no there is no need to tell Node2Vec constructor what type is your graph, just build it correctly (using networkx) and pass it on
		</comment>
		<comment id='4' author='yorickdevries' date='2020-09-28T09:18:05Z'>
		My tests with nx.Graph() is successful.
However, tests with nx.DiGraph() does not provide a reasonable result, although the program can run without error.
DG = nx.DiGraph()
DG.add_nodes_from(['1', '2', '3', '4', '5', '6'])
DG.add_weighted_edges_from([('1', '2', 0.1), ('1', '3', 0.9), ('1', '6', 0.8),
                            ('4', '2', 0.7), ('4', '3', 0.2), ('4', '5', 0.2)])
DG = nx.DiGraph()
DG.add_nodes_from(['1', '2', '3', '4', '5', '6'])
DG.add_weighted_edges_from([('1', '3', 0.1), ('1', '2', 0.9), ('1', '5', 0.3),
                            ('4', '3', 0.7), ('4', '2', 0.2), ('4', '6', 0.2)])
These 2 graphs provide the same result in most_similar node:
node2vec = Node2Vec(DG, dimensions=3, walk_length=4, num_walks=1000, workers=1)
model = node2vec.fit(window=2, min_count=2, batch_words=2)
for i in range(1, 7):
    print(model.wv.most_similar(str(i)))
&lt;denchmark-code&gt;[('5', 0.9058677554130554), ('2', 0.2474496066570282), ('6', -0.2980402112007141), ('3', -0.7367631196975708), ('4', -0.9357262849807739)]
[('1', 0.2474496066570282), ('4', -0.047295719385147095), ('5', -0.08435522019863129), ('3', -0.6640987396240234), ('6', -0.8502814173698425)]
[('4', 0.45873743295669556), ('6', 0.3805488049983978), ('5', -0.38110435009002686), ('2', -0.6640987396240234), ('1', -0.7367631196975708)]
[('3', 0.4587373733520508), ('6', 0.2805100679397583), ('2', -0.047295693308115005), ('1', -0.9357261657714844), ('5', -0.9911723136901855)]
[('1', 0.9058677554130554), ('2', -0.08435522019863129), ('6', -0.1596134752035141), ('3', -0.38110435009002686), ('4', -0.9911724328994751)]
[('3', 0.3805488049983978), ('4', 0.28051015734672546), ('5', -0.1596134901046753), ('1', -0.2980402410030365), ('2', -0.8502814173698425)]
&lt;/denchmark-code&gt;

		</comment>
		<comment id='5' author='yorickdevries' date='2020-09-29T08:08:16Z'>
		How do you define a reasonable result given the graphs you tested on? I can't figure out what you are trying to test here
		</comment>
		<comment id='6' author='yorickdevries' date='2020-09-29T08:19:45Z'>
		The 2 graphs that I defined have completely different links, yet they provide exactly the same node similarity result.
If we change nx.DiGraph to nx.Graph, the result will be different.
In fact, I just found that in nx.DiGraph, the result is exactly the same even if we didn't define any edges at all.
I believe the edges is not taken into calculation in directed graphs.
		</comment>
		<comment id='7' author='yorickdevries' date='2020-09-29T09:46:59Z'>
		I have checked the code and indeed there is a problem with directed graphs, can't see how I didn't come across this by now.
I'm reopening the issue and I'll try to fix it ASAP
&lt;denchmark-link:https://github.com/Wei-1&gt;@Wei-1&lt;/denchmark-link&gt;
 thanks!
		</comment>
		<comment id='8' author='yorickdevries' date='2020-09-29T09:56:02Z'>
		Opened a separate issue in &lt;denchmark-link:https://github.com/eliorc/node2vec/issues/46&gt;#46&lt;/denchmark-link&gt;

		</comment>
		<comment id='9' author='yorickdevries' date='2020-10-03T07:52:55Z'>
		I have uploaded a new version to fix the bug.
&lt;denchmark-link:https://github.com/Wei-1&gt;@Wei-1&lt;/denchmark-link&gt;
 about your experiment, in the new version you will still get similar results.
If you want to see whether the package works well, you should examine the after  examine the  parameter which encapsulates all the random walks made. After that - its pure .
So in your experiment it is something similar to trying to make Word2vec work on 10 words. The result will never have any significance to it, as it is too little in scope to yield any kind of useful information. So to sum that up, if you want to try directed graphs, you should try on bigger data with some kind of signal in it.
Anyway I thank you as you helped me identify a bug in the code üôè
		</comment>
	</comments>
</bug>