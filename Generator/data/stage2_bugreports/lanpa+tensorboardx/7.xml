<bug id='7' author='lucabergamini' open_date='2017-08-05T10:21:15Z' closed_time='2018-01-04T09:25:18Z'>
	<summary>Graph Scope</summary>
	<description>
Hi,
I'm a Pytorch beginner (previously working on th and tf) using your tensorboard-pytorch bridge to get some info during neural net training. It works like a charm for everything i've needed since now :). However i'm having some troubles with the graph visualization for some ConvNet and i've a few questions:

Is it possible to define scope for module? (i.e. if I'have a nested module can i give it a name to obtain a compress visualization of everything inside it?) ;
using the torch.cat() method i get some strange behaviours related to the order of the elements in the list of the first argument of cat() (see attached images, where the second one is correct for the code reported) .

Btw great work :)
&lt;denchmark-code&gt;def forward(self,i):
        # i stand as the input
        # conv_j is a module
        x = self.conv_0(i)
        x = self.conv_1(x)
        y = self.conv_r1(i)
        z = torch.cat((y,x),1)
        z = z.view(len(z),-1)
        z = self.fc1(z)
        z = F.relu(z)
        z = self.fc2(z)
        z = F.log_softmax(z)
        return z
&lt;/denchmark-code&gt;

&lt;denchmark-link:https://user-images.githubusercontent.com/27865235/28994833-da00f7ca-79d7-11e7-86a4-a23718366f5e.png&gt;&lt;/denchmark-link&gt;

&lt;denchmark-link:https://user-images.githubusercontent.com/27865235/28994834-da02e026-79d7-11e7-8eac-118bc93cb495.png&gt;&lt;/denchmark-link&gt;

	</description>
	<comments>
		<comment id='1' author='lucabergamini' date='2017-08-06T06:56:47Z'>
		I tried the following code
import torch
import torch.nn as nn
from torch.autograd.variable import Variable
import torch.nn.functional as F
from collections import OrderedDict
from tensorboard import SummaryWriter
class M(nn.Module):
    def __init__(self):
        super().__init__()
        self.conv_0 = nn.Conv2d(1,1,3)
        self.conv_1 = nn.Conv2d(1,1,3)
        self.conv_r1 = nn.Conv2d(1,1,5)
        self.fc1 = nn.Linear(2,1)
        self.fc2 = nn.Linear(1,1)
    def forward(self,i):
            # i stand as the input
            # conv_j is a module
            x = self.conv_0(i)
            x = self.conv_1(x)
            y = self.conv_r1(i)
            z = torch.cat((y,x),1)
            z = z.view(len(z),-1)
            z = self.fc1(z)
            z = F.relu(z)
            z = self.fc2(z)
            z = F.log_softmax(z)
            return z


writer = SummaryWriter('runbug')
m = M()
z = m(Variable(torch.Tensor(1,1,5,5), requires_grad=True))

writer.add_graph(m, z)
writer.close()
The result seems correct, can you provide a runnable code to reproduce the first graph?
&lt;denchmark-link:https://user-images.githubusercontent.com/2005323/29001203-f2b7fa06-7ab4-11e7-8416-b05f963bb589.png&gt;&lt;/denchmark-link&gt;

As for defining scope for modules, it needs to retrieve the module name associated with certain function object. I will look into it in the future.
		</comment>
		<comment id='2' author='lucabergamini' date='2017-08-06T10:05:51Z'>
		Using your code everything works fine, but if you introduce ReLU and MaxPooling you get this:
&lt;denchmark-code&gt;import torch
import torch.nn as nn
from torch.autograd.variable import Variable
import torch.nn.functional as F
from collections import OrderedDict
from tensorboard import SummaryWriter
from datetime import datetime

class M(nn.Module):
    def __init__(self):
        super(M,self).__init__()
        self.conv_0 = nn.Conv2d(1,1,3)
        self.conv_1 = nn.Conv2d(1,1,3)
        self.conv_r1 = nn.Conv2d(1,1,5)
        self.fc1 = nn.Linear(2,1)
        self.fc2 = nn.Linear(1,1)
    def forward(self,i):
            # i stand as the input
            # conv_j is a module
            x = self.conv_0(i)
            x = F.relu(x)
            x = F.max_pool2d(x,1)
            x = self.conv_1(x)
            x = F.relu(x)
            x = F.max_pool2d(x,1)
            y = self.conv_r1(i)
            y = F.relu(y)
            y = F.max_pool2d(y,1)

            z = torch.cat((x,y),1)
            z = z.view(len(z),-1)
            z = self.fc1(z)
            z = F.relu(z)
            z = self.fc2(z)
            z = F.log_softmax(z)
            return z


writer = SummaryWriter('runs/'+datetime.now().strftime('%B%d  %H:%M:%S'))
m = M()
z = m(Variable(torch.Tensor(1,1,5,5), requires_grad=True))

writer.add_graph(m, z)
writer.close()


&lt;/denchmark-code&gt;

&lt;denchmark-link:https://user-images.githubusercontent.com/27865235/29002301-88c135d2-7a9f-11e7-8b95-ad74eb60a6c8.png&gt;&lt;/denchmark-link&gt;

		</comment>
		<comment id='3' author='lucabergamini' date='2017-08-07T06:14:03Z'>
		OK, I just found a more compact network to reproduce strange output:
class M(nn.Module):
    def __init__(self):
        super(M,self).__init__()
        self.conv_x1 = nn.Conv2d(1,1,3)
        self.conv_x2 = nn.Conv2d(1,1,4)
        self.conv_y = nn.Conv2d(1,1,6)
    def forward(self,i):
        x = self.conv_x1(i)
        x = self.conv_x2(x)
        x = F.relu(x)
        y = self.conv_y(i)
        y = F.relu(y)
        z = torch.cat((x,y),1)
        return z
		</comment>
		<comment id='4' author='lucabergamini' date='2017-08-07T06:48:16Z'>
		As far as i can see your network seems fine to me.
&lt;denchmark-link:https://user-images.githubusercontent.com/27865235/29015020-6018c052-7b4c-11e7-81bc-3a49d479c318.png&gt;&lt;/denchmark-link&gt;

However, changing to this:
&lt;denchmark-code&gt;class M(nn.Module):
    def __init__(self):
        super(M,self).__init__()
        self.conv_x1 = nn.Conv2d(1,1,3)
        self.conv_x2 = nn.Conv2d(1,1,4)
        self.conv_y = nn.Conv2d(1,1,6)
    def forward(self,i):
        x = self.conv_x1(i)
        x = F.relu(x)
        x = self.conv_x2(x)
        x = F.relu(x)
        y = self.conv_y(i)
        y = F.relu(y)
        y = F.max_pool2d(y,1)
        z = torch.cat((x,y),1)
        return z
&lt;/denchmark-code&gt;

Leads to strange behaviours.
&lt;denchmark-link:https://user-images.githubusercontent.com/27865235/29015190-49fc1ea8-7b4d-11e7-8a0d-fe103d6e7eb8.png&gt;&lt;/denchmark-link&gt;

P.S. I'm a bit puzzled about the input tensors, sometimes I can't get them rendered (as in this last figure).
		</comment>
		<comment id='5' author='lucabergamini' date='2017-08-07T07:00:14Z'>
		Did you set requires_grad=True for the input variable?
btw, the graph drawing is based on autograd's back-propagation graph, I am wondering whether autograd uses internal optimizations to speed up the computation and causes this behavior. Anyway, I will look into it later :)
		</comment>
		<comment id='6' author='lucabergamini' date='2017-08-07T07:12:55Z'>
		I completely forgot it, that makes a lot of sense :)
Yeah that could explains it all...unfortunately autograd is used only in Pytorch as far as i know, so we can't just compile the same network under TF to check if the graphs match. Thank you in advance anyway, I'll try to look at the code behind in my spare time  :)
		</comment>
		<comment id='7' author='lucabergamini' date='2017-08-16T11:59:20Z'>
		is it possible to keep the module operations inside the layer block (scope)? Right now it only seems to associate weights with the scope, but it would be nice to assign the module's forward operations to the scope as well
		</comment>
		<comment id='8' author='lucabergamini' date='2017-08-16T12:02:58Z'>
		You mean to have every layers inside a user-defined module inside a single block with the name od the module?
		</comment>
		<comment id='9' author='lucabergamini' date='2017-08-16T12:49:06Z'>
		no, I meant the operations related to a given nn.Module being inside that module's scope.
If you add a graph for 2 linear layers you get 2 scopes one for each, containing only the weight and bias variables while the operations over theses variables are shown outside the scope.
It would be nice to have operations like the addmm for the linear to be positioned within the scope of it's module. The same applies to the examples above with the ConvNd and Threshold operations that appear outside the scope of the convolutional layers
		</comment>
		<comment id='10' author='lucabergamini' date='2017-08-16T13:06:21Z'>
		For the ```addmul`` case it should be easy to implement, because in fact the operation lies in the same module (the Linear one), while for the the threshold (AKA ReLU , Sigmoid, etc) I'm not quite sure since it has its own module (which you usually add in forward using F.relu() as example), so I think we need the equivalent of the scope from TF.
		</comment>
		<comment id='11' author='lucabergamini' date='2017-08-16T13:08:21Z'>
		I think the activations should be outside if you define them outside, anyway! By doing that the graph would be much cleaner
		</comment>
		<comment id='12' author='lucabergamini' date='2017-08-16T13:42:05Z'>
		The name of variable comes from
&lt;denchmark-link:https://github.com/lanpa/tensorboard-pytorch/blob/master/tensorboard/graph.py#L36&gt;https://github.com/lanpa/tensorboard-pytorch/blob/master/tensorboard/graph.py#L36&lt;/denchmark-link&gt;

However there seem no similar trick to extract that information from autograd's graph. I think the reason is that it's a pretty low level operation, object's name is not important.
The good news is there is a ongoing &lt;denchmark-link:https://github.com/ezyang/pytorch&gt;work&lt;/denchmark-link&gt;
  that makes trace possible. Once confirmed success, it should be easy to draw a pretty graph. My guess XD
		</comment>
	</comments>
</bug>