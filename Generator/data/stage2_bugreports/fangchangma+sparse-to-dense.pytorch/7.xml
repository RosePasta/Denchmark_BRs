<bug id='7' author='timethy' open_date='2018-04-20T12:54:21Z' closed_time='2018-05-21T00:19:11Z'>
	<summary>Exploding REL value</summary>
	<description>
During testing I noticed that the REL value is sometimes really large (e.g. 149966823318618112) which seems like we are dividing through almost zero.
After some debugging I found that this is indeed true,
in &lt;denchmark-link:https://github.com/fangchangma/sparse-to-dense.pytorch/blob/master/metrics.py#L42&gt;metrics.py:42
&lt;/denchmark-link&gt;
:

the minimal value of target is sometimes in the magnitude of e-10.
I believe this comes from resizing with interpolation of the depthmaps, resulting in sometimes really small but non-zero values.
I suggest that we can do
valid_mask &gt;= EPS
for some EPS around 10e-9 or something like that.
Or of course, "fix" the interpolation in the data transform phase somehow.
	</description>
	<comments>
		<comment id='1' author='timethy' date='2018-04-20T12:58:28Z'>
		While this is minor, it sometimes results in a
RuntimeError: Overflow when unpacking long
while writing into the csv which aborts training.
		</comment>
		<comment id='2' author='timethy' date='2018-04-24T04:58:21Z'>
		I understand the problem you described. However, I would suggest first making sure your data generation process is correct. Specifically, unlike a typical color image (which is dense), resizing sparse depth images can lead to spurious pixel values due to the bi-linear interpolation. 1e-10 is unlikely to be the real ground truth.
If possible, try to avoid resizing sparse depth image at all. If resizing is indeed necessary, use nearest neighbor for interpolation, rather than bi-linear or cubic interpolation.
		</comment>
		<comment id='3' author='timethy' date='2018-04-24T09:28:23Z'>
		Hi, yes, excactly. I observed that this also happens with the NYUDepthv2 dataset, so maybe we should add a filter there to get rid of these small depth values.
		</comment>
		<comment id='4' author='timethy' date='2018-05-21T00:19:10Z'>
		The culprit of the exploding REL values is a bug in the rotation (I was using bilinear interpolation rather than nearest neighbor). This has been fixed and the REL value remains stable during training.
		</comment>
	</comments>
</bug>