<bug id='209' author='Zach-ER' open_date='2018-11-25T16:49:35Z' closed_time='2018-11-25T23:28:47Z'>
	<summary>segmentation_maps_aug not working with affine transformations</summary>
	<description>
Hi there,
I am trying to use your library for cell histology augmentation and it's very good!
I have noticed, however, one issue. If I use a sequence of augmentations that doesn't include iaa.Affine, I get something like this:
I have overlaid the segmentations on the image using my own choice of colourmaps, and as you can see, the borders go nicely around the cells, even using 'piecewise affine' and a variety of other transformations.
&lt;denchmark-link:https://user-images.githubusercontent.com/8985103/48981747-443b3f80-f09f-11e8-8ed4-1d80112ea994.png&gt;&lt;/denchmark-link&gt;

The issue comes when I apply any augmentation other than translate_percent in iaa.Affine. This is an example of the results I get on using these:
&lt;denchmark-link:https://user-images.githubusercontent.com/8985103/48981801-d17e9400-f09f-11e8-8e8f-fd3189d1e925.png&gt;&lt;/denchmark-link&gt;

The borders have lost their alignments with the image somewhere in the iaa.Affine function. This happens for using any of rotate, shear or scale. Do you have any idea what could be causing this?
	</description>
	<comments>
		<comment id='1' author='Zach-ER' date='2018-11-25T18:17:04Z'>
		Can you post some code for your working/non-working augmentation sequence and how you apply it?
I guess you are calling to_deterministic() before augmenting images and segmentation maps? Do images and the segmentation maps have the same size? Are the segmentation maps provided as images or as instances of imgaug.SegmentationMapOnImage?
		</comment>
		<comment id='2' author='Zach-ER' date='2018-11-25T20:01:04Z'>
		I am using imgaug.SegmentationMapOnImage and believe the batching makes sure that to_deterministic is called. In either case, I have observed this error also while doing to_deterministic myself.
Here is the code to reproduce the bug. I am attaching two files (png image) to use with it.
&lt;denchmark-code&gt;
import imgaug as ia
from imgaug import augmenters as iaa
from imageio import imsave, imread
import numpy as np
from scipy.ndimage import sobel

import matplotlib.pyplot as plt 
import nibabel as nib 
import os 

%matplotlib inline

def get_seq(full_affine=True, p=400):

    deform_list = [iaa.Fliplr(0.5), # horizontal flips
        iaa.Flipud(0.5), # vert flip 
        iaa.PiecewiseAffine(scale=(0.02, .12))]
        
    if not full_affine:        
        deform_list.append(iaa.Affine(translate_percent={"x": (-0.1, 0.1), "y": (-0.1, 0.1)}))
    else:
        deform_list.append(iaa.Affine(scale={"x": (0.8, 1.2), "y": (0.8, 1.2)},
            translate_percent={"x": (-0.1, 0.1), "y": (-0.1, 0.1)},
            rotate=(-25, 25),
            shear=(-8, 8)))        
        
    seq = iaa.Sequential(deform_list, random_order=True) # apply augmenters in random order
    seq = iaa.Sequential([seq, iaa.Crop(p)])
    return seq

def sobel_filt(img):
    sx = sobel(img, axis=0, mode='constant')
    sy = sobel(img, axis=1, mode='constant')
    return np.hypot(sx, sy)

def load_batches(p=400):
    # Here, load 10 batches of size 4 each.
    # You can also load an infinite amount of batches, if you don't train
    # in epochs.
    batch_size = 2
    nb_batches = 2
    
    for i in range(nb_batches):
        
        # image files 
        batch_images = [imread('cell.png')] * nb_batches
        batch_images = [np.pad(img, ((p, p), (p,p), (0,0)), mode='symmetric') for img in batch_images]
        
        # segmentations 
        segs = [imread('seg.png')] * nb_batches
        segs = [np.pad(img, ((p, p), (p,p)), mode='symmetric') for img in segs]
        segs = [np.uint8(sobel_filt(img) &gt; 0) for img in segs]        
        segs = [ia.SegmentationMapOnImage(seg, shape=batch_images[0].shape, nb_classes=2) 
                for seg in segs]
                
        # Create the batch object to send to the background processes.
        batch = ia.Batch(
            images=np.array(batch_images, dtype=np.uint8),
            segmentation_maps=segs
        )

        yield batch
        
for full_affine in [True, False]: 
    batch_loader = ia.BatchLoader(load_batches)
    bg_augmenter = ia.BackgroundAugmenter(batch_loader, get_seq(full_affine))
    
    batch = bg_augmenter.get_batch()
    images_aug = batch.images_aug

    n_images = len(batch.segmentation_maps_aug)

    f, axe = plt.subplots(1, n_images, figsize=(9, 4))

    for i in range(n_images):
        # axe[0].imshow(images[0])

        axe[i].imshow(batch.images_aug[i])
        axe[i].imshow(batch.segmentation_maps_aug[i].arr[..., -1], alpha=0.4, cmap='gray')

    for ax in axe: 
        ax.set_axis_off()
        
    f.suptitle('Full affine is %s.' % ('on' if full_affine else 'not on') )
          
&lt;/denchmark-code&gt;

&lt;denchmark-link:https://user-images.githubusercontent.com/8985103/48983904-668e8680-f0ba-11e8-8fdb-c841f2ef58e8.png&gt;&lt;/denchmark-link&gt;

&lt;denchmark-link:https://user-images.githubusercontent.com/8985103/48983905-668e8680-f0ba-11e8-9f5f-b327b7a1e8cd.png&gt;&lt;/denchmark-link&gt;

		</comment>
		<comment id='3' author='Zach-ER' date='2018-11-25T22:14:14Z'>
		This should now be fixed in master.
The heatmap augmentation of Affine always behaved at a specific line as if fit_output was set to True, leading to the underlying image shapes being falsely changed, leading Crop to assume that the image for the heatmap(s) was smaller/larger than it really was and hence cropping less/more pixels than it should have.
Thanks for reporting this.
		</comment>
		<comment id='4' author='Zach-ER' date='2018-11-25T23:28:47Z'>
		Thanks for fixing so promptly! It's a great help.
		</comment>
	</comments>
</bug>