<bug id='408' author='Flamefire' open_date='2019-02-07T16:34:59Z' closed_time='2019-02-26T00:48:36Z'>
	<summary>CMake config does not contain include paths or libraries</summary>
	<description>
The CMake config in &lt;denchmark-link:https://github.com/oneapi-src/oneDNN/pull/358&gt;#358&lt;/denchmark-link&gt;
 is incomplete: It does not contain the required include paths in the install tree so programs using this fail to compile unless the includes happen to be in a standard location.
Furthermore it excludes all libraries that are required to link. This is especially fatal for static builds of MKL-DNN.
However this is a more general problem:  As a user what libraries do I need to link against? The readme states that no linking is required for dynamic builds but nothing about static builds. But knowledge from the build process is required:

Do I need to use lib/libmklml_gnu.so, lib/libmklml_intel.so or neither?
Do I need to use lib/libiomp5.so? Getting this wrong results in undefined behaviour, but how would I know if I didn't build it myself?

	</description>
	<comments>
		<comment id='1' author='Flamefire' date='2019-02-07T18:25:29Z'>
		I closed erroneously. Re-opening
		</comment>
		<comment id='2' author='Flamefire' date='2019-02-08T08:21:00Z'>
		I see several options how to solve the library problem in addition to the solution proposed in &lt;denchmark-link:https://github.com/oneapi-src/oneDNN/pull/409&gt;#409&lt;/denchmark-link&gt;
 (admittedly, I'm pretty ignorant on the subject of CMake config files, so please take this with a appropriately-sized grain of salt):

List (all?) the libraries MKL-DNN was linked to so that the config user could link to the same libraries.
Note configuration options from MKL-DNN so that they can be parsed by the user.

To me 1 looks easier, but may have inadvertent side effect, but 2 will require deeper knowledge of MKL-DNN build options.
		</comment>
		<comment id='3' author='Flamefire' date='2019-02-08T08:32:47Z'>
		
Is indeed kind of easy. Outline:


https://github.com/intel/mkl-dnn/blob/08bd90cca77683dd5d1c98068cea8b92ed05784d/src/CMakeLists.txt#L165 has the lists of libraries. This can possibly be gotten by a generator expression too, although it might be tricky
Iterate over these lists transforming the paths into filenames
Configure these filenames into the config and add it to linked libraries (not entirely sure this can be done as most is generated by CMake)
Note that removing the $&lt;BUILD_INTERFACE&gt; condition at these lines already does add the libraries to the exported one. But it uses the full paths which are/may not be valid after installation (e.g. build directory removed)
Drawback: it assumes the libraries can be found in the default linker paths (although there is a very good chance CMake will add the installed lib path to them which will find most of them) and it breaks for linked static libs (e.g. static MKL) as those are not installed.


"parsed by the user". Is that meant "manually"?

My recommendation is to get &lt;denchmark-link:https://github.com/oneapi-src/oneDNN/pull/409&gt;#409&lt;/denchmark-link&gt;
 merged for the next release to fix the include bug and make it work for shared builds. Then upgrade required CMake version to 3.x (3.8 is a reasonable choice with lots of good features and simplifications nowadays) and use targets and  functions to define dependencies and scope. Then the approach outlined in &lt;denchmark-link:https://github.com/oneapi-src/oneDNN/pull/409&gt;#409&lt;/denchmark-link&gt;
 will probably work easily.
Additional benefit: CMake has a mode similar to pkgconfig so this helps even projects not using cmake themselves.
		</comment>
		<comment id='4' author='Flamefire' date='2019-02-18T04:41:39Z'>
		Beg my pardon for delay. Was educating myself about cmake. I have a version that I'm going to push to master after I fix all the bugs... It allows doing this:
find_package(MKLDNN REQUIRED)
if(MKLDNN_THREADING MATCHES "OMP")
    find_package(OpenMP)
    if(OpenMP_CXX_FLAGS AND NOT MKLDNN_USES_INTEL_OPENMP)
        set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} ${OpenMP_CXX_FLAGS}")
    endif()
endif()

add_executable(mkldnn_cmake_package_test mkldnn_cmake_package_test.cpp)
target_link_libraries(mkldnn_cmake_package_test MKLDNN::mkldnn)
Test contents:
#include &lt;stdio.h&gt;
#include "mkldnn.h"

int main(int argc, char **argv)
{
    const mkldnn_version_t *version = mkldnn_version();
    printf("MKLDNN version: %d.%d.%d (%s)\n",
            version-&gt;major, version-&gt;minor, version-&gt;patch, version-&gt;hash);
    return 0;
}
Generated config:
# 8&gt;&lt; ---- Generated content snipped ---- &gt;&lt;8
include("${CMAKE_CURRENT_LIST_DIR}/mkldnn-targets.cmake")
set(MKLDNN_THREADING "OMP")
set(MKLDNN_USES_INTEL_OPENMP TRUE)
set(MKLDNN_USES_MKL "MKLML:SHARED")
check_required_components("mkldnn")
The transitive link dependencies are noted in IMPORTED_LINK_INTERFACE_LIBRARIES property in the target import file:
set_target_properties(MKLDNN::mkldnn PROPERTIES
  IMPORTED_LINK_INTERFACE_LIBRARIES_RELEASE "libmklml_intel.so;libiomp5.so"
  IMPORTED_LOCATION_RELEASE "${_IMPORT_PREFIX}/lib64/libmkldnn.so.0.18.0.0"
  IMPORTED_SONAME_RELEASE "libmkldnn.so.0"
  )
The thing that I could not resolve is that the cmake scripts of project that uses MKL-DNN will be responsible for locating path to those libraries on their build machine.
I think this should address both &lt;denchmark-link:https://github.com/oneapi-src/oneDNN/issues/408&gt;#408&lt;/denchmark-link&gt;
 and &lt;denchmark-link:https://github.com/oneapi-src/oneDNN/pull/409&gt;#409&lt;/denchmark-link&gt;
. There was a major cleanup, so I will probably just close the &lt;denchmark-link:https://github.com/oneapi-src/oneDNN/pull/409&gt;#409&lt;/denchmark-link&gt;
 if you are OK with that. Let me know if you want to review the changes first, and I'll push them to my private repo.
Also, I will probably push this to 0.17.x as well.
		</comment>
		<comment id='5' author='Flamefire' date='2019-02-18T08:59:22Z'>
		
The thing that I could not resolve is that the cmake scripts of project that uses MKL-DNN will be responsible for locating path to those libraries on their build machine.

This should be done though. If you link to targets this is easy. You can simply define a target mkldnn::openmp and mkldnn::intelOMP and link to either of those. In the CMakeConfig you then (try to) find both and define the targets. The exported target will then link to the one linked in at build time.

I think this should address both #408 and #409. There was a major cleanup, so I will probably just close the #409 if you are OK with that. Let me know if you want to review the changes first, and I'll push them to my private repo.

I don't see where this adresses &lt;denchmark-link:https://github.com/oneapi-src/oneDNN/pull/409&gt;#409&lt;/denchmark-link&gt;
, is some code missing? &lt;denchmark-link:https://github.com/oneapi-src/oneDNN/pull/409&gt;#409&lt;/denchmark-link&gt;
 was (mainly) about adding the missing include path. Why not take it and base your changes upon this? Or tell me what you'd like to have changed if I missed anything. Yes the refactoring is not required, but I think it is cleaner to have all this exporting at the end as it is already confusing enough ;)
I'd suggest you open a MR here (one can checkout MRs) and mention me. Then I can validate it and post suggestions if I find anything.
		</comment>
		<comment id='6' author='Flamefire' date='2019-02-18T17:46:53Z'>
		The include path is provided via
set_target_properties(MKLDNN::mkldnn PROPERTIES
  INTERFACE_INCLUDE_DIRECTORIES "${_IMPORT_PREFIX}/include"
)
in the target import file.

This should be done though. If you link to targets this is easy. You can simply define a target mkldnn::openmp and mkldnn::intelOMP and link to either of those. In the CMakeConfig you then (try to) find both and define the targets. The exported target will then link to the one linked in at build time.

I am not sure I understand this part. Can you please elaborate?
I will post an MR soonish.
Edit: the problem I am having with trying to locate the link deps in the MKL-DNN config file is that MKL-DNN does not always install all its dependencies. The only case when MKL and Intel OpenMP dependencies are installed alongside with MKL-DNN is when MKLML is used. I am not sure if we should change this.
		</comment>
		<comment id='7' author='Flamefire' date='2019-02-19T06:37:36Z'>
		Please take a look at &lt;denchmark-link:https://github.com/oneapi-src/oneDNN/pull/413&gt;#413&lt;/denchmark-link&gt;

		</comment>
		<comment id='8' author='Flamefire' date='2019-02-19T08:14:14Z'>
		
I am not sure I understand this part. Can you please elaborate?

If you target_link_libraries to an actual library then this library will appear in the generated config. If you link to a target, then this target will appear in the config. This can be used:
&lt;denchmark-code&gt;# Do this in source tree and config template:
find_package(OpenMP)
add_library(mkldnn::openmp INTERFACE)
# Add flags of openmp to this target
add_library(mkdnn::intelopenmp INTERFACE)
# Add flags of intel openmp to this target
&lt;/denchmark-code&gt;

In the source tree you then link to either target (mkldnn::openmp or mkldnn intelopenmp) which will cause this target to be used in the exported config. Hence in the end your exported target will be linked to the correct library without you having to do some if-magic with configured values. It does not hurt, that one of the libraries is potentially not found as it will be unused. If it gets used but is not found, cmake will tell you that.
		</comment>
		<comment id='9' author='Flamefire' date='2019-02-20T16:41:38Z'>
		Thanks for the clarification, this makes a lot of sense. However, we'll do this at a later point.
		</comment>
	</comments>
</bug>