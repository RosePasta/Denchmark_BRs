<bug id='918' author='lidanqing-intel' open_date='2020-12-11T02:40:27Z' closed_time='2021-01-05T00:27:21Z'>
	<summary>Interpolate formula fail on corner conditions</summary>
	<description>
&lt;denchmark-h:h1&gt;Summary&lt;/denchmark-h&gt;

Hi, I doubt there is some error in formula in &lt;denchmark-link:https://docs.oneapi.com/versions/latest/onednn/dev_guide_resampling.html&gt;https://docs.oneapi.com/versions/latest/onednn/dev_guide_resampling.html&lt;/denchmark-link&gt;

I implemented an interface calling oneDNN resampling kernel in PaddlePaddle. When working on unittest, I have some problems.
If I use formula in the API to make expected results
&lt;denchmark-link:https://user-images.githubusercontent.com/47151829/101854143-390dbc00-3b61-11eb-903d-fe803937add6.png&gt;&lt;/denchmark-link&gt;

All unittest failed.
If I use following formula
src(n, ic, ih, iw) = src(n, ic, min(max(ih, 0), IH-1), min(max(iw, 0), IW-1))
some unit tests passed, but some still fail.
Can you please suggest if following calculation is correct? Thank you
&lt;denchmark-h:h1&gt;URLs&lt;/denchmark-h&gt;

oneDNN Interpolate doc: &lt;denchmark-link:https://docs.oneapi.com/versions/latest/onednn/dev_guide_resampling.html&gt;https://docs.oneapi.com/versions/latest/onednn/dev_guide_resampling.html&lt;/denchmark-link&gt;

&lt;denchmark-h:h1&gt;Additional details&lt;/denchmark-h&gt;

My unittest reference results are calculated as follows:
&lt;denchmark-code&gt;    batch_size, channel, in_h, in_w = input.shape
    fh = out_h * 1.0 / in_h
    fw = out_w * 1.0 / in_w

    out = np.zeros((batch_size, channel, out_h, out_w))
    for oh in range(out_h):
        h0 = int(math.floor((oh + 0.5) / fh - 0.5))
        h1 = int(math.ceil((oh + 0.5) / fh - 0.5))
        Wh = (oh + 0.5) / fh - 0.5 - h0
        for ow in range(out_w):
            w0 = int(math.floor((ow + 0.5) / fw - 0.5))
            w1 = int(math.ceil((ow + 0.5) / fw - 0.5))
            Ww = (ow + 0.5) / fw - 0.5 - w0
            h0 = min(h0, in_h - 1)
            h1 = min(h1, in_h - 1)  
            w0 = min(w0, in_w - 1)
            w1 = min(w1, in_w - 1)
            input_h0_w0 = input[:, :, max(0, h0), max(0, w0)]
            input_h1_w0 = input[:, :, max(0, h1), max(0, w0)]
            input_h0_w1 = input[:, :, max(0, h0), max(0, w1)]
            input_h1_w1 = input[:, :, max(0, h1), max(0, w1)]
            out[:, :, oh,
                ow] = input_h0_w0 * Wh * Ww + input_h1_w0 * (
                    1 - Wh) * Ww + input_h0_w1 * Wh * (
                        1 - Ww) + input_h1_w1 * (1 - Wh) * (1 - Ww)

&lt;/denchmark-code&gt;

	</description>
	<comments>
		<comment id='1' author='lidanqing-intel' date='2020-12-11T03:57:13Z'>
		Hi &lt;denchmark-link:https://github.com/lidanqing-intel&gt;@lidanqing-intel&lt;/denchmark-link&gt;
, thanks for the question.
Resampling is not a straightforward operation and has tons of edge cases.


The formula you refer is about boundary conditions and I don't see how it's different from the one you are using.


Regarding rest computations, we moved away from dividing on scale factor due to correctness issues. E.g. h0 = int(math.floor((oh + 0.5) / fh - 0.5)) we validate as h0 = int(math.floor((oh + 0.5) * in_h / out_h - 0.5)). This gives the best accuracy from our testing of multiple sizes for forward and backward. Rest differences may be double checked with benchdnn: https://github.com/oneapi-src/oneDNN/blob/master/tests/benchdnn/resampling/ref_resampling.cpp. This is the way we ensure operation correctness.


To proceed further we will need the DNNL_VERBOSE output for failed cases (at least one or two) and the output of get versus expected.


Thanks.
		</comment>
		<comment id='2' author='lidanqing-intel' date='2020-12-11T21:52:47Z'>
		Hi &lt;denchmark-link:https://github.com/lidanqing-intel&gt;@lidanqing-intel&lt;/denchmark-link&gt;
, you convinced me something is wrong with these formulae. It's definitely not a  but  for ih &lt; 0. But deeper look makes actually these formulae senseless since they don't represent any connection with the reality from math point of view. We will try to make math statements more precise but one should read these assumptions that border values are remain the same.
Thanks for your input on this one. If there are more things to clarify, feel free to ask them, please. Thanks.
		</comment>
		<comment id='3' author='lidanqing-intel' date='2020-12-13T00:56:11Z'>
		&lt;denchmark-link:https://github.com/dzarukin&gt;@dzarukin&lt;/denchmark-link&gt;
  I found another place in the doc that is not aligned with the reference code. The formula in the doc
&lt;denchmark-link:https://user-images.githubusercontent.com/47151829/102000218-697e6300-3ce5-11eb-8ff3-d75c536e3417.png&gt;&lt;/denchmark-link&gt;

should be changed to
&lt;denchmark-code&gt;dst[n,c,oh,ow] = src(n,c,ih0,iw0)* (1 - Wh) * (1 - Ww) + 
                 src(n,c,ih1,iw0)* Wh * (1 - Ww) + 
                 src(n,c,ih0,iw1)* (1 - Wh) * Ww +
                 src(n,c,ih1,iw1)* Wh * Ww
&lt;/denchmark-code&gt;

After using second formula, all my unit tests passed! Thank you for pointing me the reference code link ~
Because I am enabling oneDNN resampling kernel in PaddlePaddle framework. And Baidu require large number of unit tests to check border conditions. That is why I need to implement this resampling myself in python, to compare if the oneDNN kernel results is the same as my python calculation. Thank you very much for you help !
		</comment>
		<comment id='4' author='lidanqing-intel' date='2021-01-05T00:27:19Z'>
		Fixed with &lt;denchmark-link:https://github.com/oneapi-src/oneDNN/commit/58e5ee23ffba463ae2f4584c2cdc49b584993ce2&gt;58e5ee2&lt;/denchmark-link&gt;
. Documentation is updated &lt;denchmark-link:https://oneapi-src.github.io/oneDNN/dev_guide_resampling.html&gt;online&lt;/denchmark-link&gt;
.
Thank you for the report!
		</comment>
	</comments>
</bug>