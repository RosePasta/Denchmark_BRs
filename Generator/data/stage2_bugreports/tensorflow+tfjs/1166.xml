<bug id='1166' author='unrealwill' open_date='2019-01-29T01:13:36Z' closed_time='2020-06-05T18:42:25Z'>
	<summary>Custom layer; weight import; name mismatch</summary>
	<description>
&lt;denchmark-h:h4&gt;TensorFlow.js version&lt;/denchmark-h&gt;

tfjs.version
'0.6.7'
&lt;denchmark-h:h4&gt;Browser version&lt;/denchmark-h&gt;

Chromium
Version 70.0.3538.77(Official Build) Built on Ubuntu , running on Ubuntu 16.04 (64-bit)
&lt;denchmark-h:h4&gt;Describe the problem or feature request&lt;/denchmark-h&gt;

The name of the variable generated by add_weight for a custom layer don't match between python and javascript, and therefore prevent loading the weights.
&lt;denchmark-h:h4&gt;Code to reproduce the bug / link to feature request&lt;/denchmark-h&gt;

In the exported json file the variable name for the variable value of custom layer MyCustomLayer is
In Json : my_custom_layer/value     -&gt;  In tfjs : "my_custom_layer_MyCustomLayer1/value"
In Json : my_custom_layer1/value   -&gt;  In tfjs : "my_custom_layer_MyCustomLayer2/value"
Notice that there is 2 mismatch : different number and repeated name.
If I modify the json manually so that it match the model works as expected.
The json seem homogeneous with other type of layers so the error is probably on the side of the custom layer.
I followed &lt;denchmark-link:https://groups.google.com/a/tensorflow.org/forum/#!topic/tfjs/_GnkC7CNA1s&gt;https://groups.google.com/a/tensorflow.org/forum/#!topic/tfjs/_GnkC7CNA1s&lt;/denchmark-link&gt;
 to get it to this point. But I can't find any documentation, the provided example &lt;denchmark-link:https://github.com/tensorflow/tfjs-examples/tree/master/custom-layer&gt;https://github.com/tensorflow/tfjs-examples/tree/master/custom-layer&lt;/denchmark-link&gt;
 doesn't deal with loading weights. I got some inspiration from
&lt;denchmark-link:https://github.com/tensorflow/tfjs-layers/blob/master/src/layers/core.ts#L211&gt;https://github.com/tensorflow/tfjs-layers/blob/master/src/layers/core.ts#L211&lt;/denchmark-link&gt;

There may be an issue with getClassName which is required to be defined as a static property to be used in loadModel. But the variable in add_weight is then named
originalName: "getclassname_GETCLASSNAME1/value",name:"getclassname_GETCLASSNAME1/value"
Can you please advise?
Thanks
Below is the code and results :
In python
&lt;denchmark-code&gt;import tensorflow as tf
import numpy as np
import tensorflowjs as tfjs

from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Conv2D, Activation,MaxPooling2D,Flatten,Dense,Dropout

class MyCustomLayer(tf.keras.layers.Layer):
    def __init__(self,):
        super(MyCustomLayer, self).__init__()

    def build(self, input_shape):
        self.val = self.add_weight("value",dtype=tf.float32,shape=[1],initializer=tf.random_normal_initializer())

    def compute_output_shape(self, input_shape):
        return input_shape

    def call(self, input):
        out = input + tf.reshape(self.val,(1,1,1,1))
        return out

input_shape = (10,10,3)
model = Sequential()
model.add(Conv2D(32, (3, 3), input_shape=input_shape))
model.add(MyCustomLayer() )
model.add(MyCustomLayer() )

sess = tf.Session()

print( model.predict( np.ones((1,10,10,3) ) ))

#model.save('my_model.h5')
tfjs.converters.save_keras_model(model, "folder")
&lt;/denchmark-code&gt;

In javascript :
&lt;denchmark-code&gt;class MyCustomLayer extends tf.layers.Layer {
    constructor() {
      super({});
      // TODO(bileschi): Can we point to documentation on masking here?
      this.supportsMasking = true;
    }
    build(inputShape) {
      this.val = this.addWeight("value",[1],"float32",tf.initializers.randomNormal);
      console.log("Displaying MyCustomLayer weight");
      console.log(this.val);

      this.built=true;
    }
  
    computeOutputShape(inputShape) {
      return inputShape
    }
 
    call(inputs, kwargs) {
      var input = inputs;
      if (Array.isArray(input)) {
        input = input[0];
      }
      this.invokeCallHook(inputs, kwargs);
      return tf.add( this.val.read().reshape([1,1,1,1]),input);
    }
  
    /*
    getConfig() {
      const config = {};
      const baseConfig = super.getConfig();
      Object.assign(config, baseConfig);
      return config;
  }
      getClassName() {
      return 'GETCLASSNAME';
    }
    */
  }

  export function mycustomlayer() {
    //return null;
    return new MyCustomLayer();
  }

  MyCustomLayer.className = 'MyCustomLayer'; // static variable
  //tf.serialization.SerializationMap.register(MyCustomLayer);
  tf.serialization.registerClass(MyCustomLayer);

tf.loadModel('http://localhost:3000/correctmodel.json').then( function (model)
    {
    console.log("Model : ")
    console.log(model);
    const xs = tf.ones([1,10,10,3]);
    console.log(xs);
    var res = model.predict( xs );
    console.log(res);
    }
);
&lt;/denchmark-code&gt;

The json generated :
&lt;denchmark-code&gt;{
    "weightsManifest": [
        {
            "weights": [
                {
                    "name": "conv2d/kernel",
                    "shape": [
                        3,
                        3,
                        3,
                        32
                    ],
                    "dtype": "float32"
                },
                {
                    "name": "conv2d/bias",
                    "shape": [
                        32
                    ],
                    "dtype": "float32"
                },
                {
                    "name": "my_custom_layer/value",
                    "shape": [
                        1
                    ],
                    "dtype": "float32"
                },
                {
                    "name": "my_custom_layer_1/value",
                    "shape": [
                        1
                    ],
                    "dtype": "float32"
                }
            ],
            "paths": [
                "group1-shard1of1"
            ]
        }
    ],
    "modelTopology": {
        "keras_version": "2.1.6-tf",
        "backend": "tensorflow",
        "model_config": {
            "class_name": "Sequential",
            "config": {
                "layers": [
                    {
                        "class_name": "Conv2D",
                        "config": {
                            "padding": "valid",
                            "dilation_rate": [
                                1,
                                1
                            ],
                            "name": "conv2d",
                            "bias_initializer": {
                                "class_name": "Zeros",
                                "config": {
                                    "dtype": "float32"
                                }
                            },
                            "kernel_size": [
                                3,
                                3
                            ],
                            "activity_regularizer": null,
                            "use_bias": true,
                            "kernel_initializer": {
                                "class_name": "GlorotUniform",
                                "config": {
                                    "dtype": "float32",
                                    "seed": null
                                }
                            },
                            "kernel_regularizer": null,
                            "bias_constraint": null,
                            "trainable": true,
                            "kernel_constraint": null,
                            "batch_input_shape": [
                                null,
                                10,
                                10,
                                3
                            ],
                            "activation": "linear",
                            "strides": [
                                1,
                                1
                            ],
                            "data_format": "channels_last",
                            "filters": 32,
                            "dtype": "float32",
                            "bias_regularizer": null
                        }
                    },
                    {
                        "class_name": "MyCustomLayer",
                        "config": {
                            "name": "my_custom_layer",
                            "dtype": "float32",
                            "trainable": true
                        }
                    },
                    {
                        "class_name": "MyCustomLayer",
                        "config": {
                            "name": "my_custom_layer_1",
                            "dtype": "float32",
                            "trainable": true
                        }
                    }
                ],
                "name": "sequential"
            }
        }
    }
}
&lt;/denchmark-code&gt;

The json which works :
&lt;denchmark-code&gt;{
    "weightsManifest": [
        {
            "weights": [
                {
                    "shape": [
                        3,
                        3,
                        3,
                        32
                    ],
                    "dtype": "float32",
                    "name": "conv2d/kernel"
                },
                {
                    "shape": [
                        32
                    ],
                    "dtype": "float32",
                    "name": "conv2d/bias"
                },
                {
                    "shape": [
                        1
                    ],
                    "dtype": "float32",
                    "name": "my_custom_layer_MyCustomLayer1/value"
                },
                {
                    "shape": [
                        1
                    ],
                    "dtype": "float32",
                    "name": "my_custom_layer_MyCustomLayer2/value"
                }
            ],
            "paths": [
                "group1-shard1of1"
            ]
        }
    ],
    "modelTopology": {
        "model_config": {
            "class_name": "Sequential",
            "config": {
                "name": "sequential",
                "layers": [
                    {
                        "class_name": "Conv2D",
                        "config": {
                            "activity_regularizer": null,
                            "use_bias": true,
                            "data_format": "channels_last",
                            "kernel_constraint": null,
                            "dilation_rate": [
                                1,
                                1
                            ],
                            "padding": "valid",
                            "activation": "linear",
                            "bias_regularizer": null,
                            "kernel_size": [
                                3,
                                3
                            ],
                            "filters": 32,
                            "kernel_regularizer": null,
                            "bias_initializer": {
                                "class_name": "Zeros",
                                "config": {
                                    "dtype": "float32"
                                }
                            },
                            "batch_input_shape": [
                                null,
                                10,
                                10,
                                3
                            ],
                            "kernel_initializer": {
                                "class_name": "GlorotUniform",
                                "config": {
                                    "seed": null,
                                    "dtype": "float32"
                                }
                            },
                            "trainable": true,
                            "dtype": "float32",
                            "strides": [
                                1,
                                1
                            ],
                            "name": "conv2d",
                            "bias_constraint": null
                        }
                    },
                    {
                        "class_name": "MyCustomLayer",
                        "config": {
                            "trainable": true,
                            "dtype": "float32",
                            "name": "my_custom_layer"
                        }
                    },
                    {
                        "class_name": "MyCustomLayer",
                        "config": {
                            "trainable": true,
                            "dtype": "float32",
                            "name": "my_custom_layer_1"
                        }
                    }
                ]
            }
        },
        "keras_version": "2.1.6-tf",
        "backend": "tensorflow"
    }
}
&lt;/denchmark-code&gt;

	</description>
	<comments>
		<comment id='1' author='unrealwill' date='2019-02-25T10:15:41Z'>
		So here is the ugly hack I currently have in prod to work around this issue :
For the whole file see &lt;denchmark-link:https://github.com/GistNoesis/Wisteria/blob/master/tfjs/src/LayerNorm.js&gt;https://github.com/GistNoesis/Wisteria/blob/master/tfjs/src/LayerNorm.js&lt;/denchmark-link&gt;
 and don't forget to call
&lt;denchmark-code&gt;import { LayerNorm } from './LayerNorm';
tf.serialization.registerClass(LayerNorm);
&lt;/denchmark-code&gt;

For the relevant part :
&lt;denchmark-code&gt;computeCorrectName(name) {
    //layer_norm_LayerNorm1/g  must be converted to layer_norm/g
    //layer_norm_LayerNorm2/g  must be converted to layer_norm_1/g
    var prefix = "layer_norm_LayerNorm";
    var subsr = name.substr(prefix.length);
    var vals = subsr.split('/');
    var num = parseInt(vals[0]);
    var nbstr = num == 1 ? "" : "_" + (num - 1).toString();
    var res = "layer_norm" + nbstr + "/" + vals[1];
    return res;
  }
  build(inputShape) {
    //console.log("LayerNorm build : ")
    this.g = this.addWeight("g", [inputShape[inputShape.length - 1]], "float32", tf.initializers.ones());
    this.b = this.addWeight("b", [inputShape[inputShape.length - 1]], "float32", tf.initializers.zeros());
    var gname = this.computeCorrectName(this.g.originalName);
    var bname = this.computeCorrectName(this.b.originalName);
    this.g.originalName = gname;
    this.g.name = gname;
    this.b.originalName = bname;
    this.b.name = bname;
    //console.log(this.g);
    //console.log(this.b);
    this.built = true;
}
&lt;/denchmark-code&gt;

		</comment>
		<comment id='2' author='unrealwill' date='2020-06-05T18:42:25Z'>
		Closing this due to lack of activity, feel to reopen. Thank you
		</comment>
	</comments>
</bug>