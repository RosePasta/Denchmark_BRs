<bug id='14863' author='rolandpersson' open_date='2019-06-21T21:14:53Z' closed_time='2019-06-27T06:35:29Z'>
	<summary>Access violation in boundingRect on arm64 NEON because of reading out of bounds</summary>
	<description>
&lt;denchmark-h:h5&gt;System information (version)&lt;/denchmark-h&gt;


OpenCV =&gt; 4.1
Operating System / Platform =&gt; iOS 12, arm64
Compiler =&gt; Xcode 10.2.1

&lt;denchmark-h:h5&gt;Detailed description&lt;/denchmark-h&gt;

The boundingRect() function will crash if the memory beyond the end of the array of points passed into it is not readable.
&lt;denchmark-h:h5&gt;Steps to reproduce&lt;/denchmark-h&gt;

It is difficult to produce a simple code sample that reproduces this as it will only actually crash if the memory beyond the end of the array is not readable (which it usually is). I have been able to reproduce it by passing an std::vectorcv::Point with 4096 entries to cv::boundingRect() and enabling the following memory debugging flags in Xcode.

Malloc Guard Edges
Guard Malloc

&lt;denchmark-h:h5&gt;More Info&lt;/denchmark-h&gt;

My own understanding of the problem is that vx_load_low on ARM NEON translates to an instruction that reads two 64-bit elements rather than just the low one.
The following lines from &lt;denchmark-link:https://github.com/opencv/opencv/blame/4.1.0/modules/imgproc/src/shapedescr.cpp#L768&gt;pointSetBoundingRect&lt;/denchmark-link&gt;
 is where the crash occurs:
&lt;denchmark-code&gt;        if( i &lt;= npoints - v_int32::nlanes/4 )
        {
            v_int32 ptXY = v_reinterpret_as_s32(v_expand_low(v_reinterpret_as_u32(vx_load_low(pts + i))));
            minval = v_min(ptXY, minval);
            maxval = v_max(ptXY, maxval);
            i += v_int64::nlanes/2;
        }
&lt;/denchmark-code&gt;

When it crashes i == 4095 and a single element remains to read from pts array.
This is the assembly code generated by the compiler:
&lt;denchmark-code&gt;    0x104fc9774 &lt;+400&gt;: ushll2.2d v1, v1, #0x0
    0x104fc9778 &lt;+404&gt;: smin.4s v1, v2, v1
    0x104fc977c &lt;+408&gt;: ushll.2d v2, v0, #0x0
    0x104fc9780 &lt;+412&gt;: ushll2.2d v0, v0, #0x0
    0x104fc9784 &lt;+416&gt;: smax.4s v0, v2, v0
    0x104fc9788 &lt;+420&gt;: cmp    w9, w0
    0x104fc978c &lt;+424&gt;: b.ge   0x104fc97a4               ; &lt;+448&gt; [inlined] cv::hal_baseline::v_int32x4::get0() const at shapedescr.cpp:778
    0x104fc9790 &lt;+428&gt;: add    x8, x8, w9, uxtw #3
-&gt;  0x104fc9794 &lt;+432&gt;: ld2.2d { v2, v3 }, [x8]
    0x104fc9798 &lt;+436&gt;: ushll.2d v2, v2, #0x0
    0x104fc979c &lt;+440&gt;: smin.4s v1, v2, v1
    0x104fc97a0 &lt;+444&gt;: smax.4s v0, v2, v0
    0x104fc97a4 &lt;+448&gt;: fmov   w8, s1
    0x104fc97a8 &lt;+452&gt;: fmov   w9, s0
    0x104fc97ac &lt;+456&gt;: ushll2.2d v1, v1, #0x0
&lt;/denchmark-code&gt;

The ld2.2d causes the access violation: Thread 5: EXC_BAD_ACCESS (code=2, address=0x1078d4000)
Here is the register dump:
&lt;denchmark-code&gt;General Purpose Registers:
        x0 = 0x0000000000001000
        x1 = 0x0000000000000002
        x2 = 0x00000000ffffffff
        x3 = 0x0000000000000001
        x4 = 0x0000000000008000
        x5 = 0x0000000000000003
        x6 = 0x0000000000000000
        x7 = 0x0000000000000000
        x8 = 0x00000001078d3ff8
        x9 = 0x0000000000000fff
       x10 = 0x0000000000000ffc
       x11 = 0x00000001078d3ff8
       x12 = 0x0000000000000fff
       x13 = 0x0000000000000001
       x14 = 0x0000000000000001
       x15 = 0x00000000000000d0
       x16 = 0x000000000000004a
       x17 = 0x000000025f6ce620  (void *)0x000000022ee4e5d4: malloc
       x18 = 0x0000000000000000
       x19 = 0x000000016b434908
       x20 = 0x000000016b434870
       x21 = 0x000000016b43cf58
       x22 = 0x000000016b43cf70
       x23 = 0x000000016b43d0f8
       x24 = 0x0000000000008b2b
       x25 = 0x0000000000000000
       x26 = 0x0000000000000000
       x27 = 0x0000000000000074
       x28 = 0x000000005d0d3aff
        fp = 0x000000016b43c950
        lr = 0x0000000104fc960c  `cv::pointSetBoundingRect(cv::Mat const&amp;) + 40 at shapedescr.cpp:743:5
        sp = 0x000000016b434830
        pc = 0x0000000104fc9794  `cv::pointSetBoundingRect(cv::Mat const&amp;) + 432 [inlined] cv::hal_baseline::v_load_low(long long const*) at intrin.hpp:412
 `cv::pointSetBoundingRect(cv::Mat const&amp;) + 432 [inlined] cv::hal_baseline::simd128::vx_load_low(long long const*) at shapedescr.cpp:768
 `cv::pointSetBoundingRect(cv::Mat const&amp;) + 432 at shapedescr.cpp:768
      cpsr = 0x80000000
&lt;/denchmark-code&gt;

The same crash also happens on Android devices.
	</description>
	<comments>
		<comment id='1' author='rolandpersson' date='2019-06-22T06:56:33Z'>
		Thank you for the detailed report!
I have checked OpenCV intrinsic wrappers:
 uses  which should &lt;denchmark-link:http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0472k/chr1360928371756.html&gt;transfer 64-bits only&lt;/denchmark-link&gt;
.
I can confirm such asm code on iOS binaries (Xcode 10.1).
Linux ARCH64 (GCC) produced binaries are differ in that place (element is loaded via LDR   D0, [X4,W3,SXTW#3])
So looks like this problem is iOS-specific.
		</comment>
		<comment id='2' author='rolandpersson' date='2019-06-25T14:07:00Z'>
		LD2 instruction is confirmed in Android builds with Clang too.
		</comment>
		<comment id='3' author='rolandpersson' date='2019-06-25T14:30:44Z'>
		&lt;denchmark-link:https://github.com/rolandpersson&gt;@rolandpersson&lt;/denchmark-link&gt;
 Could you try this workaround: &lt;denchmark-link:https://github.com/opencv/opencv/pull/14889&gt;#14889&lt;/denchmark-link&gt;
 ?
		</comment>
		<comment id='4' author='rolandpersson' date='2019-06-25T20:00:09Z'>
		&lt;denchmark-link:https://github.com/alalek&gt;@alalek&lt;/denchmark-link&gt;
 The workaround works. Thanks! I think this would be great to get in because the bug is in Xcode 11 beta too so it will probably be a while until this is fixed in clang...
		</comment>
	</comments>
</bug>