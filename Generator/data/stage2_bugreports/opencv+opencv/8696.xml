<bug id='8696' author='Rhialto' open_date='2017-05-05T08:10:43Z' closed_time='2017-05-17T14:13:42Z'>
	<summary>cvtColor() sometimes swaps R and B channel when not asked</summary>
	<description>
&lt;denchmark-h:h5&gt;System information (version)&lt;/denchmark-h&gt;


OpenCV =&gt; 3.2.0 (as extracted from OpenCV-3.2.0-vc14.exe)
Operating System / Platform =&gt;windows 7, 64-bit
Compiler =&gt; Visual Studio 2013
The problem was originally seen by a self-compiled OpenCV 3.1 for Android.
The example program is for Windows as shown.

&lt;denchmark-h:h5&gt;Detailed description&lt;/denchmark-h&gt;

The call cv::cvtColor(image, image, cv::COLOR_BGR2BGRA);, when the Mat is already 4 channels, swaps R and B channels.
&lt;denchmark-h:h5&gt;Steps to reproduce&lt;/denchmark-h&gt;

// This small demo shows that RGB to RGBA conversion (or BGR to BGRA, that is the same)
// has a bug when the input matrix already is 4 channels.
// Tried with OpenCV-3.2.0-vc14.exe (extracted)

#include "stdafx.h" // silly windows stuff, generated by Visual Studio
#include "opencv2/imgproc.hpp"
#include "opencv2/highgui.hpp"
#include &lt;iostream&gt;

int _tmain(int argc, _TCHAR* argv[])
{
	// Choose an image that has clear red and/or blue objects.
	std::string inputImage = "any red-blue picture really.jpg";

	cv::Mat image = cv::imread(inputImage);
	if (image.empty())
	{
		std::cerr &lt;&lt; "Cannot read image file: " &lt;&lt; inputImage &lt;&lt; std::endl;
		return -1;
	}

	// Make sure to have 4 channels
	if (image.channels() == 3) {
		cv::cvtColor(image, image, cv::COLOR_BGR2BGRA);
	}

	// This image is ok
	cv::imshow("ok", image);

	// This conversion should do nothing visible
	cv::cvtColor(image, image, cv::COLOR_BGR2BGRA);

	// Now R and B are swapped.
	cv::imshow("r-and-b-swapped", image);

	// And here they are swapped again (back to the way they should be).
	cv::cvtColor(image, image, cv::COLOR_BGR2BGRA);
	cv::imshow("r-and-b-swapped-back", image);

	cv::waitKey();
}
	</description>
	<comments>
	</comments>
</bug>