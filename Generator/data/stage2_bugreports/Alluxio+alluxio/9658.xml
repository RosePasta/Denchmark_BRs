<bug id='9658' author='ns1123' open_date='2019-08-07T00:16:39Z' closed_time='2019-08-13T01:10:08Z'>
	<summary>Failover Triggers an NPE because threads aren't shutdown correctly</summary>
	<description>
Alluxio Version:
1.8.1
Describe the bug
When Alluxio is set up to use ZooKeeper for leadership election, during a failover we see the following error message.
2019-08-04 01:30:25,058 INFO  UfsJournalReader - Reading journal file hdfs://hanameservice:8020/alluxio/journal/LicenseMaster/v1/logs/0xd1-0xd2.
2019-08-04 01:30:25,070 INFO  UfsJournalReader - Reading journal file hdfs://hanameservice:8020/alluxio/journal/LicenseMaster/v1/logs/0xd2-0xd3.
2019-08-04 01:30:26,283 INFO  UfsJournalCheckpointThread - BlockMaster: Journal checkpoint thread started.
2019-08-04 01:30:26,283 INFO  UfsJournalCheckpointThread - CallHomeMaster: Journal checkpoint thread started.
2019-08-04 01:30:26,286 INFO  UfsJournalReader - Reading journal file hdfs://hanameservice:8020/alluxio/journal/BlockMaster/v1/checkpoints/0x0-0x22d6f62.
2019-08-04 01:30:26,304 INFO  UfsJournalLogWriter - Marking hdfs://hanameservice:8020/alluxio/journal/FileSystemMaster/v1/logs/0xcd4688b-0x7fffffffffffffff as complete with log entries within [215246987, 215252063).
2019-08-04 01:30:26,304 INFO  UfsJournalLogWriter - Completing log hdfs://hanameservice:8020/alluxio/journal/FileSystemMaster/v1/logs/0xcd4688b-0x7fffffffffffffff with next sequence number 215252063
2019-08-04 01:30:26,313 ERROR HeartbeatThread - Uncaught exception in heartbeat executor, Heartbeat Thread shutting down
java.lang.NullPointerException: Cannot call isRootId() before initializeRoot()
at com.google.common.base.Preconditions.checkNotNull(Preconditions.java:208)
at alluxio.master.file.meta.InodeTree.isRootId(InodeTree.java:1168)
at alluxio.master.file.meta.InodeTree.computePathForInode(InodeTree.java:441)
at alluxio.master.file.meta.InodeTree.lockFullInodePath(InodeTree.java:376)
at alluxio.master.file.LostFileDetector.heartbeat(LostFileDetector.java:48)
at alluxio.heartbeat.HeartbeatThread.run(HeartbeatThread.java:74)
at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)
at java.util.concurrent.FutureTask.run(FutureTask.java:266)
at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
at java.lang.Thread.run(Thread.java:748)
This indicates that even though the master relinquished leadership, not all background threads were properly terminated. This results in isRootId() being called before initializeRoot().
To Reproduce
Unclear how to reproduce consistently.
Expected behavior
Failover should be clean and the secondary master should take leadership.
Urgency
Medium
Additional context
NPE's are bad.
	</description>
	<comments>
		<comment id='1' author='ns1123' date='2019-08-07T04:19:00Z'>
		Apparently there is a bug in the way we shut down our masters. In AbstractMaster.stop(), shutdownNow is called where shutdown should have been called. This causes following awaitTermination to be a no-op and there could always remain tasks that are executing after shutdown. This has nothing to do with Zookeeper as any master that restarts quickly will likely to encounter this or similar issue when under load. This issue exist on master branch.
A general straightforward fix is not easy in our case because HeartbeatThread runs on a dedicated thread that will not be interrupted when executor is closed by a shutdown call.
shutdownNow interrupts existing tasks but this particular LostFileDetector heartbeat thread may not be handling interruptions in a timely manner. Then it's likely it'll keep running on an already closed InodeTree as seen in the stacktrace.
		</comment>
	</comments>
</bug>