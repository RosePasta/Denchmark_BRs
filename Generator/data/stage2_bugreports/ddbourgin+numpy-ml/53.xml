<bug id='53' author='eromoe' open_date='2020-07-13T09:54:31Z' closed_time='2020-07-27T16:03:25Z'>
	<summary>[Question] Why `gamma * beta` stand for ` L2 in  LogisticRegression._NLL_grad</summary>
	<description>
Hello,  this is a great project , I am learning how to implement model without sklearn/tensorflow , it really help me a lot .
I have a question on



numpy-ml/numpy_ml/linear_models/lm.py


         Line 252
      in
      4f37707






 d_penalty = gamma * beta if p == "l2" else gamma * l1norm(beta) * np.sign(beta) 





Since P-norm is defined as
&lt;denchmark-link:https://user-images.githubusercontent.com/3938751/87290451-9957ed80-c530-11ea-98ae-0de91eed40ac.png&gt;&lt;/denchmark-link&gt;

l1norms(self.beta) means the sum of all absulote value of each element in self.beta .  I don't quite understand why the simple  gamma * beta stand for `L2  ?
PS: May I ask what IDE and code document plugin you are using ? I see some annotation don't beyond to latex ,  it would be nice to see beautiful math symbols than raw latex :)
	</description>
	<comments>
		<comment id='1' author='eromoe' date='2020-07-17T22:09:01Z'>
		For linear regression, the l2-regularization term is gamma * np.sqrt(beta @ beta)
The gradient of l2 penalty wrt beta is then simply gamma * beta
Keep in mind that d_penality is the gradient of the penalty term wrt the coefficients, not the penalty itself :)
I don't use a special IDE, unfortunately. the equations are formatted for display as Sphinx &lt;denchmark-link:https://www.sphinx-doc.org/en/master/usage/restructuredtext/index.html&gt;reStructuredText&lt;/denchmark-link&gt;
. You can see the rendered equations in the online &lt;denchmark-link:https://numpy-ml.readthedocs.io/en/latest/&gt;documentation&lt;/denchmark-link&gt;
, or build it yourself from the source in the  directory. There may also be IDE plugins that will try to render them, but I am not aware of any :)
		</comment>
		<comment id='2' author='eromoe' date='2020-07-18T02:31:50Z'>
		&lt;denchmark-link:https://github.com/ddbourgin&gt;@ddbourgin&lt;/denchmark-link&gt;
 Thank you for  reply .
From &lt;denchmark-link:https://towardsdatascience.com/intuitions-on-l1-and-l2-regularisation-235f2db4c261&gt;https://towardsdatascience.com/intuitions-on-l1-and-l2-regularisation-235f2db4c261&lt;/denchmark-link&gt;

&lt;denchmark-link:https://user-images.githubusercontent.com/3938751/87842748-68393d80-c8e1-11ea-94fb-af4ebfde9faa.png&gt;&lt;/denchmark-link&gt;

l1-regularization term is gamma * np.absolute(beta)
l2-regularization term is gamma * np.power(np.sqrt(beta @ beta), 2)  (I think you miswrote in previous comment )
The gradient of l1 penalty wrt beta is then gamma  * np.sign(beta)
The gradient of l2 penalty wrt beta is then gamma * 2beta  proportional to gamma * beta .
Actually  I thought  l2-regularization term was gamma * np.sqrt(beta @ beta)  , so the gradient of l2 term is +- 1 too .Because sometimes I thought L2 norm was beta^2 , sometimes it was np.sqrt(beta^2) in my brain  ,  l2 norm and  l2-regularization term` are so likely and mess up ,  now I have figure  it clear .
But there is a left problem : why you multiply l1norm(beta) in L1 case ?  since the gradient of l1 penalty is gamma * np.sign(beta) , this confused me .
		</comment>
		<comment id='3' author='eromoe' date='2020-07-25T03:42:01Z'>
		Whoops, yup, that's what I get for being hasty! The regularization penalty is &lt;denchmark-link:https://github.com/ddbourgin/numpy-ml/blob/4f37707c6c7c390645dec5a503c12a48e624b249/numpy_ml/linear_models/lm.py#L244&gt;(gamma / 2) * np.sqrt(beta @ beta) ** 2&lt;/denchmark-link&gt;
, which gives a gradient of .
In the L1 case, I'd recommend explicitly writing down the L1 penalty (not just the l1 norm) and then trying to derive the gradient wrt beta. It should quickly become clear why there is an l1norm term in the calc :)
		</comment>
		<comment id='4' author='eromoe' date='2020-07-27T07:28:12Z'>
		&lt;denchmark-link:https://github.com/ddbourgin&gt;@ddbourgin&lt;/denchmark-link&gt;
 Sorry but I don't quite understand why penalty in L1 case need square as L2 does
&lt;denchmark-code&gt;penalty = 0.5 * self.gamma * np.linalg.norm(self.beta, ord=order) ** 2   #  remaid square under l1 case
&lt;/denchmark-code&gt;

All ariticles I saw was using a L1 term (penalty) like
&lt;denchmark-link:https://user-images.githubusercontent.com/3938751/88514973-8871a680-d01d-11ea-81c8-bd3128468f9d.png&gt;&lt;/denchmark-link&gt;

And the derivative is +-\lambda  .
Now I am very confusing .
		</comment>
		<comment id='5' author='eromoe' date='2020-07-27T15:38:15Z'>
		Oh! I see what you're saying. You're right, the square of the L1 norm is not what we want. The proper L1 penalty is
gamma * np.abs(beta).sum()
which gives a gradient of
gamma * np.sign(beta)
I'll make a PR to fix this. Thank you very much for pointing this out :)
		</comment>
	</comments>
</bug>