<bug id='10' author='AndreiBarsan' open_date='2017-06-25T12:05:20Z' closed_time='2017-07-02T12:51:07Z'>
	<summary>Fix depth filtering when using depth maps from dispnet</summary>
	<description>
This issue does not occur when using ELAS, just dispnet; the filterDepth_device kernel fails (but without crashing the rest of the program) at the line tmpz = imageData_in[(x + j) + (y + i) * imgDims.x];
This may also be the root cause of the "floating" artifacts produced when using dispnet depth but not elas depth. Solving this would allow me to turn down the min depth back to 0.5 or so, yay!
Once again, cuda-memcheck is the real MVP.
	</description>
	<comments>
		<comment id='1' author='AndreiBarsan' date='2017-07-02T12:51:07Z'>
		Yep, turns out the ITM code had an off-by-one error which was masked by the fact that they were using VGA input, whose dimensions were a multiple of 16, the block size used for the bilateral filtering.
Once you plugged in arbitrary values for the depth size, reads would start to happen from outside the array
bounds, leading to undefined behavior, and, therefore occasional artifacts. This has been fixed in commit &lt;denchmark-link:https://github.com/AndreiBarsan/InfiniTAM/commit/9211e4f491ea321159a32ad76aa67cd482d18b80&gt;AndreiBarsan/InfiniTAM@9211e4f&lt;/denchmark-link&gt;
.
Cuda-memcheck was VERY helpful!
		</comment>
	</comments>
</bug>