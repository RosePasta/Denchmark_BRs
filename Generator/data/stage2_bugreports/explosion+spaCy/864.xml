<bug id='864' author='knub' open_date='2017-02-27T14:47:00Z' closed_time='2017-10-16T15:54:01Z'>
	<summary>Matcher with operators not working as expected</summary>
	<description>
The following code does not behave as I would expect:
&lt;denchmark-code&gt;import spacy
import spacy.attrs as spacy_attrs
from spacy.matcher import Matcher

nlp = spacy.load("de")
doc = nlp(u"a b b c d")
matcher = Matcher(nlp.vocab)
matcher.add_pattern("Foo", [{spacy_attrs.ORTH: "a"},
                            {"OP": "+", spacy_attrs.IS_PUNCT: False},
                            {spacy_attrs.ORTH: "c"}])
ent, label, start, end = matcher(doc)[0]
print doc[start:end]
&lt;/denchmark-code&gt;

Expected:
a b b c
Actual:
No match found
I looked into the matching code, and the issue is that the second pattern spec never fails. Thus, the matcher always decides to ADVANCE the pattern as a partial and never gets to ACCEPT'ing it, even though the third spec should have already been matched.
It works, if the string is a b b . d and the token spec's final character is ., because the second pattern spec fails on the period, advances to the third, and then finds a match.
If I leave out the spacy_attrs.IS_PUNCT: False part, the matcher returns only a, as the second pattern spec is empty.
I feel this needs a bigger refactoring or do you see some way to integrate this into the current code?
Also not sure, if this is a bug or a feature request. I guess this depends on the scope of the matching/how powerful it should get?
Hoping for your thoughts here.
Environment

Python Version Used: 2.7
spaCy Version Used: 1.6

	</description>
	<comments>
		<comment id='1' author='knub' date='2017-03-11T23:35:09Z'>
		I wrote some notes on this in &lt;denchmark-link:https://github.com/explosion/spaCy/issues/850&gt;#850&lt;/denchmark-link&gt;
 , which is about the same problem. I'll keep this one open because the title is better. I think your analysis is correct.
		</comment>
		<comment id='2' author='knub' date='2017-03-11T23:36:24Z'>
		
Difficult case to handle with the current code.


The code currently works like this:


Start with a list of potential patterns, an empty queue of open patterns, and an empty list of matches.
For each token:
1.1 For each open pattern,
1.1.1 Choose an action, apply it.
1.2 Check each potential pattern. Add matches to the open patterns.


Currently the * operator triggers the REPEAT action, which keeps the pattern in the queue, at the same position. This way, we'll check the same again on the next token in the document. This is wrong: we need to keep it on the queue, but we also need to open another option. None of the other actions cause this to happen, and I didn't think of this case ahead of time.


There are a few fixes that could be applied here, and in the short term none of them seem terribly complicated. But I'm hesitating a bit, because it feels like we're in a hole here, and it might not be smart to keep digging. It might be better to redesign this, instead of programming our way out of the immediate problem.

		</comment>
		<comment id='3' author='knub' date='2017-04-18T00:24:27Z'>
		Wouldn't this be solved by negation if we could use ! and + simultaneously?
matcher.add_pattern("Foo", [{spacy_attrs.ORTH: "a"}, {"OP": '!+', spacy_attrs.ORTH: "c"}, {spacy_attrs.ORTH: "c"}])])
		</comment>
		<comment id='4' author='knub' date='2017-08-16T14:38:44Z'>
		I'm ran into this issue myself the other day. The OP functionality is not very useful when working this way.
I think the only way forward is to implement a proper Thompson NFA or Backtracking algorithm?
		</comment>
		<comment id='5' author='knub' date='2017-10-09T07:20:01Z'>
		&lt;denchmark-link:https://github.com/mollerhoj&gt;@mollerhoj&lt;/denchmark-link&gt;
 I think a Thomspon NFA is the way to go. I doubt my hacky mess here is more efficient anyway.
In the meantime, I've applied a minimal bandaid solution, that lets the major case work. The solution is, when we would return the action REPEAT, we first check what the next action would be if we advanced to the next group of token attributes. If advancing would return REJECT, we repeat --- but if advancing matches, we advance.
This leads to pretty messy semantics for the + operator. If the operator is applied to the last piece of a pattern, we get greedy matching --- there's no next piece to advance to. However, if the operator is applied within a pattern, the matching is *non-*greedy.
One stance on this is that the semantics are supposed to be greedy, and the non-greedy matching is a bug. Here's an example of the kind of case we'd be getting wrong:
&lt;denchmark-code&gt;pattern = [{'ORTH': 'a'}, {'IS_ASCII': True, "OP": "+"}, {"IS_ALPHA": True, "OP": "+"}]
text = "a b c 1 d"
&lt;/denchmark-code&gt;

The matcher would consume the first pattern-piece, ORTH:'a', and then match IS_ASCII:1 on "b". Instead of continuing on IS_ASCII, the non-greedy behaviour would kick in, and it'd switch over to the IS_ALPHA:1 pattern-piece. We'll then hit a dead-end, and fail to find the match we could've had if we had stayed with IS_ASCII up to 1, and let IS_ALPHA match the last "d".
This case seems difficult to handle correctly without a proper NFA or backtracking algorithm. Instead I hope we can make the limitations more explicit, perhaps by introducing another operator, *, for non-greedy matching. We would then state a restriction that you can't use a greedy operator before another variable-length operator -- you have to use the non-greedy one. This way we can describe the limitations pretty neatly in the docs, and raise an error when an pattern is written that we won't be able to handle correctly.
		</comment>
		<comment id='6' author='knub' date='2017-10-16T15:54:00Z'>
		Merged! ðŸŽ‰
		</comment>
		<comment id='7' author='knub' date='2018-05-08T15:27:17Z'>
		This thread has been automatically locked since there has not been any recent activity after it was closed. Please open a new issue for related bugs.
		</comment>
	</comments>
</bug>