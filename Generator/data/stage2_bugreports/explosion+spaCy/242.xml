<bug id='242' author='savkov' open_date='2016-01-29T17:23:00Z' closed_time='2016-10-23T12:03:22Z'>
	<summary>Overlapping multi-word phrases break text representation</summary>
	<description>
When two bigrams from the gazetteer overlap in the text, the text representation of the first one is broken. Consider the following code:
import spacy.en
import spacy.matcher
from spacy.attrs import ORTH, TAG, LOWER, IS_ALPHA, FLAG63

patterns = [
    [{LOWER: 'food'}, {LOWER: 'safety'}],
    [{LOWER: 'safety'}, {LOWER: 'standards'}],
]

nlp = spacy.en.English(tagger=False, parser=False, load_vectors=False)

nlp.matcher.add('FOOD', 'FOOD', {}, patterns)

docs = nlp('There are different food safety standards in different countries.')

for e in docs.ents:
    print(e.text, e.label_)
Output:
&lt;denchmark-code&gt;&gt;&gt;&gt; food FOOD
&gt;&gt;&gt; safety standards FOOD
&lt;/denchmark-code&gt;

	</description>
	<comments>
		<comment id='1' author='savkov' date='2016-01-29T19:57:05Z'>
		Thanks! I'll take a look at this next week.
		</comment>
		<comment id='2' author='savkov' date='2016-04-17T13:40:49Z'>
		Sorry for leaving this to sit for so long.
There's really a deeper design problem here that I should've seen sooner. The code is all doing the right thing.
The problem is that the Matcher class automatically sets named entity annotations, but the named entity annotations don't allow overlapping entities. The lack of overlapping entities is not ideal, but it's a standard limitation, and not so problematic. But the Matcher class is useful for lots of other situations --- it's a generic way to recognise contiguous sequences of tokens.
I think the Matcher class shouldn't set entity annotations. It should just return Span objects.
		</comment>
		<comment id='3' author='savkov' date='2016-04-18T10:08:58Z'>
		I agree. In fact, I am using it at the moment for a few separate groups of annotations, which have to be loaded in separate objects because of the overlap. It would be nice to make the overlap optional though because picking the longest match is sometimes desirable. Thoughts?
		</comment>
		<comment id='4' author='savkov' date='2016-10-23T12:03:22Z'>
		This is finally fixed in 1.0 â€” the matcher returns a sequence of (ent_id, label_id, start, end) tuples, and you can associate an on_match and/or acceptor callback with each entity ID. The on_match callback is only called after all matches are collected. The callback takes 4 arguments: the matcher, the doc, the index of the match to handle, and the list of matches. This allows the user to resolve the matches considering the total set of matches.
		</comment>
		<comment id='5' author='savkov' date='2018-05-09T08:11:51Z'>
		This thread has been automatically locked since there has not been any recent activity after it was closed. Please open a new issue for related bugs.
		</comment>
	</comments>
</bug>