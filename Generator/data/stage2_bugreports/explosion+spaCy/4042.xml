<bug id='4042' author='psychosis448' open_date='2019-07-29T17:57:52Z' closed_time='2019-09-27T18:57:14Z'>
	<summary>Adding EntityRuler before ner and saving model to disk crashes loading the model</summary>
	<description>
&lt;denchmark-h:h2&gt;How to reproduce the behaviour&lt;/denchmark-h&gt;

I got a strange problem when loading a modified model, adding an EnityRuler to the pipeline with the before='ner' flag.
So I create my patterns, add them to my entity_ruler and the ruler to my pipe:
nlp = spacy.load('de_core_news_sm')
ruler = EntityRuler(nlp)
ruler.add_patterns(patterns)
nlp.add_pipe(ruler, before='ner')
Then I check for the dir, create it if necessary and save the model to disk:
output_dir = Path('custom_model')
if not output_dir.exists():
  output_dir.mkdir()
nlp.to_disk(output_dir)
When I now load the model with
&lt;denchmark-code&gt;spacy.load(Path('custom_model'))
&lt;/denchmark-code&gt;

It throws the following error:
ValueError: [E109] Model for component 'ner' not initialized.
Did you forget to load a model, or forget to call begin_training()?
There is no problem doing this without before='ner'...
Extended Error:
Traceback (most recent call last):
  File "/spacy/__init__.py", line 27, in load
    return util.load_model(name, **overrides)
  File "/spacy/util.py", line 135, in load_model
    return load_model_from_path(name, **overrides)
  File "/spacy/util.py", line 173, in load_model_from_path
    return nlp.from_disk(model_path)
  File "/spacy/language.py", line 791, in from_disk
    util.from_disk(path, deserializers, exclude)
  File "/spacy/util.py", line 630, in from_disk
    reader(path / key)
  File "/spacy/language.py", line 787, in &lt;lambda&gt;
    deserializers[name] = lambda p, proc=proc: proc.from_disk(p, exclude=["vocab"])
  File "/spacy/pipeline/entityruler.py", line 183, in from_disk
    self.add_patterns(patterns)
  File "/spacy/pipeline/entityruler.py", line 138, in add_patterns
    self.phrase_patterns[label].append(self.nlp(pattern))
  File "/spacy/language.py", line 390, in __call__
    doc = proc(doc, **component_cfg.get(name, {}))
  File "nn_parser.pyx", line 205, in spacy.syntax.nn_parser.Parser.__call__
  File "nn_parser.pyx", line 238, in spacy.syntax.nn_parser.Parser.predict
  File "nn_parser.pyx", line 235, in spacy.syntax.nn_parser.Parser.require_model
ValueError: [E109] Model for component 'ner' not initialized.
Did you forget to load a model, or forget to call begin_training()?
&lt;denchmark-h:h2&gt;Your Environment&lt;/denchmark-h&gt;


spaCy version: 2.1.6
Platform: Darwin-18.6.0-x86_64-i386-64bit
Python version: 3.7.3

	</description>
	<comments>
		<comment id='1' author='psychosis448' date='2019-07-29T18:05:51Z'>
		Thanks for opening the issue  Copying over my suspected explanation from &lt;denchmark-link:https://stackoverflow.com/questions/57099240/adding-entityruler-before-ner-and-saving-model-to-disk-crashes-loading-the-model?noredirect=1#comment100963749_57099240&gt;Stack Overflow&lt;/denchmark-link&gt;
:

This looks like it might be a bug: when your entity ruler is loaded back and the patterns are put together spaCy uses the existing nlp object to recreate the phrase patterns. That nlp object contains the still uninitialized ner component (because that's only initialized in the next step, after the entity ruler).

		</comment>
		<comment id='2' author='psychosis448' date='2019-08-02T15:07:27Z'>
		&lt;denchmark-link:https://github.com/ines&gt;@ines&lt;/denchmark-link&gt;
 : I tried addressing this by moving some functionality from  to , so that each component would be created, added and deserialized one by one. Cf. PR &lt;denchmark-link:https://github.com/explosion/spaCy/pull/4072&gt;#4072&lt;/denchmark-link&gt;

It's still a little ugly, but unfortunately also not working. Weirdly enough, now it doesn't crash (anymore) on deserializing the EntityRuler, but it does crash when trying to deserialize the ner's model, with a thinc complaint about array dimensions:

test_issue4042.py:38:

...._init_.py:27: in load
return util.load_model(name, **overrides)
....\util.py:138: in load_model
return load_model_from_path(name, **overrides)
....\util.py:171: in load_model_from_path
pipeline=meta.get("pipeline", []),
....\language.py:847: in from_disk
util.from_disk(path, proc_deserializers, exclude=exclude)
....\util.py:629: in from_disk
reader(path / key)
....\language.py:845: in 
p, exclude=["vocab"]
nn_parser.pyx:635: in spacy.syntax.nn_parser.Parser.from_disk
???
C:\Users\Sofie\Anaconda3\envs\coref\lib\site-packages\thinc\neural_classes\model.py:376: in from_bytes
copy_array(dest, param[b"value"])

dst = array([[-0., -0.,  0.,  0., -0.,  0.,  0.,  0., -0.,  0.,  0.,  0.,  0.,
-0.,  0.,  0., -0., -0.,  0.,  0., -0...0.,  0., -0., -0., -0.,  0.,
-0., -0.,  0., -0., -0., -0., -0.,  0.,  0.,  0.,  0., -0.]],
dtype=float32)
src = array([[ 0., -0.,  0., -0., -0., -0.,  0., -0.,  0.,  0., -0.,  0., -0.,
0., -0., -0., -0.,  0., -0., -0.,  0...0.,  0.,  0.,  0.,  0.,  0.,
0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.]],
dtype=float32)
casting = 'same_kind', where = None
def copy_array(dst, src, casting="same_kind", where=None):
if isinstance(dst, numpy.ndarray) and isinstance(src, numpy.ndarray):
dst[:] = src
ValueError: could not broadcast input array from shape (9,64) into shape (5,64)
C:\Users\Sofie\Anaconda3\envs\coref\lib\site-packages\thinc\neural\util.py:124: ValueError

Not sure I'm on the right track to fixing the original issue, but also not sure how to fix the new issue :|
If you change the unit test to nlp.add_pipe(ruler, after="ner")  it works fine both in the original code base as well as in this PR.
I'm thinking there's some complex deserialization logic that I'm still not quite grasping... if you have any pointers or ideas I'd be happy to look into this further :-)
		</comment>
		<comment id='3' author='psychosis448' date='2019-08-02T17:52:24Z'>
		&lt;denchmark-link:https://github.com/svlandeg&gt;@svlandeg&lt;/denchmark-link&gt;
 Thanks for looking into this â€“ I'll take a look!
Another potential (and probably easier) fix for this particular issue might be to just disable all pipeline components that are supposed to run after the entity ruler in the pipeline. I think the EntityRuler has access to the whole nlp object, so it could check the nlp.pipe_names and then add the phrase patterns within a with nlp.disable_pipes block. But there might still be some edge cases that I'm not considering here â€“ I'm not 100% sure ðŸ¤”
		</comment>
		<comment id='4' author='psychosis448' date='2019-08-02T21:21:45Z'>
		Could definitely do that. But then every component that ever accesses the nlp object during initialization will have to make sure to follow that procedure. I was hoping to provide a more generic fix but it does make the deserialization code a little uglier...
		</comment>
		<comment id='5' author='psychosis448' date='2019-08-03T08:50:16Z'>
		&lt;denchmark-link:https://github.com/svlandeg&gt;@svlandeg&lt;/denchmark-link&gt;
 Yeah, good point. I guess in a way, actually   within a pipeline component is sort of an antipattern. We just have to do it in the case of the entity ruler, because we can't make any assumptions about the user's pipeline and what they're doing to their s that might be relevant to create the phrase patterns.
		</comment>
		<comment id='6' author='psychosis448' date='2019-08-03T11:18:29Z'>
		Oh weird stuff &lt;denchmark-link:https://github.com/ines&gt;@ines&lt;/denchmark-link&gt;
. Now I implemented your solution which is indeed a much easier fix: PR &lt;denchmark-link:https://github.com/explosion/spaCy/pull/4075&gt;#4075&lt;/denchmark-link&gt;
. Unfortunately, the  deserialization is throwing the exact same error again, .
So, I'm thinking there were two bugs to begin with, and the first one got fixed in both PRs ... so now off to hunt the second one. Something in the EntityRuler (de)serialization is influencing the ner's (de)serialization.
		</comment>
		<comment id='7' author='psychosis448' date='2019-08-03T14:19:32Z'>
		Ok, I'm getting closer. The second bug is not really an issue with (de)serialization, but revolves around the internal states of the ner model. In the unit test that I set up, I just do:
&lt;denchmark-code&gt;ner = nlp.create_pipe("ner")
ner.add_label("SOME_LABEL")
nlp.add_pipe(ner)
&lt;/denchmark-code&gt;

and then a bit later:
&lt;denchmark-code&gt;nlp.add_pipe(ruler, before="ner")
&lt;/denchmark-code&gt;

It turns out that the EntityRuler is influencing the internal states of the BiluoPushDown TransitionSystem. More specifically, after constructing the pipeline, all is fine, and ner.moves.labels is :

{0: Counter(), 1: Counter({'SOME_LABEL': -1}), 2: Counter({'SOME_LABEL': -1}), 3: Counter({'SOME_LABEL': -1}), 4: Counter({'SOME_LABEL': -1}), 5: Counter({'': 1})}

Then when you apply ,  and the NER Parser calls , eventually this &lt;denchmark-link:https://github.com/explosion/spaCy/blob/master/spacy/syntax/ner.pyx#L237&gt;line&lt;/denchmark-link&gt;
:

self.add_action(BEGIN, st._sent[i].ent_type)

sees the entity from the entity ruler (I'm guessing), and changes its internal state self.labels to

{0: Counter(), 1: Counter({'SOME_LABEL': -1, 17374225351233417627: -2}), 2: Counter({'SOME_LABEL': -1}), 3: Counter({'SOME_LABEL': -1}), 4: Counter({'SOME_LABEL': -1}), 5: Counter({'': 1})}

The next few lines will keep adding to this field until eventually, self.labels equals

{0: Counter(), 1: Counter({'SOME_LABEL': -1, 17374225351233417627: -2}), 2: Counter({'SOME_LABEL': -1, 17374225351233417627: -2}), 3: Counter({'SOME_LABEL': -1, 17374225351233417627: -2}), 4: Counter({'SOME_LABEL': -1, 17374225351233417627: -2}), 5: Counter({'': 1})}

This will end up with the ner trying to parse out 9 classes, instead of 5, when reading its data back in from file.
I'm pretty unfamiliar with the inner workings of the  model code though, so kind of hesitant to start poking around in hope of fixing this... Any suggestions &lt;denchmark-link:https://github.com/honnibal&gt;@honnibal&lt;/denchmark-link&gt;
 or &lt;denchmark-link:https://github.com/ines&gt;@ines&lt;/denchmark-link&gt;
 ?
		</comment>
		<comment id='8' author='psychosis448' date='2019-08-05T22:09:07Z'>
		Ah this is indeed a somewhat nasty interaction.
The situation is, the NER's state machine handles preset labels by declaring that all actions that would stop that entity being assigned are invalid. The model produces scores over the actions as normal, but it will be forced to follow a move that preserves the entity. This keeps the details of this "preset entity" stuff inside the transition system, so the parser code can stay general across the dependency and NER tasks.
So before we start parsing, we have to look for any labels on the Doc objects we might be missing, and register them. If we don't do this, we'll get one of those dreaded "no valid actions" errors. We do want to support the possibility of adding new entities to a pretrained model anyway. So, the idea of extending a model with another entity doesn't seem so bad.
It sounds to me like the case we're hitting here is that we're deserialising weights that are a different size from what we expected. If we had registered the labels before deserialising that would be fine, or if we had loaded the model before registering the labels, that would be fine also. But it sounds like we're in an ordering that's not working.
		</comment>
		<comment id='9' author='psychosis448' date='2019-08-05T22:09:48Z'>
		Should we be having a look at whether it's possible to avoid the call to nlp()? Is there another way to do the serialisation so that that's not necessary?
		</comment>
		<comment id='10' author='psychosis448' date='2019-08-06T06:54:28Z'>
		I think the second bug won't be solved by avoiding the call to self.nlp() in EntityRuler.add_patterns.
Take &lt;denchmark-link:https://github.com/explosion/spaCy/pull/4072/files#diff-77c14f4ea85d677a9e11fe0b13112af6&gt;this unit test&lt;/denchmark-link&gt;
. The second bug  when I change the last bit to only serialize &amp; deserialize the  component (instead of the whole  object). To me this feels like the NER is in some inherent inconsistent state, that manifests itself only during IO.
Before IO, it's this code creating that potentially inconsistent state:
&lt;denchmark-code&gt;nlp.add_pipe(ner)
nlp.add_pipe(ruler, before="ner")
doc1 = nlp("What do you think about Apple ?")
&lt;/denchmark-code&gt;

When creating doc1, the ner sees the "Apple" entity from the EntityRuler and then changes its internal states as discussed. But then somehow when serializing the NER after that, things go wrong (independently, then, of the EntityRuler).
Could it be an obscure bug somewhere in the registering of the new labels the NER found?
In the example above: why is the NER still trying to parse out 5 labels, instead of 9, after it updated its internal state?
		</comment>
		<comment id='11' author='psychosis448' date='2019-08-06T07:12:20Z'>
		
In the example above: why is the NER still trying to parse out 5 labels, instead of 9, after it updated its internal state?

Because it updated its internal state, changed the self.labels and set self.n_moves to 9 instead of 5, but meanwhile the NER had already been initialized and trained on the original dimension of 5?
		</comment>
		<comment id='12' author='psychosis448' date='2019-09-17T06:44:34Z'>
		&lt;denchmark-link:https://github.com/psychosis448&gt;@psychosis448&lt;/denchmark-link&gt;
  Do you use Phrase Matcher for your entityrule?
I've used it and got same error. And I use token matcher for my entityrule.jsonl. It solved for me.
		</comment>
		<comment id='13' author='psychosis448' date='2019-10-27T19:44:00Z'>
		This thread has been automatically locked since there has not been any recent activity after it was closed. Please open a new issue for related bugs.
		</comment>
	</comments>
</bug>