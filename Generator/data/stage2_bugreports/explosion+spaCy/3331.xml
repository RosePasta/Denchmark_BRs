<bug id='3331' author='phdowling' open_date='2019-02-25T16:58:55Z' closed_time='2019-03-04T10:20:10Z'>
	<summary>Create multiple labels per match in PhraseMatcher</summary>
	<description>
&lt;denchmark-h:h2&gt;How to reproduce the behaviour&lt;/denchmark-h&gt;

&lt;denchmark-code&gt;from spacy.matcher import PhraseMatcher
matcher = PhraseMatcher(nlp.vocab)
matcher.add('OBAMA A', None, nlp(u"Barack Obama"))
matcher.add('OBAMA B', None, nlp(u"Barack Obama"))
doc = nlp(u"Barack Obama lifts America one last time in emotional farewell")
matches = matcher(doc)
&lt;/denchmark-code&gt;

gives only one match, but I'd expect the same surface form to be matched to both labels. Is this possible to implement using the PhraseMatcher?
Background is that I am trying to tag a certain type of entity Gazetteer-style, where different entities can have the same surface form, and all candidates should be retrieved. Are these kinds of matches necessarily unique Spans in spaCy? Is there a good/efficient workaround?
	</description>
	<comments>
		<comment id='1' author='phdowling' date='2019-02-25T21:28:22Z'>
		Thanks for the report – it's true that this currently doesn't work and I agree that it probably should. Duplicate patterns within the same rules can be ignored, but if they're added for different rule IDs, the matcher should return both matches.
In the meantime, maybe you could work around this by using two matchers? It's not the most elegant solution and doesn't scale that well, but it should prevent duplicate patterns from being ignored.
		</comment>
		<comment id='2' author='phdowling' date='2019-02-28T15:45:16Z'>
		On a similar note - is there any way around the "Entity spans are not allowed to overlap" rule? I'd like to keep all entities the NER pipe outputs, and add some of my own on top using a matcher. I can't set doc.ents directly with overlapping entities, and storing them in the doc.user_data dict has led to serialization problems down the line (I imagine because the spans hold reference to the underlying doc, so you run into sort of an infinite loop trying to traverse the object graph? if that's unexpected I can also probably just file another issue on that). Maybe there could be an option to specifically allow for overlapping entity spans?
		</comment>
		<comment id='3' author='phdowling' date='2019-03-01T18:56:56Z'>
		Each token can only be part of one entity and it can only have one entity label – this is sort of inherent to NER. When the named entity recognizer predicts entities, it assigns labels like B-PERSON, L-PERSON, O etc. to each token. Those are then used to populate the doc.ents. Similarly, if you overwrite the doc.ents, the setter will assign the respective labels to the underlying tokens. (For efficiency, this all happens at the C-level btw.) So by definition, overlapping entities cannot exist.
Previous versions of spaCy didn't raise an error in the setter, which was bad, because it silently produced inconsistent results. Tokens would just receive whichever entity label was added last, because they can only have one.
That said, I can definitely see the need for more generic "span container attribute", or making it easier to add those serializable "span containers" to the Doc. You often want to store sequences of tokens that have some kind of meaning in the context of your app and that aren't named entities per se.

I can't set doc.ents directly with overlapping entities, and storing them in the doc.user_data dict has led to serialization problems down the line
(I imagine because the spans hold reference to the underlying doc, so you run into sort of an infinite loop trying to traverse the object graph?

Yes, you can't store span objects in the user data – at least not if you also want to serialize them. However, you can store the spans as (start, end, label) tuples in the doc.user_data and then use a custom extension attribute to retrieve them as spans, just like the doc.ents. Here's an example that shows the idea (untested, but should work):
from spacy.tokens import Doc, Span

def get_custom_ents(doc):
    # This getter receives the doc object it's called on, creates spans for the custom 
    # entities stored in doc.user_data['custom_ents'] and returns them
    custom_ents = doc.user_data.get('custom_ents', [])
    return [Span(doc, start, end, label=doc.vocab.strings[label]) 
            for start, end, label in custom_ents]

# Register the extension on the Doc so it's available as doc._.custom_ents
Doc.set_extension('custom_ents', getter=get_custom_ents)
If your doc has spans like [(0, 5, 'SOME_LABEL')] in its user_data['custom_ents'], the doc._.custom_ents attribute will return a list of Span objects for those spans.
		</comment>
		<comment id='4' author='phdowling' date='2019-03-04T10:20:08Z'>
		Worked like a charm, thanks a lot!
		</comment>
		<comment id='5' author='phdowling' date='2019-04-03T10:37:58Z'>
		This thread has been automatically locked since there has not been any recent activity after it was closed. Please open a new issue for related bugs.
		</comment>
	</comments>
</bug>