<bug id='392' author='wzhAptiv' open_date='2018-05-03T09:17:09Z' closed_time='2020-03-19T21:46:38Z'>
	<summary>Incorrect unreal_transform for Lidar sensor</summary>
	<description>
After some experiments following a new comment in &lt;denchmark-link:https://github.com/carla-simulator/carla/issues/314&gt;#314&lt;/denchmark-link&gt;
 , I found the unreal_transform is incorrect for Lidar sensors.
An overridden function should be added to carla.sensor.Lidar as:
def get_unreal_transform(self): 
    to_unreal_transform = Transform(Rotation(yaw=90), Scale(z=-1))
    return self.get_transform() * to_unreal_transform
e.g. A Lidar is installed on (x=0,y=0,z=0,p=0,y=0,r=0). This will convert a Lidar data point (x,y,z) to (-y,x,-z), which should match the meaning of such data point in the car coordinate.
The issue should occur since Lidar sensor was added
	</description>
	<comments>
		<comment id='1' author='wzhAptiv' date='2018-09-24T09:11:26Z'>
		This issue has been automatically marked as stale because it has not had recent activity. It will be closed if no further activity occurs. Thank you for your contributions.
		</comment>
		<comment id='2' author='wzhAptiv' date='2020-10-20T01:06:40Z'>
		Hello,
For those who are working on 0.9.6 and are integrating several lidar sweeps into one here is some hints/advice to help you with it.
So basically the first thing is to get the transformations in the world's coordinate by  . Then  of the lidar transformation (function attached below - from issue &lt;denchmark-link:https://github.com/carla-simulator/carla/issues/594&gt;#594&lt;/denchmark-link&gt;
):
NOTE: get_unreal_transform() was not used. I believe that is only for version 0.8.4.
&lt;denchmark-code&gt;def get_matrix():
    scale_x = 1
    scale_y = 1
    scale_z = -1
    rotation = transform.rotation
    location = transform.location
    c_y = np.cos(np.radians(rotation.yaw + 90)) #-270
    s_y = np.sin(np.radians(rotation.yaw + 90)) #-270
    c_r = np.cos(np.radians(0))
    s_r = np.sin(np.radians(0))
    c_p = np.cos(np.radians(0))
    s_p = np.sin(np.radians(0))
    matrix = np.matrix(np.identity(4))
    matrix[0, 3] = location.x
    matrix[1, 3] = location.y
    matrix[2, 3] = location.z
    matrix[0, 0] = scale_x * (c_p * c_y)
    matrix[0, 1] = scale_x * (c_y * s_p * s_r - s_y * c_r)
    matrix[0, 2] = scale_x * (c_y * s_p * c_r + s_y * s_r)
    matrix[1, 0] = scale_y * (s_y * c_p)
    matrix[1, 1] = scale_y * (s_y * s_p * s_r + c_y * c_r)
    matrix[1, 2] = scale_y * (s_y * s_p * c_r - c_y * s_r)
    matrix[2, 0] = scale_z * (-s_p)
    matrix[2, 1] = scale_z * (c_p * s_r)
    matrix[2, 2] = scale_z * (c_p * c_r)
&lt;/denchmark-code&gt;

After doing the dot product, between the transformation matrix and the transpose of lidar.raw_data, you will notice (by plotting) that the axis of the point cloud is not quite right. Changing the order of the point cloud array from (x,y,z) to (y,x,-z) will do the job.
Please note that this walkaround will work only for straight roads (no slopes) as pitch and roll are not accounted for in lidar. That is why they are zeroed out in the get_matrix(). However, if someone finds a solution to that then I will be happy to know it.
Thanks. Hope this is helpful.
		</comment>
	</comments>
</bug>