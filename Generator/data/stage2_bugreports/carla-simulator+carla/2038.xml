<bug id='2038' author='jitrc' open_date='2019-08-26T08:12:32Z' closed_time='2020-06-26T03:18:27Z'>
	<summary>Synchronous_mode gets stuck in endless loop</summary>
	<description>
SynchronizeFrame sometime does not get the correct GFrame Counter
and thus keeps waiting  in world.tick()
&lt;denchmark-link:https://user-images.githubusercontent.com/660504/63675682-33d70300-c79e-11e9-9aae-0016552fb82d.png&gt;&lt;/denchmark-link&gt;

Lot of additional messages added to debug the situation, that is what is in the image.
	</description>
	<comments>
		<comment id='1' author='jitrc' date='2019-08-30T01:06:41Z'>
		This is our intermediate solution
void FCarlaEngine::OnPostTick(UWorld *, ELevelTick, float DeltaSeconds)
{
  uint32_t RunSomeCount = 0u;
  do
  {
    Server.RunSome(10u);
    // TODO: fix bug and remove
    // To solve for bug of Client not receiving new Frame and stuck forever in SyncronizeFrame
    // We are repeatedly sending same frame, only in SynchronousMode, and waiting for next tick
    // It only happens in Sync mode and faster than real-time speeds 
    // and we need to send Frames repeatedly fast enough to maintain average performance 
    RunSomeCount++;
    if (bSynchronousMode &amp;&amp; RunSomeCount % 100 == 0)
     WorldObserver.BroadcastTick(*CurrentEpisode, DeltaSeconds);
  }
  while (bSynchronousMode &amp;&amp; !Server.TickCueReceived());
}
		</comment>
		<comment id='2' author='jitrc' date='2019-08-30T03:37:15Z'>
		Seems like the culprit is session 0: connection too slow: message discarded , data streaming is dropped instead of being queued.
		</comment>
		<comment id='3' author='jitrc' date='2019-09-02T07:51:09Z'>
		
session 0: connection too slow: message discarded

I see, that causes a dead-lock between client and server, but not sure how to fix it.
Definitively not very nice the way the simulator drops messages when the connection is slow, but having a queue also has its own problems.
Nevertheless, there is always a possibility some message is lost, in that case the client ends up waiting forever. I guess the best would be adding a timeout to the image queue in Python, say if the image hasn't arrived in X seconds, skip it and go on to the next tick (and make sure you ignore images with older frame numbers in case the image eventually arrives).
		</comment>
		<comment id='4' author='jitrc' date='2019-09-03T18:27:40Z'>
		In our case we are not even using image and operating in no-rendering mode, that's how we are getting those high FPS and hitting this issue. We are only waiting for new Frame no. to be avaialbe WorldObserver.BroadcastTick(in Server) as SynchronizeFrame (in Client) waits.
static void SynchronizeFrame(uint64_t frame, const Episode &amp;episode) {
    while (frame &gt; episode.GetState()-&gt;GetTimestamp().frame) {
      std::this_thread::yield();
    }
  }
The do..while (bSynchronousMode &amp;&amp; !Server.TickCueReceived()); loop is a idle loop waiting for the next tick from the client, which will never come if the client has never received the current frame. So keeping on re-sending the current frame in the waiting loop is on the msot robust way to make sure the client gets the current frame.
Few other options would be :

a time-out in SynchronizeFrame to skip frame
Synchronous get_frame call implementation to poll from SynchronizeFrame
Detect failure in AsyncStream.Send() from WorldObserver::BroadcastTick() and retry
Queue and send messages in ServerSession::Write(), instead of dropping, Example link

We also made some other improvements in the streaming server (yet to make a PR on that)
 // Configure socket options
    log_debug("streaming client: configuring socket");
    _socket.set_option( boost::asio::ip::tcp::no_delay( true) );
    #if defined(__linux) || defined(linux) || defined(__linux__)
      boost::asio::detail::socket_option::boolean&lt;
          IPPROTO_TCP, TCP_QUICKACK&gt; quickack(true);
      _socket.set_option(quickack);
    #endif
		</comment>
		<comment id='5' author='jitrc' date='2019-09-04T03:08:44Z'>
		Fix in this branch &lt;denchmark-link:https://github.com/AuroAi/carla/tree/improve_sync_mode_performance&gt;https://github.com/AuroAi/carla/tree/improve_sync_mode_performance&lt;/denchmark-link&gt;

Here is the PR &lt;denchmark-link:https://github.com/carla-simulator/carla/pull/2070&gt;#2070&lt;/denchmark-link&gt;

Commit specific to this issue &lt;denchmark-link:https://github.com/AuroAi/carla/commit/8caa2e7c2f2c5b508946bb77d55fb50882203eb5&gt;AuroAi@8caa2e7&lt;/denchmark-link&gt;

		</comment>
		<comment id='6' author='jitrc' date='2020-03-12T04:02:44Z'>
		&lt;denchmark-link:https://github.com/nsubiron&gt;@nsubiron&lt;/denchmark-link&gt;

Hello nsubiron,
has this problem be solved?
when I run sync mode at high FPS, get stuck at ramdom, show the following warning:
RuntimeError: time-out of 10000ms while waiting for the simulator, make sure the simulator is ready and connected to localhost:2000
I am wondering how to solve the problem

if the image hasn't arrived in X seconds, skip it and go on to the next tick

The same problem as &lt;denchmark-link:https://github.com/carla-simulator/carla/issues/1994&gt;#1994&lt;/denchmark-link&gt;

		</comment>
		<comment id='7' author='jitrc' date='2020-06-16T14:02:57Z'>
		Please also note, that sync mode also has bad performance compared to async, see &lt;denchmark-link:https://github.com/carla-simulator/carla/issues/2617#issuecomment-643192087&gt;#2617 (comment)&lt;/denchmark-link&gt;
 and the following comments.
		</comment>
		<comment id='8' author='jitrc' date='2020-06-26T03:18:27Z'>
		&lt;denchmark-link:https://github.com/hh0rva1h&gt;@hh0rva1h&lt;/denchmark-link&gt;
 I believe this is not the right place for that comment. Please, let's not mix issues.
		</comment>
	</comments>
</bug>