<bug id='91' author='azyslzp' open_date='2020-09-17T05:20:03Z' closed_time='2020-09-20T22:51:33Z'>
	<summary>problem about predict</summary>
	<description>
due to lack of predict examples,  I am unable to use the model.predict correctly, there also exists a bug as:
RuntimeError: Expected 4-dimensional input for 4-dimensional weight [256, 1, 1, 3], but got 3-dimensional input of size [31, 2, 132] instead
I used :output=model.predict_on_batch(Singledata)
and my Singledata is a array of size (31,2,128), float type
	</description>
	<comments>
		<comment id='1' author='azyslzp' date='2020-09-17T12:39:50Z'>
		Hi, thank you for your question. Is it possible to get the whole stack trace of the error? Otherwise, it should work the way you're using the function.
Thank you.
		</comment>
		<comment id='2' author='azyslzp' date='2020-09-17T13:22:13Z'>
		
Hi, thank you for your question. Is it possible to get the whole stack trace of the error? Otherwise, it should work the way you're using the function.
Thank you.


Hi, thank you for your question. Is it possible to get the whole stack trace of the error? Otherwise, it should work the way you're using the function.
Thank you.

Hi, thanks for your reply. I have used:
idx=109000
Singledata=sX[idx-1:idx]# sX is a array of size (120000, 2, 128) , which contains 120000 samples of I and Q signal data
Singledata=torch.cuda.FloatTensor(Singledata).unsqueeze(0)
output=model.predict(Singledata)
to solve the predict problem,
but it seems that this way only worked on single sample, when I use
predict_batch or predict_generator,
I still met the dimension problem
and I loaded the model by
checkname=os.path.join(checkdir+"/checkpoint.optim")
model.load_optimizer_state(checkname)#get the checkpoint model to predict
		</comment>
		<comment id='3' author='azyslzp' date='2020-09-17T14:27:20Z'>
		Is it possible to have the code of your network? Also, to load your checkpoint, you should use the load_weights method, not the load_optimizer_state. load_optimizer_state is used to load back the optimizer state for further training. It does not load the weights of the network.
		</comment>
		<comment id='4' author='azyslzp' date='2020-09-17T17:57:22Z'>
		
Is it possible to have the code of your network? Also, to load your checkpoint, you should use the load_weights method, not the load_optimizer_state. load_optimizer_state is used to load back the optimizer state for further training. It does not load the weights of the network.

Sure, I have uploaded my code at &lt;denchmark-link:https://github.com/azyslzp/LZP-Signal-recognition&gt;https://github.com/azyslzp/LZP-Signal-recognition&lt;/denchmark-link&gt;

and the predict problem existed in the test.py.
In train.py, I have demo it and i t could output a pth file which is created by .
In test.py, I reload the model file , but it is unable to complete the prediction, and
thanks for your advice~


		</comment>
		<comment id='5' author='azyslzp' date='2020-09-17T18:20:05Z'>
		Hi,
In your Dataset  method, you also do an &lt;denchmark-link:https://github.com/azyslzp/LZP-Signal-recognition/blob/9e691368c0a7b680ba30722efcc0cbdb1bd01a4b/torch_modulation_recognition/data.py#L72&gt;.unsqueeze(0)&lt;/denchmark-link&gt;
. So, my guess would be that you can do an  so that your examples have the same shape as in training. Also, I think your error stems from the fact that &lt;denchmark-link:https://pytorch.org/docs/stable/generated/torch.nn.Conv2d.html#torch.nn.Conv2d&gt;nn.Conv2d&lt;/denchmark-link&gt;
 takes in a 4d tensor and your Singledata tensor is only a 3d tensor. Let me know if that helps you.
Thank you.
		</comment>
		<comment id='6' author='azyslzp' date='2020-09-18T02:19:21Z'>
		
Hi,
In your Dataset __getitem__ method, you also do an .unsqueeze(0). So, my guess would be that you can do an .unsqueeze(1) so that your examples have the same shape as in training. Also, I think your error stems from the fact that nn.Conv2d takes in a 4d tensor and your Singledata tensor is only a 3d tensor. Let me know if that helps you.
Thank you.

Hi,
I have tried to modify my code by .unsqueeze(1), but it still unable to work, which also brings the training problem. I also have a key issue:
If I use ModelCheckpoint to save the model weight, should I use
&lt;denchmark-code&gt;model = Model(
    network=net,
    optimizer="Adam",
    loss_function=nn.CrossEntropyLoss(),
    batch_metrics=metrics
)
checkname=os.path.join(MODEL_DIR+'/'+args.model+'.pth')
out1=model.load_weights(checkname)
&lt;/denchmark-code&gt;

to load? But it seems not work for out1.predict(s1) by
AttributeError: 'NoneType' object has no attribute 'predict'
Thanks
		</comment>
		<comment id='7' author='azyslzp' date='2020-09-18T03:19:16Z'>
		Hi, load_weights does not return anything, it modifies the model in-place. Also, could you print the shape of your input tensor in the forward during train and during test? Maybe, we could see the difference.
		</comment>
		<comment id='8' author='azyslzp' date='2020-09-18T03:35:31Z'>
		Hi, I have checked the ModelCheckpoint source, it seem only use the model.save_weights. For verification, I add the predict in the end of training directly:
&lt;denchmark-code&gt;    model.fit_generator(
        train_dataloader,
        val_dataloader,
        epochs=EPOCHS,
        initial_epoch=1,
        callbacks=callbacks
    )
    checkname=os.path.join(MODEL_DIR+'/'+args.model+'1.pth')
    model.save_weights(checkname)
    model.load_weights(checkname)
    output=model.predict(s1)
&lt;/denchmark-code&gt;

And I found it works in vtcnn model, but not in mrresnet model. So I think the problem may came from the model structure.
As for the tensor shape, it is
&lt;denchmark-code&gt;    for i, (x, y) in enumerate(train_dataloader):
        x2=x
        y2=y
        print(x2)
x2.shape
Out[61]: torch.Size([192, 1, 2, 128])
s1.shape
Out[64]: torch.Size([1, 1, 2, 128])
&lt;/denchmark-code&gt;

		</comment>
		<comment id='9' author='azyslzp' date='2020-09-18T13:58:42Z'>
		Hi, it seems that you are using Conv1d instead of Conv2d in MRResNet. Conv1d takes in 3d tensors. You also do x = x.squeeze() at the beginning of your forward which removes all dimensions of size 1 which in the case of s1 gives you a 2d tensor of shape [2, 128].
		</comment>
		<comment id='10' author='azyslzp' date='2020-09-20T02:35:01Z'>
		Hi, I have solved this problem by input 192 samples a time for prediction( although it is not a good idea)
		</comment>
		<comment id='11' author='azyslzp' date='2020-09-20T22:51:33Z'>
		Alright, I will close the issue. However, I will advise you to really look the shapes of your tensors everywhere in your networks (from input to output and in the middle) to make sure that the shapes you get are what you expect them to be. Let me know if you have any question related to Poutyne.
		</comment>
	</comments>
</bug>