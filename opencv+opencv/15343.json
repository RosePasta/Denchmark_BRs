{"BR": {"BR_id": "15343", "BR_author": "Zyrin", "BRopenT": "2019-08-20T07:30:05Z", "BRcloseT": "2019-08-23T19:01:03Z", "BR_text": {"BRsummary": "Stack overflow when converting a typed Mat_ to another typed Mat_ on gcc &gt;= 7.1 with c++17 enabled", "BRdescription": "\n <denchmark-h:h5>System information (version)</denchmark-h>\n \n \n OpenCV => at least 3.1 but also 4.1.1\n Operating System / Platform => Linux\n Compiler =>        >= gcc 7.1\n \n <denchmark-h:h5>Detailed description</denchmark-h>\n \n When converting typed cv::Mat_<...> from one type to another with gcc >= 7.1 with c++17 enabled an endless recursion is generated leading to a stack overflow, thus the software is terminated with a segfault. In c++14 mode this issue does not occure.\n I created a summary version of the Mat classes in godbolt where you can see the issue directly in assembly: <denchmark-link:https://gcc.godbolt.org/z/f8vFZj>https://gcc.godbolt.org/z/f8vFZj</denchmark-link>\n \n <denchmark-h:h5>Steps to reproduce</denchmark-h>\n \n Compile this short example with c++ 17 enabled:\n <denchmark-code>#include \"opencv2/core.hpp\"\n int main()\n {\n   cv::Mat_<unsigned char> m1;\n   cv::Mat_<signed char> m2{m1};\n   return 0;\n }\n </denchmark-code>\n \n Or see the example on godbolt above.\n \t"}, "comments": {"comments_0": {"comment_id": 1, "comment_author": "Zyrin", "commentT": "2019-08-20T14:46:53Z", "comment_text": "\n \t\tThis trick helps in provided reproducer:\n -template<typename T2> operator Mat_<T2>() const { return Mat_<T2>(*this); }\n +template<typename T2> operator Mat_<T2>() const { return Mat_<T2>((Mat&)*this); }\n Could you check this on your machine?\n \t\t"}, "comments_1": {"comment_id": 2, "comment_author": "Zyrin", "commentT": "2019-08-20T18:21:37Z", "comment_text": "\n \t\tI already tried the following:\n -template<typename T2> operator Mat_<T2>() const { return Mat_<T2>(*this); }\n +template<typename T2> operator Mat_<T2>() const { return Mat_<T2>(Mat(*this)); }\n That seemed to work, but I am still testing. Your sollution is probably better, since it does not call an aditional constructor. I will test it tomorrow.\n \t\t"}, "comments_2": {"comment_id": 3, "comment_author": "Zyrin", "commentT": "2019-08-21T07:19:00Z", "comment_text": "\n \t\tThat seems to work in first tests.\n On another note. While looking through mat.inl.hpp I saw that the move constructors/operators of Mat_ call the copy constructory of Mat. Is there a reason for that?\n \t\t"}, "comments_3": {"comment_id": 4, "comment_author": "Zyrin", "commentT": "2019-08-21T07:47:47Z", "comment_text": "\n \t\tThank you for checks!\n \n call the copy constructory of Mat\n \n Related code is <denchmark-link:https://github.com/opencv/opencv/blame/3.4.7/modules/core/include/opencv2/core/mat.inl.hpp#L2106>here</denchmark-link>\n \n I believe this should be fixed.\n Perhaps we can try to use std::forward there (with casting to base Mat type rvalue).\n In general, it is not safe to move objects via base types, but here this should work (no extra fields).\n Could you prepare patch with changes onto 3.4 branch? (3.4 is current maintenance branch, we will merge changes into master later through regular process)\n \t\t"}, "comments_4": {"comment_id": 5, "comment_author": "Zyrin", "commentT": "2019-08-21T08:44:18Z", "comment_text": "\n \t\tOk, I will prepare a patch.\n std::forward would be conceptionally incorrect, though. I will test with std::move.\n \t\t"}}}, "commit": {"commit_id": "8ef80886866a36d257566b8185b071414bd68501", "commit_author": "Zyrin", "commitT": "2019-08-21 10:57:03+02:00", "changed_files": {"file_0": {"file_change_type": "MODIFY", "file_Nmethod": 1, "file_old_name": "modules\\core\\include\\opencv2\\core\\mat.inl.hpp", "file_new_name": "modules\\core\\include\\opencv2\\core\\mat.inl.hpp", "hunks": {"hunk_0": {"Ismethod": 1, "added_lines": "1812", "deleted_lines": "1812", "method_info": {"method_name": "cv::Mat_<_Tp>::operator Mat_ < T2 >", "method_params": "", "method_startline": "1810", "method_endline": "1813"}}}}}}}