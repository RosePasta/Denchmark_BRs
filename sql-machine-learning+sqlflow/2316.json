{"BR": {"BR_id": "2316", "BR_author": "weiguoz", "BRopenT": "2020-05-20T07:45:43Z", "BRcloseT": "2020-05-22T09:39:56Z", "BR_text": {"BRsummary": "Shall we find a way to specify the external parser", "BRdescription": "\n \n SQLFlow determines the external parser by  which specified in DataSource string. e.g. <denchmark-link:https://github.com/sql-machine-learning/sqlflow/blob/436d4559577ea3f2214f9cf3b8ffd255f399d788/doc/run_with_maxcompute.md#connect-existing-maxcompute-server>maxcompute Datasource string</denchmark-link>\n \n For dialect maxcompute, we run the unit test well with calcite parser. However, in some company environments, it's more accurate to use the odps parser because of the Non-Open sourced syntax file.\n \n \n \n sqlflow/pkg/parser/external/parser.go\n \n \n         Lines 32 to 46\n       in\n       436d455\n \n \n \n \n \n \n  // NewParser instantiates a parser. \n \n \n \n  func NewParser(dialect string) (Parser, error) { \n \n \n \n  switch dialect { \n \n \n \n  case \"mysql\", \"tidb\": \n \n \n \n  return newTiDBParser(), nil \n \n \n \n  case \"hive\": \n \n \n \n  return newJavaParser(\"hive\"), nil \n \n \n \n  case \"calcite\", \"maxcompute\": \n \n \n \n  return newJavaParser(\"calcite\"), nil \n \n \n \n  case \"alisa\": \n \n \n \n  return newJavaParser(\"odps\"), nil \n \n \n \n  default: \n \n \n \n  return nil, fmt.Errorf(\"unrecognized dialect %s\", dialect) \n \n \n \n  \t} \n \n \n \n  } \n \n \n \n \n \n Describe the solution you'd like\n It looks like we should find a way to specify the external parser.\n \t"}, "comments": {"comments_0": {"comment_id": 1, "comment_author": "weiguoz", "commentT": "2020-05-20T15:38:41Z", "comment_text": "\n \t\tHow about this? It seems only maxcompute has the issue.\n \tcase \"mysql\", \"tidb\":\n  \t\treturn newTiDBParser(), nil\n  \tcase \"hive\":\n  \t\treturn newJavaParser(\"hive\"), nil\n  \tcase \"calcite\":\n  \t\treturn newJavaParser(\"calcite\"), nil\n \tcase \"maxcompute\":\n \t\tif parser := newJavaParser(\"odps\"); parser != nil {\n \t\t\treturn parser, nil\n \t\t}\n \t\treturn newJavaParser(\"maxcompute\"), nil\n  \tcase \"alisa\":\n  \t\treturn newJavaParser(\"odps\"), nil\n \t\t"}, "comments_1": {"comment_id": 2, "comment_author": "weiguoz", "commentT": "2020-05-21T08:57:31Z", "comment_text": "\n \t\tHi <denchmark-link:https://github.com/shendiaomo>@shendiaomo</denchmark-link>\n , thanks for your suggestion.\n To test if  is , we need to try to call the Parser firstly.\n Let me do some tests.\n \t\t"}, "comments_2": {"comment_id": 3, "comment_author": "weiguoz", "commentT": "2020-05-21T23:24:24Z", "comment_text": "\n \t\t\n To test if newJavaParser(\"odps\") is nil, we need to try to call the Parser firstly.\n \n Maybe we can wrap a new Parser which is something like:\n type ComposedParser struct {\n     parsers []Parser\n } \n \n func (parser *ComposedParser) Parse(stmt string) {\n     for _, p := range parsers {\n         ret, err := p.Parse(stmt)\n         if err == nil {\n             return ret\n         }\n     }\n     return fmt.Errorf(\"...\")\n }\n \t\t"}, "comments_3": {"comment_id": 4, "comment_author": "weiguoz", "commentT": "2020-05-22T02:10:12Z", "comment_text": "\n \t\tIf we can't use odps parser, why should we add a maxcompute unit test run? Sorry, I'm not clear about the historical context.\n \t\t"}, "comments_4": {"comment_id": 5, "comment_author": "weiguoz", "commentT": "2020-05-22T07:13:04Z", "comment_text": "\n \t\t\n \n To test if newJavaParser(\"odps\") is nil, we need to try to call the Parser firstly.\n \n Maybe we can wrap a new Parser which is something like:\n type ComposedParser struct {\n     parsers []Parser\n } \n \n func (parser *ComposedParser) Parse(stmt string) {\n     for _, p := range parsers {\n         ret, err := p.Parse(stmt)\n         if err == nil {\n             return ret\n         }\n     }\n     return fmt.Errorf(\"...\")\n }\n \n This approach, each stmt calls multi parsers. I would like to use a fixed parser currently.\n \t\t"}}}, "commit": {"commit_id": "19c365b0f2113cb4114b8f9b102d7b559b7ac347", "commit_author": "HongwuLin", "commitT": "2020-05-22 17:39:55+08:00", "changed_files": {"file_0": {"file_change_type": "MODIFY", "file_Nmethod": 3, "file_old_name": "java\\parser\\src\\main\\java\\org\\sqlflow\\parser\\ParserFactory.java", "file_new_name": "java\\parser\\src\\main\\java\\org\\sqlflow\\parser\\ParserFactory.java", "hunks": {"hunk_0": {"Ismethod": 1, "added_lines": "63,64,65,66,67,68,69,70", "deleted_lines": null, "method_info": {"method_name": "ParserFactory::getAlternativeParsers", "method_params": "alts", "method_startline": "63", "method_endline": "70"}}, "hunk_1": {"Ismethod": 1, "added_lines": "73,74,75,76,77,78,79,80", "deleted_lines": null, "method_info": {"method_name": "ParserFactory::newParser", "method_params": "dialect", "method_startline": "72", "method_endline": "85"}}, "hunk_2": {"Ismethod": 1, "added_lines": "31,32,33,34,44,47,48", "deleted_lines": "31,41,42,45,46", "method_info": {"method_name": "ParserFactory::ParserFactory", "method_params": "folderPath", "method_startline": "16", "method_endline": "61"}}}}, "file_1": {"file_change_type": "MODIFY", "file_Nmethod": 2, "file_old_name": "java\\parser\\src\\test\\java\\org\\sqlflow\\parser\\ParserFactoryTest.java", "file_new_name": "java\\parser\\src\\test\\java\\org\\sqlflow\\parser\\ParserFactoryTest.java", "hunks": {"hunk_0": {"Ismethod": 1, "added_lines": "20,21,22,23,24,25,26,27,28,29,30,31,32", "deleted_lines": null, "method_info": {"method_name": "ParserFactoryTest::testMaxcompute", "method_params": "", "method_startline": "20", "method_endline": "33"}}, "hunk_1": {"Ismethod": 1, "added_lines": "15,16,17", "deleted_lines": "13,14", "method_info": {"method_name": "ParserFactoryTest::testDynamicLoading", "method_params": "", "method_startline": "11", "method_endline": "17"}}}}, "file_2": {"file_change_type": "MODIFY", "file_Nmethod": 1, "file_old_name": "pkg\\parser\\external\\parser.go", "file_new_name": "pkg\\parser\\external\\parser.go", "hunks": {"hunk_0": {"Ismethod": 1, "added_lines": "39,41,42,43,44,45", "deleted_lines": "39", "method_info": {"method_name": "NewParser", "method_params": "string", "method_startline": "33", "method_endline": "51"}}}}}}}