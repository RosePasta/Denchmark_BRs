{"BR": {"BR_id": "2480", "BR_author": "HHousen", "BRopenT": "2020-07-03T04:08:46Z", "BRcloseT": "2020-07-09T11:11:08Z", "BR_text": {"BRsummary": "For versions &gt;0.8.2 learning rate is zero for last epoch (potentially a logging bug)", "BRdescription": "\n <denchmark-h:h2>\ud83d\udc1b Bug</denchmark-h>\n \n Version 0.8.2 and above changed the behavior of either my learning rate scheduler or the WandbLogger logger. I am using a linear warmup and decay scheduler. However, the learning rate graph produced by the LearningRateLogger is as shown below ever since version 0.8.2:\n <denchmark-link:https://user-images.githubusercontent.com/11785397/86428929-fc898a80-bcbb-11ea-85b1-2a42f4c54cfd.png></denchmark-link>\n \n The period where the learning rate is zero corresponds to the last epoch of training as you can see below:\n <denchmark-link:https://user-images.githubusercontent.com/11785397/86428981-22af2a80-bcbc-11ea-90ff-bf4418dfe090.png></denchmark-link>\n \n This graph raises another issue. The first epoch appears to take twice as many steps as the second and third epoch. I specified max_epochs=3. During training, each epoch takes the same amount of time, so this seems like a logging issue.\n Note that the above graphs are for a model that had its training stopped early. So the last epoch is slightly shorter than the second to last. This is not the issue.\n Both of these issues (the 0 learning rate and the twice-as-long epoch) do not exist in version 0.8.1, and both graphs look as they should.\n These issues could be caused by the logger or they might actually occur and be logged correctly. I have looked through the <denchmark-link:https://github.com/PyTorchLightning/pytorch-lightning/releases>changelog</denchmark-link>\n  and I am guessing that these bugs are caused by \"Changed epoch indexing from 0 instead of 1\" (<denchmark-link:https://github.com/PyTorchLightning/pytorch-lightning/pull/2289>#2289</denchmark-link>\n ). I also may be relying on the fact that epoch indexing started at 1 somewhere in my code, but I do not believe this to be the case.\n <denchmark-h:h3>To Reproduce</denchmark-h>\n \n Reproducing this problem may be difficult since I can't provide the script and data I used. I used the WandbLogger logger and LearningRateLogger callback. I trained with 1400 warmup steps and accumulate_grad_batches set to 2.\n I can provide additional code samples or information that you may need.\n <denchmark-h:h4>Code sample</denchmark-h>\n \n def lr_lambda_func(current_step, num_warmup_steps, num_training_steps):\n     if current_step < num_warmup_steps:\n         return float(current_step) / float(max(1, num_warmup_steps))\n     return max(\n         0.0,\n         float(num_training_steps - current_step)\n         / float(max(1, num_training_steps - num_warmup_steps)),\n     )\n \n t_total = int(len(self.train_dataloader_object) * self.hparams.max_epochs // self.hparams.accumulate_grad_batches)\n \n lr_lambda = partial(\n     lr_lambda_func,\n     num_warmup_steps=self.hparams.warmup_steps\n     * self.hparams.accumulate_grad_batches,\n     num_training_steps=t_total,\n )\n \n scheduler = LambdaLR(optimizer, lr_lambda, -1)\n scheduler_dict = {\"scheduler\": scheduler, \"interval\": \"step\"}\n return ([optimizer], [scheduler_dict])\n <denchmark-h:h3>Expected behavior</denchmark-h>\n \n The learning rate should warmup and decay in versions greater than 0.8.2 the same way it does in versions less than 0.8.2. Each epoch should be the same number of steps.\n The below graphs highlight the expected behavior. They are from a different model so they are not directly comparable, but their shape is as expected since they were captured from a model trained with pytorch_lightning version 0.8.1.\n <denchmark-link:https://user-images.githubusercontent.com/11785397/86430600-b5ea5f00-bcc0-11ea-8c07-b78670f1ef7d.png></denchmark-link>\n \n <denchmark-link:https://user-images.githubusercontent.com/11785397/86430629-c8649880-bcc0-11ea-8aca-85cdde47a0d2.png></denchmark-link>\n \n <denchmark-h:h3>Environment</denchmark-h>\n \n \n CUDA:\n \n GPU:\n \n Tesla P100-PCIE-16GB\n \n \n available:         True\n version:           10.1\n \n \n Packages:\n \n numpy:             1.18.5\n pyTorch_debug:     False\n pyTorch_version:   1.5.1+cu101\n pytorch-lightning: 0.8.4\n tensorboard:       2.2.2\n tqdm:              4.41.1\n \n \n System:\n \n OS:                Linux\n architecture:\n \n 64bit\n \n \n \n processor:         x86_64\n python:            3.6.9\n version:           #1 SMP Wed Feb 19 05:26:34 PST 2020\n \n \n \n \t"}, "comments": {"comments_0": {"comment_id": 1, "comment_author": "HHousen", "commentT": "2020-07-03T04:09:41Z", "comment_text": "\n \t\tHi! thanks for your contribution!, great first issue!\n \t\t"}, "comments_1": {"comment_id": 2, "comment_author": "HHousen", "commentT": "2020-07-03T05:36:59Z", "comment_text": "\n \t\tit would be good to know whether this can be observed with the other loggers as well. Could you run your example also with TensorboardLogger?\n \t\t"}, "comments_2": {"comment_id": 3, "comment_author": "HHousen", "commentT": "2020-07-03T15:06:33Z", "comment_text": "\n \t\tHey! I believe problem lies in configure_accumulated_gradients() when accumulate_grad_batches is integer, scheduler is set to use it from current_epoch=1, but Trainer starts from current_epoch=0, so trainer.accumulate_grad_batches = self.scheduling.get(self.epochs[i]) sets accumulate_grad_batches to default value (1) for this epoch.\n \t\t"}, "comments_3": {"comment_id": 4, "comment_author": "HHousen", "commentT": "2020-07-03T15:10:10Z", "comment_text": "\n \t\tUpdate: When accumulate_grad_batches is an integer, Scheduler gets {1: accumulate_grad_batches} as input, and then scheduling.update({0: 1}) inserts \"default\" 1 for first epoch.\n \t\t"}, "comments_4": {"comment_id": 5, "comment_author": "HHousen", "commentT": "2020-07-03T15:18:41Z", "comment_text": "\n \t\t<denchmark-link:https://github.com/HHousen>@HHousen</denchmark-link>\n  You could do workaround and set  in pl.Trainer (I did so), but you might have problems with restoring from checkpoint, as\n <denchmark-code>n_accum = 1 if self.accumulate_grad_batches is None else self.accumulate_grad_batches\n expected_steps = self.num_training_batches / n_accum\n </denchmark-code>\n \n in restore_training_state will try to use dict in division.\n \t\t"}, "comments_5": {"comment_id": 6, "comment_author": "HHousen", "commentT": "2020-07-03T19:56:20Z", "comment_text": "\n \t\t<denchmark-link:https://github.com/szymonzareba>@szymonzareba</denchmark-link>\n  Yep, setting  to  fixed this problem (I create my  like so: ). Both the learning rate and epoch graphs are now correct. It seems like your reasoning is correct.\n \t\t"}, "comments_6": {"comment_id": 7, "comment_author": "HHousen", "commentT": "2020-07-03T20:20:50Z", "comment_text": "\n \t\t<denchmark-link:https://github.com/HHousen>@HHousen</denchmark-link>\n  mind send a PR?\n \t\t"}, "comments_7": {"comment_id": 8, "comment_author": "HHousen", "commentT": "2020-07-03T20:51:23Z", "comment_text": "\n \t\tSure\n \t\t"}, "comments_8": {"comment_id": 9, "comment_author": "HHousen", "commentT": "2020-07-03T22:45:38Z", "comment_text": "\n \t\t<denchmark-link:https://github.com/PyTorchLightning/pytorch-lightning/pull/2490>#2490</denchmark-link>\n  fixes this. There was a problem with the  test. See <denchmark-link:https://github.com/PyTorchLightning/pytorch-lightning/pull/2490>#2490</denchmark-link>\n  for more information.\n \t\t"}}}, "commit": {"commit_id": "992a7e2a414d052754f3579e173620baf740308a", "commit_author": "Hayden Housen", "commitT": "2020-07-09 07:11:07-04:00", "commit_complexity": {"commit_NLOC": "1.0", "commit_CCN": "1.0", "commit_Nprams": "0.0"}, "changed_files": {"file_0": {"file_change_type": "MODIFY", "file_Nmethod": 1, "file_old_name": "pytorch_lightning\\trainer\\training_tricks.py", "file_new_name": "pytorch_lightning\\trainer\\training_tricks.py", "file_complexity": {"file_NLOC": "235", "file_CCN": "41", "file_NToken": "1406"}, "hunks": {"hunk_0": {"Ismethod": 1, "added_lines": "102", "deleted_lines": "102", "method_info": {"method_name": "configure_accumulated_gradients", "method_params": "self,accumulate_grad_batches", "method_startline": "98", "method_endline": "105", "method_complexity": {"method_NLOC": "8", "method_CCN": "3", "method_NToken": "53", "method_nesting_level": "1"}}}}}, "file_1": {"file_change_type": "MODIFY", "file_Nmethod": 1, "file_old_name": "tests\\trainer\\test_lr_finder.py", "file_new_name": "tests\\trainer\\test_lr_finder.py", "file_complexity": {"file_NLOC": "126", "file_CCN": "13", "file_NToken": "707"}, "hunks": {"hunk_0": {"Ismethod": 1, "added_lines": "157", "deleted_lines": "157", "method_info": {"method_name": "test_accumulation_and_early_stopping", "method_params": "tmpdir", "method_startline": "136", "method_endline": "158", "method_complexity": {"method_NLOC": "16", "method_CCN": "1", "method_NToken": "93", "method_nesting_level": "0"}}}}}, "file_2": {"file_change_type": "MODIFY", "file_Nmethod": 4, "file_old_name": "tests\\trainer\\test_trainer.py", "file_new_name": "tests\\trainer\\test_trainer.py", "file_complexity": {"file_NLOC": "658", "file_CCN": "73", "file_NToken": "5391"}, "hunks": {"hunk_0": {"Ismethod": 1, "added_lines": "143,144,145", "deleted_lines": "144,145", "method_info": {"method_name": "test_gradient_accumulation_scheduling._optimizer_step", "method_params": "epoch,batch_idx,optimizer,optimizer_idx,second_order_closure,on_tpu,using_native_amp,using_lbfgs", "method_startline": "143", "method_endline": "145", "method_complexity": {"method_NLOC": "3", "method_CCN": "1", "method_NToken": "27", "method_nesting_level": "1"}}}, "hunk_1": {"Ismethod": 1, "added_lines": "106,107,108,109,110,111,112,113,114,134,135,136,137,138,139,140,141,143,144,145,150,151,154,156,157,161,162,165,167,168,171,172,175,177,178", "deleted_lines": "106,127,128,133,134,137,139,140,144,145,148,150,151,154,155,158,160,161,168,169,170,171,172,173,174,175,176,178", "method_info": {"method_name": "test_gradient_accumulation_scheduling", "method_params": "tmpdir", "method_startline": "106", "method_endline": "181", "method_complexity": {"method_NLOC": "45", "method_CCN": "7", "method_NToken": "324", "method_nesting_level": "0"}}}, "hunk_2": {"Ismethod": 1, "added_lines": null, "deleted_lines": "127,128", "method_info": {"method_name": "test_gradient_accumulation_scheduling._optimizer_step", "method_params": "self,epoch,batch_idx,optimizer,optimizer_idx,second_order_closure", "method_startline": "127", "method_endline": "128", "method_complexity": {"method_NLOC": "2", "method_CCN": "1", "method_NToken": "17", "method_nesting_level": "1"}}}, "hunk_3": {"Ismethod": 1, "added_lines": "114,134,135,136,137,138,139,140,141,143,144,145,150,151,154,156,157,161,162,165,167,168,171,172,175,177,178,186", "deleted_lines": "127,128,133,134,137,139,140,144,145,148,150,151,154,155,158,160,161,168,169,170,171,172,173,174,175,176,178", "method_info": {"method_name": "test_gradient_accumulation_scheduling", "method_params": "tmpdir,schedule,expected", "method_startline": "114", "method_endline": "189", "method_complexity": {"method_NLOC": "44", "method_CCN": "7", "method_NToken": "359", "method_nesting_level": "0"}}}}}}}}