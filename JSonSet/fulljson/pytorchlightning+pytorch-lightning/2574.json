{"BR": {"BR_id": "2574", "BR_author": "ruotianluo", "BRopenT": "2020-07-10T04:36:46Z", "BRcloseT": "2020-08-04T21:00:56Z", "BR_text": {"BRsummary": "horovod mode increase lr", "BRdescription": "\n <denchmark-h:h2>Not really a \ud83d\udc1b Bug</denchmark-h>\n \n <denchmark-link:https://github.com/PyTorchLightning/pytorch-lightning/blob/master/pytorch_lightning/trainer/distrib_parts.py#L299>https://github.com/PyTorchLightning/pytorch-lightning/blob/master/pytorch_lightning/trainer/distrib_parts.py#L299</denchmark-link>\n \n Under horovod mode, the learning rate will automatically be increased by hvd.size().\n This behavior is different from ddp, so it may confuse the users.\n \t"}, "comments": {"comments_0": {"comment_id": 1, "comment_author": "ruotianluo", "commentT": "2020-07-10T09:52:58Z", "comment_text": "\n \t\tmind check <denchmark-link:https://github.com/tgaddair>@tgaddair</denchmark-link>\n  <denchmark-link:https://github.com/SkafteNicki>@SkafteNicki</denchmark-link>\n   ^^\n \t\t"}, "comments_1": {"comment_id": 2, "comment_author": "ruotianluo", "commentT": "2020-07-10T10:27:11Z", "comment_text": "\n \t\tI was not aware of this. It's seems that it is a good practice, that really can help boost training speed (see this paper <denchmark-link:https://arxiv.org/abs/1706.02677>https://arxiv.org/abs/1706.02677</denchmark-link>\n  and this issue <denchmark-link:https://github.com/horovod/horovod/issues/384>horovod/horovod#384</denchmark-link>\n ). So maybe we should implement something similar for ddp backend.\n \t\t"}, "comments_2": {"comment_id": 3, "comment_author": "ruotianluo", "commentT": "2020-07-10T12:47:01Z", "comment_text": "\n \t\tYes, in Horovod (and I believe DDP), increasing number of workers is analogous to increasing the total batch size during training.  As such, scaling the learning rate proportionately is considered a best practice.  It's good to handle it internally to the distributed_backend, because some backends may behave differently.  For example, in Horovod, enabling the Adasum optimizer only requires scaling by the number of GPUs per host.\n \t\t"}, "comments_3": {"comment_id": 4, "comment_author": "ruotianluo", "commentT": "2020-07-10T14:17:53Z", "comment_text": "\n \t\tI agree it is a good practice. However if it's not the only way, I don't think it should be the default, Especially without notifying the users.\n It could instead be an argument of the trainer.\n \t\t"}, "comments_4": {"comment_id": 5, "comment_author": "ruotianluo", "commentT": "2020-07-10T16:24:18Z", "comment_text": "\n \t\tI think making it configurable is reasonable.  However, I do think it should be enabled by default.  Part of the goal of the Trainer abstraction is to make distributed training accessible to people who are not familiar with distributed training concepts / best practices.\n For most users, unless they are using custom learning rate schedules or unusual optimizers, they will want to scale the learning rate.  At the same time, most users would not know to do this themselves, so I fear without enabling it by default, they would not do so, and their models would converge worse as a result.\n \t\t"}, "comments_5": {"comment_id": 6, "comment_author": "ruotianluo", "commentT": "2020-07-11T16:33:49Z", "comment_text": "\n \t\tBTW, there may be a problem when lr_scheduler is LambdaLR. It seems LambdaLR will collect the lrs in optimizer and save as base_lrs. The lambda function will take place on the base_lrs. Even you change the lr later, the lr scheduler would ignore it.\n <denchmark-link:https://github.com/pytorch/pytorch/blob/879cf0b15a54c7848ae710e3d0ec62c4a9d7d3dd/torch/optim/lr_scheduler.py#L43>https://github.com/pytorch/pytorch/blob/879cf0b15a54c7848ae710e3d0ec62c4a9d7d3dd/torch/optim/lr_scheduler.py#L43</denchmark-link>\n \n LambdaLR scheduler I believe is a commonly used scheduler. For now I think it's safer to delete that line for now, and then think of what is the best way to implement it.\n Of course, correct me if I am wrong.\n \t\t"}, "comments_6": {"comment_id": 7, "comment_author": "ruotianluo", "commentT": "2020-07-16T22:11:00Z", "comment_text": "\n \t\tHey <denchmark-link:https://github.com/ruotianluo>@ruotianluo</denchmark-link>\n , that's a good point regarding interaction with LambdaLR and other LR schedulers.  Can you take a look at <denchmark-link:https://github.com/PyTorchLightning/pytorch-lightning/pull/2626>#2626</denchmark-link>\n  and see if it addresses your concern?\n \t\t"}, "comments_7": {"comment_id": 8, "comment_author": "ruotianluo", "commentT": "2020-07-23T00:27:00Z", "comment_text": "\n \t\t<denchmark-link:https://github.com/tgaddair>@tgaddair</denchmark-link>\n  I still want to defend against scaling learning rate by default. By primitive search, it doesn't seem to me that in nlp, people do the same learning rate scaling. Bert uses batch size 256 and learning rate 1e-4; Roberta uses batch size 8k and max learning rate is 4e-4/6e-4(depending on the model size). I think it may be related to optimizer(in nlp it's usually adam). I don't know if this fact can convince you.\n \t\t"}, "comments_8": {"comment_id": 9, "comment_author": "ruotianluo", "commentT": "2020-07-23T00:35:49Z", "comment_text": "\n \t\tHey <denchmark-link:https://github.com/ruotianluo>@ruotianluo</denchmark-link>\n , even when training BERT with Horovod, it's common practice to scale the learning rate.  See:\n \n https://github.com/LeoWood/bert-horovod/blob/master/optimization_hvd.py#L61\n https://github.com/google-research/bert/pull/568/files#diff-717a6b63e0d2e51c2ff68a440534783eR61\n \n Fundamentally, when you add more workers, you are increasing the batch size.  That holds true whether it is a vision task, NLP, or other scenarios.  So you need to account for that somehow (most commonly through LR scaling, though I imagine other means are possible as well).\n I do agree we should make this configurable, though.  I'm interested in putting together a separate PR for this, but it should include changes to DDP as well.\n \t\t"}, "comments_9": {"comment_id": 10, "comment_author": "ruotianluo", "commentT": "2020-07-23T01:17:51Z", "comment_text": "\n \t\t<denchmark-link:https://arxiv.org/pdf/1904.00962.pdf>https://arxiv.org/pdf/1904.00962.pdf</denchmark-link>\n . This paper uses square root scaling for bert(and also imagenet classification too). Aand albert(from google) uses this approach (<denchmark-link:https://arxiv.org/pdf/1909.11942.pdf>https://arxiv.org/pdf/1909.11942.pdf</denchmark-link>\n ).\n The first link you provide doesn't have any results. For the second, I didn't see any quantitative results either how that would affects.(and it is not merged yet.)\n Do other frameworks do learning rate scaling by default too(Keras, fastai?)? If it's common across other libraries, I think it's fine too.\n \t\t"}, "comments_10": {"comment_id": 11, "comment_author": "ruotianluo", "commentT": "2020-07-23T17:31:01Z", "comment_text": "\n \t\tHey <denchmark-link:https://github.com/ruotianluo>@ruotianluo</denchmark-link>\n , in my experience, frameworks that expose distributed training to users as an API (like ) will mention in their docs that it's good practice to scale the LR, but will leave it to the user to do so (this is what we do with Horovod as well).\n However, frameworks that attempt to completely abstract away distributed training (like PyTorch Lightning is seeking to do) should provide a good reasonable default.\n I agree with you that in practice, it may be that linearly scaling the learning rate does not provide the best model performance, in which cases the researchers will often hand-tune the combination of learning rate and total batch size (i.e., number of workers) to obtain the best performance.  To support that, there is definitely a need to make learning rate adjustment configurable.\n At the same time, whatever solution we come up with needs to be backend-agnostic.  One of the selling points of PL is the ability to swap out different distributed backends.  If we couple the LR scaling to the backend (e.g., require the user to put lr * hvd.size() in the LightningModule), we lose a lot of the benefit.\n With that in mind, here's what I'm currently thinking could be a good solution:\n \n Provide a good reasonable default for users who are not experts in distributed training (linear learning rate scaling) for Horovod and DDP.\n Provide an optional method in the LightningModule that allows the user to adjust the learning rate as a function of the number of workers, independent of the specific backend being used, which will override the default in (1):\n \n <denchmark-code>class MyModule(LightningModule):\n \n     ...\n \n     def adjust_learning_rate(self, base_lr, world_size):\n         return base_lr * sqrt(world_size)\n </denchmark-code>\n \n <denchmark-link:https://github.com/ruotianluo>@ruotianluo</denchmark-link>\n  <denchmark-link:https://github.com/williamFalcon>@williamFalcon</denchmark-link>\n  <denchmark-link:https://github.com/Borda>@Borda</denchmark-link>\n  <denchmark-link:https://github.com/SkafteNicki>@SkafteNicki</denchmark-link>\n  what do you think?\n \t\t"}, "comments_11": {"comment_id": 12, "comment_author": "ruotianluo", "commentT": "2020-07-23T17:57:40Z", "comment_text": "\n \t\tcc: <denchmark-link:https://github.com/orgs/PyTorchLightning/teams/core-contributors>@PyTorchLightning/core-contributors</denchmark-link>\n \n \t\t"}, "comments_12": {"comment_id": 13, "comment_author": "ruotianluo", "commentT": "2020-08-04T21:00:56Z", "comment_text": "\n \t\tshall be resolved in <denchmark-link:https://github.com/PyTorchLightning/pytorch-lightning/pull/2626>#2626</denchmark-link>\n \n \t\t"}}}, "commit": {"commit_id": "1369012bc71f257dcf7423ec65146d055ddc1cc7", "commit_author": "Travis Addair", "commitT": "2020-07-23 12:14:57-04:00", "commit_complexity": {"commit_NLOC": "0.0", "commit_CCN": "0.84", "commit_Nprams": "1.0"}, "changed_files": {"file_0": {"file_change_type": "MODIFY", "file_Nmethod": 0, "file_old_name": "CHANGELOG.md", "file_new_name": "CHANGELOG.md", "file_complexity": {"file_NLOC": "None", "file_CCN": "None", "file_NToken": "None"}, "hunks": {"hunk_0": {"Ismethod": 0, "added_lines": "28,29", "deleted_lines": null}}}, "file_1": {"file_change_type": "MODIFY", "file_Nmethod": 1, "file_old_name": "pytorch_lightning\\trainer\\distrib_parts.py", "file_new_name": "pytorch_lightning\\trainer\\distrib_parts.py", "file_complexity": {"file_NLOC": "378", "file_CCN": "107", "file_NToken": "2249"}, "hunks": {"hunk_0": {"Ismethod": 1, "added_lines": "302,303,304,305,306,307", "deleted_lines": "302", "method_info": {"method_name": "horovod_train", "method_params": "self,model", "method_startline": "276", "method_endline": "342", "method_complexity": {"method_NLOC": "38", "method_CCN": "15", "method_NToken": "333", "method_nesting_level": "1"}}}}}, "file_2": {"file_change_type": "MODIFY", "file_Nmethod": 2, "file_old_name": "tests\\models\\test_horovod.py", "file_new_name": "tests\\models\\test_horovod.py", "file_complexity": {"file_NLOC": "162", "file_CCN": "21", "file_NToken": "1171"}, "hunks": {"hunk_0": {"Ismethod": 1, "added_lines": "183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212", "deleted_lines": null, "method_info": {"method_name": "test_horovod_multi_optimizer_with_scheduling_stepping", "method_params": "tmpdir", "method_startline": "183", "method_endline": "212", "method_complexity": {"method_NLOC": "21", "method_CCN": "3", "method_NToken": "162", "method_nesting_level": "0"}}}, "hunk_1": {"Ismethod": 1, "added_lines": null, "deleted_lines": "116", "method_info": {"method_name": "test_horovod_transfer_batch_to_gpu", "method_params": "tmpdir", "method_startline": "115", "method_endline": "143", "method_complexity": {"method_NLOC": "17", "method_CCN": "1", "method_NToken": "80", "method_nesting_level": "0"}}}}}}}}