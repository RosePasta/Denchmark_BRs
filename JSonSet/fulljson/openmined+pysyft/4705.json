{"BR": {"BR_id": "4705", "BR_author": "LaRiffle", "BRopenT": "2020-10-24T13:20:39Z", "BRcloseT": "2020-11-05T12:59:50Z", "BR_text": {"BRsummary": "Comparison between FPT and AST doesn't always works", "BRdescription": "\n <denchmark-h:h2>Description</denchmark-h>\n \n Some cases of handling comparison between FixedPrecision and AdditiveSharingTensor are supported, but some are not. We should systematize this.\n <denchmark-h:h2>How to Reproduce</denchmark-h>\n \n t1 = torch.tensor([1.2, 1]).fix_precision().share(*workers, crypto_provider=crypto_provider, protocol=\"fss\")\n t2 = torch.tensor([1.2, 1]).fix_precision()\n \n t1 > t2 # FAILS but t1 < t2 works\n <denchmark-h:h2>Stacktrace</denchmark-h>\n \n <denchmark-code>AttributeError                            Traceback (most recent call last)\n <ipython-input-10-c55d3fcd7179> in <module>\n       2 t2 = torch.tensor([1.2, 1]).fix_precision()#.share(*workers, crypto_provider=crypto_provider, protocol=\"fss\", requires_grad=True)\n       3 \n ----> 4 t1 > t2\n \n ~/code/PySyft/syft/generic/frameworks/hook/hook.py in overloaded_native_method(self, *args, **kwargs)\n     218                 # Send the new command to the appropriate class and get the response\n     219                 method = getattr(new_self, method_name)\n --> 220                 response = method(*new_args, **new_kwargs)\n     221 \n     222                 # For inplace methods, just directly return self\n \n ~/code/PySyft/syft/generic/frameworks/overload.py in _hook_method_args(self, *args, **kwargs)\n      25 \n      26             # Send it to the appropriate class and get the response\n ---> 27             response = attr(self, new_self, *new_args, **new_kwargs)\n      28 \n      29             # Put back SyftTensor on the tensors found in the response\n \n ~/code/PySyft/syft/frameworks/torch/tensors/interpreters/precision.py in __gt__(self, _self, other)\n     821     def __gt__(self, _self, other):\n     822         print(\"FPT gt\", _self, other)\n --> 823         result = _self.__gt__(other)\n     824         return result.type(self.torch_dtype) * self.base ** self.precision_fractional\n     825 \n \n ~/code/PySyft/syft/frameworks/torch/mpc/__init__.py in method(self, *args, **kwargs)\n      33         def method(self, *args, **kwargs):\n      34             f = protocol_store[(name, self.protocol)]\n ---> 35             return f(self, *args, **kwargs)\n      36 \n      37         return method\n \n ~/code/PySyft/syft/frameworks/torch/tensors/interpreters/additive_shared.py in __gt__(self, other)\n     938     @crypto_protocol(\"fss\")\n     939     def __gt__(self, other):\n --> 940         return (other + 1) <= self\n     941 \n     942     def ge(self, other):\n \n ~/code/PySyft/syft/generic/frameworks/hook/hook.py in overloaded_native_method(self, *args, **kwargs)\n     156                     # arguments\n     157                     if not isinstance(args[0].child, PointerTensor):\n --> 158                         self = type(args[0].child)().on(self, wrap=True)\n     159                         args = [args[0]]\n     160                         return overloaded_native_method(self, *args, **kwargs)\n \n AttributeError: 'dict' object has no attribute 'on'\n \n </denchmark-code>\n \n \t"}, "comments": {}}, "commit": {"commit_id": "d2bbbc994aa7e7428d9686c3c160e3bcaff881d6", "commit_author": "Anubhav Raj Singh", "commitT": "2020-11-05 18:17:49+05:18", "commit_complexity": {"commit_NLOC": "0.3076923076923077", "commit_CCN": "1.0", "commit_Nprams": "0.3076923076923077"}, "changed_files": {"file_0": {"file_change_type": "MODIFY", "file_Nmethod": 0, "file_old_name": "pip-dep\\requirements_udacity.txt", "file_new_name": "pip-dep\\requirements_udacity.txt", "file_complexity": {"file_NLOC": "None", "file_CCN": "None", "file_NToken": "None"}, "hunks": {"hunk_0": {"Ismethod": 0, "added_lines": "2", "deleted_lines": "1"}}}, "file_1": {"file_change_type": "MODIFY", "file_Nmethod": 1, "file_old_name": "syft\\frameworks\\torch\\tensors\\interpreters\\additive_shared.py", "file_new_name": "syft\\frameworks\\torch\\tensors\\interpreters\\additive_shared.py", "file_complexity": {"file_NLOC": "798", "file_CCN": "227", "file_NToken": "5811"}, "hunks": {"hunk_0": {"Ismethod": 1, "added_lines": "932", "deleted_lines": "932", "method_info": {"method_name": "__gt__", "method_params": "self,other", "method_startline": "931", "method_endline": "932", "method_complexity": {"method_NLOC": "2", "method_CCN": "1", "method_NToken": "17", "method_nesting_level": "1"}}}}}, "file_2": {"file_change_type": "MODIFY", "file_Nmethod": 2, "file_old_name": "test\\torch\\tensors\\test_additive_shared.py", "file_new_name": "test\\torch\\tensors\\test_additive_shared.py", "file_complexity": {"file_NLOC": "941", "file_CCN": "80", "file_NToken": "13115"}, "hunks": {"hunk_0": {"Ismethod": 1, "added_lines": "1370,1371,1372,1373,1374,1375,1376,1377,1378,1379,1380,1381,1382,1383,1384,1385,1386", "deleted_lines": null, "method_info": {"method_name": "test_eq_ast_fpt", "method_params": "workers,protocol", "method_startline": "1370", "method_endline": "1386", "method_complexity": {"method_NLOC": "12", "method_CCN": "1", "method_NToken": "112", "method_nesting_level": "0"}}}, "hunk_1": {"Ismethod": 1, "added_lines": "1332,1333,1334,1335,1336,1337,1338,1339,1340,1341,1342,1343,1344,1345,1346,1347,1348,1349,1350,1351,1352,1353,1354,1355,1356,1357,1358,1359,1360,1361,1362,1363,1364,1365,1366", "deleted_lines": null, "method_info": {"method_name": "test_comp_ast_fpt", "method_params": "workers,protocol,force_preprocessing", "method_startline": "1332", "method_endline": "1366", "method_complexity": {"method_NLOC": "27", "method_CCN": "2", "method_NToken": "427", "method_nesting_level": "0"}}}}}}}}