{"BR": {"BR_id": "533", "BR_author": "cvjjm", "BRopenT": "2020-03-06T14:19:48Z", "BRcloseT": "2020-03-16T10:28:10Z", "BR_text": {"BRsummary": ".inv() not correctly inverting `Operation.decomposition()`", "BRdescription": "\n Update: I thought this would only be a problem in the drawer but also the circuit does not yield the expected result.\n A user (like myself) might want to define their own Operation and start from one of the PennyLane Operations, e.g., Rot.\n Now, If I just copy the definition of Rot to my module and rename it to MyRot, then the operation is no longer natively supported by, e.g., the default.qubit device, but it has a decomposition (the same as that of Rot into supported gates) and so I can use it without problems in my qnode circuits. However problems start to occur when I use MyRot(...).inv().\n A circuit such as\n <denchmark-code>@qml.qnode(dev)\n def circuit(*params):\n     MyRot(0.1, 0.2, 0.3, wires=0).inv()\n     Rot(0.1, 0.2, 0.3, wires=0)\n     return qml.probs(range(wires))\n </denchmark-code>\n \n does not yield the expected result (the two gates should cancel) and circuit.draw() looks the same irrespective of whether the .inv() is there or not. If I put the .inv() on Rot instead of the MyRot then the correct result is obtained.\n As expected, the Rot gate is displayed as such by the circuit drawer and MyRot is decomposed into elementary rotations, but the individual rotations do not get an .inv when MyRot is inverted and their order is not reversed.\n \t"}, "comments": {"comments_0": {"comment_id": 1, "comment_author": "cvjjm", "commentT": "2020-03-06T15:49:20Z", "comment_text": "\n \t\tHi <denchmark-link:https://github.com/cvjjm>@cvjjm</denchmark-link>\n , thanks so much for opening an issue for this! \n Could you please provide more details on how exactly the definition of MyRot looks like in your case? In specific, was it decorated with @template?\n \t\t"}, "comments_1": {"comment_id": 2, "comment_author": "cvjjm", "commentT": "2020-03-07T10:01:14Z", "comment_text": "\n \t\tIt sounds like  is not a template, but a custom operation, can you confirm <denchmark-link:https://github.com/cvjjm>@cvjjm</denchmark-link>\n ? It might be useful if you could post your minimal (non)-working example \n Most likely this could be a bug in how either PennyLane or the default.qubit simulator is treating the inverses of decomposed operations!\n \t\t"}, "comments_2": {"comment_id": 3, "comment_author": "cvjjm", "commentT": "2020-03-09T07:56:08Z", "comment_text": "\n \t\tI agree that for what I originally wanted to achieve I could just as well define a template, but I then found it more convenient to subclass Operation (for example because I can define num_params and num_wires) and in this way discovered what I think is indeed a bug in how PL (or default.qubit?) treats the inverse of decomposable operations. Inv on operations that need to be decomposed doesn't seem to do anything. Instead of queuing the inverse of the gates from the decomposition in the reverse order, the gates from the decomposition are applied normally.\n MyRot is just of demonstration purposes and a plain vanilla copy of Rot() and consequently looks like this:\n <denchmark-code>class MyRot(Operation):\n     r\"\"\"MyRot(phi, theta, omega, wires)\n     A simple copy or Rot() to demonstrate a problem.\n     .. math::\n         R(\\phi,\\theta,\\omega) = RZ(\\omega)RY(\\theta)RZ(\\phi)= \\begin{bmatrix}\n         e^{-i(\\phi+\\omega)/2}\\cos(\\theta/2) & -e^{i(\\phi-\\omega)/2}\\sin(\\theta/2) \\\\\n         e^{-i(\\phi-\\omega)/2}\\sin(\\theta/2) & e^{i(\\phi+\\omega)/2}\\cos(\\theta/2)\n         \\end{bmatrix}.\n     **Details:**\n     * Number of wires: 1\n     * Number of parameters: 3\n     * Gradient recipe: :math:`\\frac{d}{d\\phi}f(R(\\phi, \\theta, \\omega)) = \\frac{1}{2}\\left[f(R(\\phi+\\pi/2, \\theta, \\omega)) - f(R(\\phi-\\pi/2, \\theta, \\omega))\\right]`\n       where :math:`f` is an expectation value depending on :math:`R(\\phi, \\theta, \\omega)`.\n       This gradient recipe applies for each angle argument :math:`\\{\\phi, \\theta, \\omega\\}`.\n     .. note::\n         If the ``Rot`` gate is not supported on the targeted device, PennyLane\n         will attempt to decompose the gate into :class:`~.RZ` and :class:`~.RY` gates.\n     Args:\n         phi (float): rotation angle :math:`\\phi`\n         theta (float): rotation angle :math:`\\theta`\n         omega (float): rotation angle :math:`\\omega`\n         wires (Sequence[int] or int): the wire the operation acts on\n     \"\"\"\n     num_params = 3\n     num_wires = 1\n     par_domain = \"R\"\n     grad_method = \"A\"\n \n     @staticmethod\n     def _matrix(*params):\n         a, b, c = params\n         return RZ._matrix(c) @ (RY._matrix(b) @ RZ._matrix(a))\n \n     @staticmethod\n     def decomposition(phi, theta, omega, wires):\n         decomp_ops = [RZ(phi, wires=wires), RY(theta, wires=wires), RZ(omega, wires=wires)]\n         return decomp_ops\n </denchmark-code>\n \n This together with the qnode above (and the usual boilerplate to set up a one wire device and such) is a minimal non, working example. Observe that the output of the above qnode is [1,0] in case the .inv() is on Rot() and it is not in case .inv is on MyRot(). Printing circuit.draw() reveals that MyRot() is deomposed but the resulting sequence of gates is not inverted.\n \t\t"}, "comments_3": {"comment_id": 4, "comment_author": "cvjjm", "commentT": "2020-03-09T08:31:44Z", "comment_text": "\n \t\tIndeed looks like a bug in ! Thanks for alerting this to us <denchmark-link:https://github.com/cvjjm>@cvjjm</denchmark-link>\n \n \t\t"}, "comments_4": {"comment_id": 5, "comment_author": "cvjjm", "commentT": "2020-03-16T10:28:10Z", "comment_text": "\n \t\tHi <denchmark-link:https://github.com/cvjjm>@cvjjm</denchmark-link>\n , this was fixed in PR <denchmark-link:https://github.com/PennyLaneAI/pennylane/pull/543>#543</denchmark-link>\n . You can use the new functionality when directly installing the latest master branch of PennyLane.\n \t\t"}, "comments_5": {"comment_id": 6, "comment_author": "cvjjm", "commentT": "2020-03-16T10:37:51Z", "comment_text": "\n \t\tThank you very much for fixing this so fast!\n \t\t"}}}, "commit": {"commit_id": "1de545dd1df74e7c20eb06f86f1ecb2aba9e28dc", "commit_author": "Johannes Jakob Meyer", "commitT": "2020-03-13 16:21:36+01:00", "commit_complexity": {"commit_NLOC": "0.023809523809523808", "commit_CCN": "1.0", "commit_Nprams": "1.0"}, "changed_files": {"file_0": {"file_change_type": "MODIFY", "file_Nmethod": 1, "file_old_name": "pennylane\\qnodes\\base.py", "file_new_name": "pennylane\\qnodes\\base.py", "file_complexity": {"file_NLOC": "409", "file_CCN": "117", "file_NToken": "2495"}, "hunks": {"hunk_0": {"Ismethod": 1, "added_lines": "101,102,103", "deleted_lines": null, "method_info": {"method_name": "_decompose_queue", "method_params": "ops,device", "method_startline": "86", "method_endline": "107", "method_complexity": {"method_NLOC": "12", "method_CCN": "4", "method_NToken": "81", "method_nesting_level": "0"}}}}}, "file_1": {"file_change_type": "MODIFY", "file_Nmethod": 14, "file_old_name": "tests\\qnodes\\test_qnode_base.py", "file_new_name": "tests\\qnodes\\test_qnode_base.py", "file_complexity": {"file_NLOC": "917", "file_CCN": "139", "file_NToken": "9439"}, "hunks": {"hunk_0": {"Ismethod": 1, "added_lines": "1188", "deleted_lines": null, "method_info": {"method_name": "test_regular_arguments", "method_params": "self,mock_device", "method_startline": "1186", "method_endline": "1210", "method_complexity": {"method_NLOC": "13", "method_CCN": "2", "method_NToken": "105", "method_nesting_level": "1"}}}, "hunk_1": {"Ismethod": 1, "added_lines": "1214", "deleted_lines": "1228", "method_info": {"method_name": "test_array_arguments", "method_params": "self,mock_device", "method_startline": "1212", "method_endline": "1238", "method_complexity": {"method_NLOC": "14", "method_CCN": "2", "method_NToken": "111", "method_nesting_level": "1"}}}, "hunk_2": {"Ismethod": 1, "added_lines": "1313", "deleted_lines": null, "method_info": {"method_name": "test_variadic_arguments", "method_params": "self,mock_device", "method_startline": "1311", "method_endline": "1338", "method_complexity": {"method_NLOC": "16", "method_CCN": "2", "method_NToken": "137", "method_nesting_level": "1"}}}, "hunk_3": {"Ismethod": 1, "added_lines": "1117,1118,1119,1120,1121,1122,1123,1124,1125,1126,1127,1128,1129,1130,1131,1132,1133,1134,1135,1136,1137,1138,1139,1140,1141,1142,1143,1144,1145,1146,1147,1148,1149,1150,1151,1152,1153,1154,1155,1156,1157", "deleted_lines": "1129,1132,1133,1134,1135,1141,1146", "method_info": {"method_name": "test_decompose_queue_inv", "method_params": "self,operable_mock_device_2_wires_with_inverses", "method_startline": "1117", "method_endline": "1157", "method_complexity": {"method_NLOC": "26", "method_CCN": "1", "method_NToken": "261", "method_nesting_level": "1"}}}, "hunk_4": {"Ismethod": 1, "added_lines": "912", "deleted_lines": "919,924", "method_info": {"method_name": "test_mutable_qnode", "method_params": "self,theta,phi,varphi,tol", "method_startline": "908", "method_endline": "930", "method_complexity": {"method_NLOC": "13", "method_CCN": "1", "method_NToken": "158", "method_nesting_level": "1"}}}, "hunk_5": {"Ismethod": 1, "added_lines": "1058,1059,1060,1061,1062,1063,1064,1065,1066,1067,1068,1069,1070,1071,1072,1073,1074,1075,1076,1077,1078,1079,1080,1081,1082,1083,1084,1085,1086,1087,1088,1089,1090,1091,1092,1093,1094,1095,1096,1097,1098,1099,1100,1101,1102,1103,1104,1105,1106,1107,1108,1109,1110,1111,1112,1113,1114,1115", "deleted_lines": null, "method_info": {"method_name": "test_decompose_queue_recursive", "method_params": "self,operable_mock_device_2_wires_with_inverses", "method_startline": "1058", "method_endline": "1115", "method_complexity": {"method_NLOC": "36", "method_CCN": "1", "method_NToken": "380", "method_nesting_level": "1"}}}, "hunk_6": {"Ismethod": 1, "added_lines": "1242,1252,1255,1256,1257,1258,1264,1265,1266,1267", "deleted_lines": null, "method_info": {"method_name": "test_regular_keyword_arguments", "method_params": "self,mock_device", "method_startline": "1240", "method_endline": "1268", "method_complexity": {"method_NLOC": "17", "method_CCN": "3", "method_NToken": "144", "method_nesting_level": "1"}}}, "hunk_7": {"Ismethod": 1, "added_lines": "937,942", "deleted_lines": null, "method_info": {"method_name": "test_mutable_qnode_for_loop_varying_executions", "method_params": "self,tol", "method_startline": "932", "method_endline": "952", "method_complexity": {"method_NLOC": "10", "method_CCN": "1", "method_NToken": "157", "method_nesting_level": "1"}}}, "hunk_8": {"Ismethod": 1, "added_lines": "1273", "deleted_lines": null, "method_info": {"method_name": "test_array_keyword_arguments.circuit", "method_params": "a,0", "method_startline": "1273", "method_endline": "1282", "method_complexity": {"method_NLOC": "9", "method_CCN": "1", "method_NToken": "166", "method_nesting_level": "2"}}}, "hunk_9": {"Ismethod": 1, "added_lines": "942", "deleted_lines": null, "method_info": {"method_name": "test_mutable_qnode_for_loop_varying_executions.node", "method_params": "x,n", "method_startline": "940", "method_endline": "944", "method_complexity": {"method_NLOC": "5", "method_CCN": "3", "method_NToken": "62", "method_nesting_level": "2"}}}, "hunk_10": {"Ismethod": 1, "added_lines": "63,64,65,66,67,68,69,70,71,72,73,74,75", "deleted_lines": null, "method_info": {"method_name": "operable_mock_device_2_wires_with_inverses", "method_params": "monkeypatch", "method_startline": "63", "method_endline": "75", "method_complexity": {"method_NLOC": "11", "method_CCN": "1", "method_NToken": "147", "method_nesting_level": "0"}}}, "hunk_11": {"Ismethod": 1, "added_lines": "1272,1273,1285,1288,1294,1305,1306,1307,1308", "deleted_lines": null, "method_info": {"method_name": "test_array_keyword_arguments", "method_params": "self,mock_device", "method_startline": "1270", "method_endline": "1309", "method_complexity": {"method_NLOC": "25", "method_CCN": "3", "method_NToken": "195", "method_nesting_level": "1"}}}, "hunk_12": {"Ismethod": 1, "added_lines": "336", "deleted_lines": null, "method_info": {"method_name": "test_prune_tensors_construct", "method_params": "self,mock_device", "method_startline": "334", "method_endline": "345", "method_complexity": {"method_NLOC": "7", "method_CCN": "1", "method_NToken": "70", "method_nesting_level": "1"}}}, "hunk_13": {"Ismethod": 1, "added_lines": "1359,1360,1361,1362", "deleted_lines": null, "method_info": {"method_name": "test_draw_before_construction_error", "method_params": "self", "method_startline": "1349", "method_endline": "1363", "method_complexity": {"method_NLOC": "9", "method_CCN": "1", "method_NToken": "45", "method_nesting_level": "1"}}}}}}}}