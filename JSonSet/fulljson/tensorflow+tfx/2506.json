{"BR": {"BR_id": "2506", "BR_author": "pselden", "BRopenT": "2020-09-17T20:52:05Z", "BRcloseT": "2021-01-08T20:54:09Z", "BR_text": {"BRsummary": "\"Type already exists with different properties error\" when running TFX 0.21.2 and TFX 0.23.0 in same kubeflow", "BRdescription": "\n One of the users of my kubeflow cluster is using TFX 0.21.4 and another is using TFX 0.23.0\n After any pipeline is run that uses TFX 0.23.0, the ones that use TFX 0.21.4 fail with the following error during BigQueryExampleGen\n <denchmark-code>Traceback (most recent call last):\n   File \"/tfx-src/tfx/orchestration/kubeflow/container_entrypoint.py\", line 382, in <module>\n     main()\n   File \"/tfx-src/tfx/orchestration/kubeflow/container_entrypoint.py\", line 375, in main\n     execution_info = launcher.launch()\n   File \"/tfx-src/tfx/orchestration/launcher/base_component_launcher.py\", line 197, in launch\n     self._exec_properties)\n   File \"/tfx-src/tfx/orchestration/launcher/base_component_launcher.py\", line 166, in _run_driver\n     component_info=self._component_info)\n   File \"/tfx-src/tfx/components/base/base_driver.py\", line 289, in pre_execution\n     contexts=contexts)\n   File \"/tfx-src/tfx/orchestration/metadata.py\", line 601, in update_execution\n     registered_artifacts_ids=registered_output_artifact_ids))\n   File \"/tfx-src/tfx/orchestration/metadata.py\", line 538, in _artifact_and_event_pairs\n     a.set_mlmd_artifact_type(self._prepare_artifact_type(a.artifact_type))\n   File \"/tfx-src/tfx/orchestration/metadata.py\", line 184, in _prepare_artifact_type\n     artifact_type=artifact_type, can_add_fields=True)\n   File \"/opt/venv/lib/python3.6/site-packages/ml_metadata/metadata_store/metadata_store.py\", line 268, in put_artifact_type\n     self._call('PutArtifactType', request, response)\n   File \"/opt/venv/lib/python3.6/site-packages/ml_metadata/metadata_store/metadata_store.py\", line 131, in _call\n     return self._call_method(method_name, request, response)\n   File \"/opt/venv/lib/python3.6/site-packages/ml_metadata/metadata_store/metadata_store.py\", line 162, in _call_method\n     raise _make_exception(e.details(), e.code().value[0])\n tensorflow.python.framework.errors_impl.AlreadyExistsError: Type already exists with different properties.\n \n </denchmark-code>\n \n I completely wiped out my kubeflow cluster/metadata to test from scratch, and the same thing happens. Is there any way to avoid that short of forcing everyone to be on the same tfx version?\n \t"}, "comments": {"comments_0": {"comment_id": 1, "comment_author": "pselden", "commentT": "2020-09-25T16:59:48Z", "comment_text": "\n \t\tAnyone else having this issue or know a workaround?\n \t\t"}, "comments_1": {"comment_id": 2, "comment_author": "pselden", "commentT": "2020-10-02T22:16:33Z", "comment_text": "\n \t\tThis happens with 0.22.1 and 0.24.0 as well. Throwing an error using tfx.extensions.google_cloud_big_query.example_gen.component import BigQueryExampleGen\n \t\t"}, "comments_2": {"comment_id": 3, "comment_author": "pselden", "commentT": "2020-10-02T22:29:15Z", "comment_text": "\n \t\tRunning into same issue with upgrade, we are trying to debug to identify possible workarounds\n \t\t"}, "comments_3": {"comment_id": 4, "comment_author": "pselden", "commentT": "2020-10-02T23:24:45Z", "comment_text": "\n \t\tThis might due to artifact's properties changes between TFX versions, the compatibility is single direction.\n If Metadata type is updated, the old type might become incompatible.\n Consider using different metadata db when run old version of TFX?\n \t\t"}, "comments_4": {"comment_id": 5, "comment_author": "pselden", "commentT": "2020-10-05T16:19:57Z", "comment_text": "\n \t\tIs that an \u201cexpected\u201d incompatibility that can be introduced in future versions? It seems acceptable although annoying that within a single pipeline the upgrade is a one-way process but for it to affect completely unrelated pipelines is quite bad.\n How would I go about creating and using a parallel metadata DB?\n \t\t"}, "comments_5": {"comment_id": 6, "comment_author": "pselden", "commentT": "2020-10-05T18:18:25Z", "comment_text": "\n \t\tIn our current TFX examples, each pipeline has its own Metadata DB.\n +Hui@, Do you know if there is any pipeline level isolation provided in MLMD recently?\n \t\t"}, "comments_6": {"comment_id": 7, "comment_author": "pselden", "commentT": "2020-10-05T18:46:47Z", "comment_text": "\n \t\tHow is that supposed to work with Kubeflow though? There's a single metadata service that connects to a single metadata database.\n \t\t"}, "comments_7": {"comment_id": 8, "comment_author": "pselden", "commentT": "2020-10-05T21:37:24Z", "comment_text": "\n \t\tWould be nice to have this actually be directional. On larger TFX deployments, you may want to reuse MLMD instances. Also there's potentialy to use centralized MLMD to reuse artifacts across pipelines using ResolverNodes. But this wont be possible if every time there's an upgrade it's not backwards compatible as code can't be redeployed for every single pipeline.\n \t\t"}, "comments_8": {"comment_id": 9, "comment_author": "pselden", "commentT": "2020-10-05T21:49:55Z", "comment_text": "\n \t\tI think I agree with Paul and Gerard that we should aim to get support of\n multi-tenanted MLMD working. We had some existing designs but had not got\n time to prioritize implementation.\n \n <denchmark-link:https://github.com/charles>@charles</denchmark-link>\n  Chen <ccy@google.com> <denchmark-link:https://github.com/hui>@hui</denchmark-link>\n  Miao <huimiao@google.com> <denchmark-link:https://github.com/neoklis>@neoklis</denchmark-link>\n \n Polyzotis <npolyzotis@google.com> can help to comment on readiness of\n related proposals.\n <denchmark-link:#>\u2026</denchmark-link>\n \n \n On Mon, Oct 5, 2020 at 2:37 PM Gerard Casas Saez ***@***.***> wrote:\n  Would be nice to have this actually be directional. On larger TFX\n  deployments, you may want to reuse MLMD instances. Also there's potentialy\n  to use centralized MLMD to reuse artifacts across pipelines using\n  ResolverNodes. But this wont be possible if every time there's an upgrade\n  it's not backwards compatible as code can't be redeployed for every single\n  pipeline.\n \n  \u2014\n  You are receiving this because you are subscribed to this thread.\n  Reply to this email directly, view it on GitHub\n  <#2506 (comment)>,\n  or unsubscribe\n  <https://github.com/notifications/unsubscribe-auth/AAY6AZWS4JW2FDMFTGZR6UDSJI4CJANCNFSM4RQ7YWCA>\n  .\n \n \n -- \n Cheers,\n \n Zhitao Li\n \n \t\t"}, "comments_9": {"comment_id": 10, "comment_author": "pselden", "commentT": "2020-10-05T23:28:26Z", "comment_text": "\n \t\tOn a different note, is there any chance we can add some testing to avoid this type of breaking update from happening again?\u00a0\n It was surprising to hear that backwards compatibility on MLMD schema is not granted. We expected that if <denchmark-link:https://github.com/google/ml-metadata/blob/master/g3doc/get_started.md#downgrade-the-database-schema>MLMD had the same schema</denchmark-link>\n  then we wouldn't have issues on upgrade or downgrade. We did this upgrade blinded by the fact MLMD repo said the schema was the same version as the previous version.\u00a0\n In addition, we are lacking tools to perform a downgrade of TFX types to the previous version which is making our job at the current moment quite hard.\n We are adding more processes to perform these upgrades on our side to testing that: Running our example pipeline on a new version of TFX and then running the same pipeline with the existing version of TFX in a shared MLMD works.\n \t\t"}, "comments_10": {"comment_id": 11, "comment_author": "pselden", "commentT": "2020-10-05T23:46:23Z", "comment_text": "\n \t\t\n This might due to artifact's properties changes between TFX versions, the compatibility is single direction.\n If Metadata type is updated, the old type might become incompatible.\n \n To just clarify this comments, this issue happens when the properties set of the type in mlmd is not a super or subset of the new properties set.\n E.g., in metadata, the properties of type X is (A,B,C), register new superset (A,B,C,D) or subset(A,B) will be compatible. But error happens when trying to register type X with properties like (A,B,D)\n \t\t"}, "comments_11": {"comment_id": 12, "comment_author": "pselden", "commentT": "2020-10-06T00:38:00Z", "comment_text": "\n \t\tYup, I understand. I just don't understand why using BigQueryExampleGen on 0.22.1 and 0.24.0 can't happen at the same time.\n After debugging a bit more though, I think we can narrow down a bit more using the GRPC server error log\n <denchmark-code>2020-10-06 00:26:53.508991: W ml_metadata/metadata_store/metadata_store_service_impl.cc:59] PutArtifactType failed: Type already exists with different properties.\n </denchmark-code>\n \n Seems the issue is with an artifact type. Could it be due to  standard artifact adding <denchmark-link:https://github.com/tensorflow/tfx/compare/v0.22.1...v0.24.0#diff-e807d9ad36fccf0c68690d0681057b5b>new properties</denchmark-link>\n ? Given that it hasn't removed any property I think it should work as it's a superset (upgrade version) and then a subset  (downgrade). Unless I'm missing something\n I've been looking at <denchmark-link:https://github.com/tensorflow/tfx/compare/v0.22.1...v0.24.0>v0.22.1...v0.24.0</denchmark-link>\n  to see if there's any of the (A,B,D) situation you described.\n Btw, another action item would be to make those errors a bit more verbose. It would be nice to have TFX tell us what type is the one that failed to register.\n \t\t"}, "comments_12": {"comment_id": 13, "comment_author": "pselden", "commentT": "2020-10-06T01:11:27Z", "comment_text": "\n \t\tone way to find out is add some logs in mlmd to print detailed information like <denchmark-link:https://github.com/tensorflow/tfx/blob/master/tfx/orchestration/metadata.py#L437>this</denchmark-link>\n \n Here is the <denchmark-link:https://github.com/tensorflow/tfx/blob/master/tfx/orchestration/metadata.py#L185>call</denchmark-link>\n  for artifact type\n (or just query MLMD to check the type information)\n we did add new properties to the artifacts. But adding new properties should work.\n \t\t"}, "comments_13": {"comment_id": 14, "comment_author": "pselden", "commentT": "2020-10-06T01:16:45Z", "comment_text": "\n \t\tHow about removing them? The issue happens after you run a pipeline in 0.24 (which adds the properties to the artifact type) and then running a pipeline in 0.22.1 (which tries to remove the properties?)\n \t\t"}, "comments_14": {"comment_id": 15, "comment_author": "pselden", "commentT": "2020-10-06T01:22:16Z", "comment_text": "\n \t\tOkay, after checking <denchmark-link:https://github.com/tensorflow/tfx/blob/master/tfx/orchestration/metadata.py#L185>https://github.com/tensorflow/tfx/blob/master/tfx/orchestration/metadata.py#L185</denchmark-link>\n  and <denchmark-link:https://github.com/google/ml-metadata/blob/59c6afc76a339536600f782b9c4578a662cc6bd2/ml_metadata/metadata_store/metadata_store.py#L232>https://github.com/google/ml-metadata/blob/59c6afc76a339536600f782b9c4578a662cc6bd2/ml_metadata/metadata_store/metadata_store.py#L232</denchmark-link>\n  I'm guessing (hunch) that the issue may be due to TFX calling MLMD using  when registering the artifact. This may make the call to fail when there are fields registered in MLMD but are not existing in the current representation.\n I'm going to try to recreate the issue as a unit test and see if it gets solved by setting all_fields_match = False.\n \t\t"}, "comments_15": {"comment_id": 16, "comment_author": "pselden", "commentT": "2020-10-06T01:23:56Z", "comment_text": "\n \t\t<denchmark-link:https://github.com/hui>@hui</denchmark-link>\n , what happens when we set both can_add_fields and <denchmark-link:https://github.com/google/ml-metadata/blob/r0.24.0/ml_metadata/metadata_store/metadata_store.py#L251>all_fields_match</denchmark-link>\n (default) to true\n \t\t"}, "comments_16": {"comment_id": 17, "comment_author": "pselden", "commentT": "2020-10-06T01:46:21Z", "comment_text": "\n \t\tI was able to reproduce error with a simple test: <denchmark-link:https://github.com/tensorflow/tfx/pull/2606>#2606</denchmark-link>\n \n Working to file a fix now that the issue is more isolated.\n \t\t"}, "comments_17": {"comment_id": 18, "comment_author": "pselden", "commentT": "2020-10-06T01:49:54Z", "comment_text": "\n \t\tSeems fix is not possible due to option not being implemented in MLMD: <denchmark-link:https://github.com/google/ml-metadata/blob/1fceefd596e2ed7e98e629e7186e0f0b1fbace28/ml_metadata/metadata_store/metadata_store.cc#L248>https://github.com/google/ml-metadata/blob/1fceefd596e2ed7e98e629e7186e0f0b1fbace28/ml_metadata/metadata_store/metadata_store.cc#L248</denchmark-link>\n \n \t\t"}, "comments_18": {"comment_id": 19, "comment_author": "pselden", "commentT": "2020-10-06T01:52:17Z", "comment_text": "\n \t\tHere's the culprit: <denchmark-link:https://github.com/google/ml-metadata/blob/1fceefd596e2ed7e98e629e7186e0f0b1fbace28/ml_metadata/metadata_store/metadata_store.cc#L35>https://github.com/google/ml-metadata/blob/1fceefd596e2ed7e98e629e7186e0f0b1fbace28/ml_metadata/metadata_store/metadata_store.cc#L35</denchmark-link>\n  Seems it only allows to add fields. If registered fields are a superset of artifact then it will fail.\n So:\n \n (AB) -> (ABC) -  Works!\n (ABC) -> (AB) - Doesn't work!\n (ABC) -> (ABD) - Doesn't work!\n \n \t\t"}, "comments_19": {"comment_id": 20, "comment_author": "pselden", "commentT": "2020-10-06T10:41:57Z", "comment_text": "\n \t\tCC: <denchmark-link:https://github.com/hughmiao>@hughmiao</denchmark-link>\n \n \t\t"}, "comments_20": {"comment_id": 21, "comment_author": "pselden", "commentT": "2020-10-07T01:42:56Z", "comment_text": "\n \t\tFrom MLMD, as the instances (e.g., artifacts) of old types are stored, when updating users' type, its properties must be a superset of the properties of the stored type schema.  Currently we do not allow to delete properties or change existing property's\u00a0value type to ensure the data backward compatibility. (i.e., the new type schema can be used to parse the stored instances).\n To support type evolution properly, some discussions and caveats had in the past, e.g.,\n a) In MLMD, to allow the same types have versioned identifiers, so that they don't conflict (as there are multiple copies of the type schema stored) and we infer the compatibilities. This may be tricky for applications (TFX) for querying stored information, e.g., imaging building a cache resolution logic on the v0.21, v0.23, v0.24 runs, shall it respect the older tfx run or not, etc. For example, when building a UI, does it need to be aware of the differences of the type versions.\n AND / OR\n b) in TFX, it makes sure that the type evolutions can co-exist in two ways: older tfx can work with newer tfx types, and newer tfx can read older tfx instances. For example, here, when v0.21 saw 0.23 types, which is a superset, it considers it as future change is backward compatible, etc. Without an explicit rule, the tricky part is v0.21 does not possibly know that what kind of 0.23's future change will be and whether the superset is safe to proceed. For 0.23 to read 0.21, it will be good to capture the deprecated types, renamed types etc.\n As you can see, supporting this can go quite complicated. /cc <denchmark-link:https://github.com/charlesccychen>@charlesccychen</denchmark-link>\n   to add other comments.\n \n I think I agree with Paul and Gerard that we should aim to get support of multi-tenanted MLMD working.\n \n +1 to zhitaoli@'s comment that we should prioritize this and better support multi-tenanted MLMD instances.\n For now, as the 0.21.0 is released, to unblock the case, the shared mlmd instance must have compatible application level types. When upgrading tfx, please consider to use a new db to partition the different pipelines based on their tfx versions.\n For the short term solution, in the new release, supporting/using all_fields_match = True, which is quite tricky and undeterministic depending on the order of the type registration call.  Another thought is in tfx metadata.py always trying to explicitly read the stored artifact type of the same name and by pass the registration if it is a superset.\n /cc <denchmark-link:https://github.com/ruoyu90>@ruoyu90</denchmark-link>\n  to comment more.\n \t\t"}, "comments_21": {"comment_id": 22, "comment_author": "pselden", "commentT": "2020-10-07T02:24:01Z", "comment_text": "\n \t\tThanks for your thoughtful response!\n Would love to have an RFC or a similar discussion topic around issue exposed in a) and b). Not sure what's the best location for that though.\n We do have a system internally that allows us partition and have 2 version at the same time at this point. I guess my main issue was that this was not easy to debug (I think we can add documentation to error that is easier to understand) and we were caught by surprise as it was not surfaced in MLMD documentation or release notes (or it was not clear that it was there). We are adding internal safeguards to avoid this to happen again and rolling 0.24 to most pipelines. It's a bit difficult since any pipeline that runs 0.24 then can immediatly make the DB unusable for 0.22.1.\n Also, did you mean all_fields_match = False? And TFX layer solution also works imo. I can propose that one in the PR I linked here.\n \t\t"}, "comments_22": {"comment_id": 23, "comment_author": "pselden", "commentT": "2020-10-07T18:34:56Z", "comment_text": "\n \t\t\n did you mean all_fields_match = False? And TFX layer solution also works imo.\n \n Gerard: all_fields_match = False semantics is tricky when mixing tfx versions pipelines and register types concurrently. The behavior is undeterministic, i.e., 0.21 may overwrite 0.23, and vise versa.\n We probably needs a semantics of succeed_if_compatible, for the short term, my suggestion was putting the skipping logic (stored type is compatible) explicitly and skip the registration (call put_artifact_type) in the tfx layer when calling put_artifact_type.\n /cc <denchmark-link:https://github.com/ruoyu90>@ruoyu90</denchmark-link>\n  <denchmark-link:https://github.com/charlesccychen>@charlesccychen</denchmark-link>\n \n \t\t"}, "comments_23": {"comment_id": 24, "comment_author": "pselden", "commentT": "2020-10-07T21:37:40Z", "comment_text": "\n \t\tFair, succeed_if_compatible sounds good to me. I saw all_field_match as an equivalent to succeed_if_subset which is why I proposed this.\n Regarding what layer, I think adding it on MLMD is better long term (as more users may be able to benefit from this. for ex: we are actually looking into using MLMD to track more generic jobs and training, even outside of TFX). But not sure how easy to fix/timeframe would be for each.\n \t\t"}, "comments_24": {"comment_id": 25, "comment_author": "pselden", "commentT": "2020-10-08T18:10:14Z", "comment_text": "\n \t\tImplementing a succeed_if_compatible semantics can be done easily in tfx, i.e., catching the AlreadyExists error, and reuse the type_id in [1]. 0.23 will always succeed, while 0.21 goes to the fallback branch to reuse the new type.\n If this is a blocking issue, either change that line and use a locally built wheel or we can do a patch release to make the change to work for this case 0.21 with 0.23. wdyt?\n Agree that it will be good to have this semantics in mlmd to let it be used others in the long term, which requires a mlmd release, and change tfx to use that mode. I will work on this and update the usage of tfx at head for the next release.\n [1] \n \n \n tfx/tfx/orchestration/metadata.py\n \n \n          Line 183\n       in\n       7c4f240\n \n \n \n \n \n \n  type_id = self.store.put_artifact_type( \n \n \n \n \n \n \t\t"}, "comments_25": {"comment_id": 26, "comment_author": "pselden", "commentT": "2020-10-08T19:00:35Z", "comment_text": "\n \t\t\n If this is a blocking issue, either change that line and use a locally built wheel or we can do a patch release to make the change to work for this case 0.21 with 0.23. wdyt?\n \n A patch release for 0.21.x would be awesome and would solve my immediate problem.\n \t\t"}, "comments_26": {"comment_id": 27, "comment_author": "pselden", "commentT": "2020-10-08T19:29:58Z", "comment_text": "\n \t\tFor us a fix it forward works (aka fix it in MLMD for next release). As <denchmark-link:https://github.com/pselden>@pselden</denchmark-link>\n  mentions, it would be nice to have the patch release as well in case we need to revert pipelines to 0.22 as we continue migration to 0.23/0.24.\n \t\t"}, "comments_27": {"comment_id": 28, "comment_author": "pselden", "commentT": "2020-10-09T19:08:04Z", "comment_text": "\n \t\tsg. we are working on this and will do patch release for 0.21.x and 0.22.x.\n \t\t"}, "comments_28": {"comment_id": 29, "comment_author": "pselden", "commentT": "2021-01-08T20:54:09Z", "comment_text": "\n \t\tThis is working now.\n \t\t"}, "comments_29": {"comment_id": 30, "comment_author": "pselden", "commentT": "2021-01-08T20:54:10Z", "comment_text": "\n \t\tAre you satisfied with the resolution of your issue?\n <denchmark-link:https://docs.google.com/forms/d/e/1FAIpQLSfaP12TRhd9xSxjXZjcZFNXPGk4kc1-qMdv3gc6bEP90vY1ew/viewform?entry.85265664=Yes&entry.2137816233=https://github.com/tensorflow/tfx/issues/2506>Yes</denchmark-link>\n \n <denchmark-link:https://docs.google.com/forms/d/e/1FAIpQLSfaP12TRhd9xSxjXZjcZFNXPGk4kc1-qMdv3gc6bEP90vY1ew/viewform?entry.85265664=No&entry.2137816233=https://github.com/tensorflow/tfx/issues/2506>No</denchmark-link>\n \n \t\t"}}}, "commit": {"commit_id": "9a875331d4cc4966de870e13e70085baccb5d596", "commit_author": "tfx-team", "commitT": "2020-11-12 13:12:03-08:00", "commit_complexity": {"commit_NLOC": "0.0", "commit_CCN": "1.0", "commit_Nprams": "1.0"}, "changed_files": {"file_0": {"file_change_type": "MODIFY", "file_Nmethod": 0, "file_old_name": "RELEASE.md", "file_new_name": "RELEASE.md", "file_complexity": {"file_NLOC": "None", "file_CCN": "None", "file_NToken": "None"}, "hunks": {"hunk_0": {"Ismethod": 0, "added_lines": "77,78", "deleted_lines": null}}}, "file_1": {"file_change_type": "MODIFY", "file_Nmethod": 0, "file_old_name": "tfx\\orchestration\\metadata.py", "file_new_name": "tfx\\orchestration\\metadata.py", "file_complexity": {"file_NLOC": "982", "file_CCN": "42", "file_NToken": "4730"}, "hunks": {"hunk_0": {"Ismethod": 0, "added_lines": "183,186,187,188,189,190,191,193", "deleted_lines": "186"}}}, "file_2": {"file_change_type": "MODIFY", "file_Nmethod": 1, "file_old_name": "tfx\\orchestration\\metadata_test.py", "file_new_name": "tfx\\orchestration\\metadata_test.py", "file_complexity": {"file_NLOC": "852", "file_CCN": "19", "file_NToken": "3717"}, "hunks": {"hunk_0": {"Ismethod": 1, "added_lines": "148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201", "deleted_lines": null, "method_info": {"method_name": "testArtifactTypeRegistrationForwardCompatible", "method_params": "self", "method_startline": "148", "method_endline": "201", "method_complexity": {"method_NLOC": "48", "method_CCN": "1", "method_NToken": "143", "method_nesting_level": "1"}}}}}, "file_3": {"file_change_type": "MODIFY", "file_Nmethod": 0, "file_old_name": "tfx\\orchestration\\portable\\mlmd\\common_utils.py", "file_new_name": "tfx\\orchestration\\portable\\mlmd\\common_utils.py", "file_complexity": {"file_NLOC": "145", "file_CCN": "5", "file_NToken": "578"}, "hunks": {"hunk_0": {"Ismethod": 0, "added_lines": "162,163,164,165,166,167,168,169,170,171,174,176,177,178,179,180,181,182", "deleted_lines": "162,163,164,167,168,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185"}}}, "file_4": {"file_change_type": "MODIFY", "file_Nmethod": 1, "file_old_name": "tfx\\orchestration\\portable\\mlmd\\common_utils_test.py", "file_new_name": "tfx\\orchestration\\portable\\mlmd\\common_utils_test.py", "file_complexity": {"file_NLOC": "150", "file_CCN": "13", "file_NToken": "666"}, "hunks": {"hunk_0": {"Ismethod": 1, "added_lines": "185", "deleted_lines": "185", "method_info": {"method_name": "testRegisterTypeModifiedKey", "method_params": "self,metadata_type_class", "method_startline": "169", "method_endline": "187", "method_complexity": {"method_NLOC": "16", "method_CCN": "1", "method_NToken": "66", "method_nesting_level": "1"}}}}}}}}