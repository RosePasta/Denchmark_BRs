{"BR": {"BR_id": "3185", "BR_author": "VirajBagal", "BRopenT": "2020-08-26T05:19:53Z", "BRcloseT": "2020-09-01T13:17:53Z", "BR_text": {"BRsummary": "Value out of range (expected to be in range of [-1, 0], but got 1)", "BRdescription": "\n <denchmark-h:h2>Value out of range (expected to be in range of [-1, 0], but got 1)</denchmark-h>\n \n Exception in device=TPU:5: torch_xla/csrc/helpers.cpp:97 : Check failed: min_shape_dim <= dim && dim <= max_shape_dim\n Following is the stack trace when I am using all 8 TPU cores on Kaggle. The exact same code with\n \n sync_dist=False\n \n works completely fine on Kaggle GPU.\n \n Value out of range (expected to be in range of [-1, 0], but got 1)Exception in device=TPU:5: torch_xla/csrc/helpers.cpp:97 : Check failed: min_shape_dim <= dim && dim <= max_shape_dim\n *** Begin stack trace ***\n tensorflow::CurrentStackTrace()\n torch_xla::XlaHelpers::GetCanonicalDimensionIndex(long long, long long)\n torch_xla::XlaHelpers::MakeTransposePermutation(long long, long long, long long)\n torch_xla::XLATensor::transpose(torch_xla::XLATensor const&, long long, long long)\n torch_xla::AtenXlaType::t(at::Tensor const&)\n c10::impl::wrap_kernel_functor_unboxed_<c10::impl::detail::WrapFunctionIntoRuntimeFunctor_<at::Tensor ()(at::Tensor const&), at::Tensor, c10::guts::typelist::typelist<at::Tensor const&> >, at::Tensor (at::Tensor const&)>::call(c10::OperatorKernel, at::Tensor const&)\n at::t(at::Tensor const&)\n at::Tensor::t() const\n _PyMethodDef_RawFastCallKeywords\n _PyMethodDescr_FastCallKeywords\n _PyEval_EvalFrameDefault\n _PyFunction_FastCallKeywords\n _PyEval_EvalFrameDefault\n _PyFunction_FastCallKeywords\n _PyEval_EvalFrameDefault\n _PyFunction_FastCallKeywords\n _PyEval_EvalFrameDefault\n _PyFunction_FastCallKeywords\n _PyEval_EvalFrameDefault\n _PyEval_EvalCodeWithName\n _PyFunction_FastCallKeywords\n _PyEval_EvalFrameDefault\n _PyFunction_FastCallKeywords\n _PyEval_EvalFrameDefault\n _PyFunction_FastCallKeywords\n _PyEval_EvalFrameDefault\n _PyEval_EvalCodeWithName\n _PyFunction_FastCallDict\n _PyObject_Call_Prepend\n PyObject_Call\n _PyEval_EvalFrameDefault\n _PyFunction_FastCallKeywords\n _PyEval_EvalFrameDefault\n _PyFunction_FastCallDict\n _PyEval_EvalFrameDefault\n _PyFunction_FastCallDict\n _PyEval_EvalFrameDefault\n _PyFunction_FastCallKeywords\n _PyEval_EvalFrameDefault\n _PyFunction_FastCallKeywords\n _PyEval_EvalFrameDefault\n _PyFunction_FastCallKeywords\n _PyEval_EvalFrameDefault\n _PyFunction_FastCallDict\n _PyObject_Call_Prepend\n _PyObject_FastCallKeywords\n _PyEval_EvalFrameDefault\n _PyFunction_FastCallKeywords\n _PyEval_EvalFrameDefault\n _PyFunction_FastCallKeywords\n _PyEval_EvalFrameDefault\n _PyEval_EvalCodeWithName\n _PyFunction_FastCallKeywords\n _PyEval_EvalFrameDefault\n _PyEval_EvalCodeWithName\n _PyFunction_FastCallKeywords\n _PyEval_EvalFrameDefault\n _PyFunction_FastCallKeywords\n _PyEval_EvalFrameDefault\n _PyEval_EvalCodeWithName\n _PyFunction_FastCallDict\n _PyEval_EvalFrameDefault\n _PyEval_EvalCodeWithName\n _PyFunction_FastCallKeywords\n _PyEval_EvalFrameDefault\n _PyEval_EvalCodeWithName\n PyEval_EvalCodeEx\n PyEval_EvalCode\n _PyMethodDef_RawFastCallKeywords\n _PyCFunction_FastCallKeywords\n _PyEval_EvalFrameDefault\n _PyGen_Send\n _PyEval_EvalFrameDefault\n _PyGen_Send\n _PyEval_EvalFrameDefault\n _PyGen_Send\n _PyMethodDef_RawFastCallKeywords\n _PyMethodDescr_FastCallKeywords\n _PyEval_EvalFrameDefault\n _PyFunction_FastCallKeywords\n _PyEval_EvalFrameDefault\n _PyFunction_FastCallKeywords\n _PyEval_EvalFrameDefault\n _PyEval_EvalCodeWithName\n _PyFunction_FastCallDict\n _PyObject_Call_Prepend\n PyObject_Call\n _PyEval_EvalFrameDefault\n _PyEval_EvalCodeWithName\n _PyFunction_FastCallKeywords\n _PyEval_EvalFrameDefault\n _PyMethodDef_RawFastCallKeywords\n _PyCFunction_FastCallKeywords\n _PyEval_EvalFrameDefault\n _PyEval_EvalCodeWithName\n _PyFunction_FastCallKeywords\n _PyEval_EvalFrameDefault\n _PyMethodDef_RawFastCallKeywords\n _PyCFunction_FastCallKeywords\n _PyEval_EvalFrameDefault\n _PyEval_EvalCodeWithName\n _PyFunction_FastCallKeywords\n _PyEval_EvalFrameDefault\n _PyMethodDef_RawFastCallKeywords\n _PyCFunction_FastCallKeywords\n _PyEval_EvalFrameDefault\n _PyEval_EvalCodeWithName\n _PyFunction_FastCallDict\n _PyObject_Call_Prepend\n PyObject_Call\n _PyEval_EvalFrameDefault\n _PyGen_Send\n _PyMethodDef_RawFastCallKeywords\n _PyMethodDescr_FastCallKeywords\n _PyEval_EvalFrameDefault\n _PyFunction_FastCallKeywords\n _PyEval_EvalFrameDefault\n _PyFunction_FastCallDict\n *** End stack trace ***\n \n Here is the code for my LightningModule\n class GraphAEStage1(pl.LightningModule):\n   def __init__(self, config):\n     super(GraphAEStage1, self).__init__()\n     max_deg = config['poc_max_degree']\n     input_dim = config['input_dim']\n     hidden_feat = config['hidden_feat_dim']\n     layerid = config['layerid']\n     self.lr = config['lr']\n   \n     self.encoder = GraphEncoderStage1(max_deg, input_dim, hidden_feat[layerid])\n     self.decoder = GraphDecoderStage1(max_deg, input_dim, hidden_feat[layerid])\n     \n     self.encoder.apply(self.init_weights)\n     \n     self.crit = torch.nn.L1Loss()\n     self.node_mae = MAE()\n     self.adj_mae = MAE()\n     \n     self.decoder.self_linear.weight = nn.Parameter(self.encoder.self_linear.weight.permute(1,0))\n     for d in range(config['poc_max_degree']):\n         self.decoder.neigh_linear[d].weight = nn.Parameter(self.encoder.neigh_linear[d].weight.permute(1,0))\n \n   def training_step(self, batch, batch_idx):\n     loss, tf_node, _, _, _ = self.shared_step(batch)\n     result = pl.TrainResult(minimize=loss)\n     result.log('train_loss', loss, prog_bar = True, logger = True, on_step = False, on_epoch = True, sync_dist = True)\n     return result\n \n   def validation_step(self, batch, batch_idx):\n     loss, tf_node, recon_node, val_node_mae, val_adj_mae = self.shared_step(batch)\n     \n     logs = {'val_loss': loss, 'node_mae': val_node_mae, 'adj_mae': val_adj_mae}\n     result = pl.EvalResult(checkpoint_on = loss)\n     result.log_dict(logs, prog_bar = True, logger = True, on_step = False, on_epoch = True, sync_dist = True)\n     \n     return result               \n \n   def shared_step(self, batch):\n     node, adj, deg, mask = batch\n     tf_node, avg_adj = self.encoder(node, adj, deg, mask)\n     recon_node, recon_adj = self.decoder(tf_node, deg)\n \n     \n     node_loss = self.criterion(recon_node, node)\n     adj_loss = self.criterion(recon_adj, avg_adj)\n     loss = node_loss + adj_loss\n     \n     node_mae = self.node_mae(node, recon_node)\n     adj_mae = self.adj_mae(recon_adj, avg_adj)\n     \n     return loss, tf_node, recon_node, node_mae, adj_mae\n \n   def configure_optimizers(self):\n     optimizer = torch.optim.Adam(self.parameters(), lr=self.lr)\n     return optimizer\n \n   def criterion(self, output, target):\n     return self.crit(output, target)\n \n   def init_weights(self, m):\n     if type(m) == nn.Linear:\n         torch.nn.init.xavier_uniform(m.weight)\n         m.bias.data.fill_(0.00)  \n There are similar issues reported on PyTorch XLA repo, but many of them were using CrossEntropyLoss. I am not using CrossEntropyLoss here.\n \t"}, "comments": {"comments_0": {"comment_id": 1, "comment_author": "VirajBagal", "commentT": "2020-08-26T15:24:23Z", "comment_text": "\n \t\t<denchmark-link:https://github.com/lezwon>@lezwon</denchmark-link>\n  <denchmark-link:https://github.com/Borda>@Borda</denchmark-link>\n  mind taking a look at this?\n \t\t"}, "comments_1": {"comment_id": 2, "comment_author": "VirajBagal", "commentT": "2020-08-26T15:41:59Z", "comment_text": "\n \t\t<denchmark-link:https://github.com/VirajBagal>@VirajBagal</denchmark-link>\n  could you share the notebook?\n \t\t"}, "comments_2": {"comment_id": 3, "comment_author": "VirajBagal", "commentT": "2020-08-26T16:32:46Z", "comment_text": "\n \t\t<denchmark-link:https://github.com/lezwon>@lezwon</denchmark-link>\n  Due to some privacy issues, I can't share it publicly here. I have shared it with you on Kaggle. Please check the \"Shared With You\" tab on Kaggle.\n \t\t"}, "comments_3": {"comment_id": 4, "comment_author": "VirajBagal", "commentT": "2020-08-26T16:46:24Z", "comment_text": "\n \t\tSure.. Will do \ud83d\ude0a\ud83d\udc4d\n \t\t"}, "comments_4": {"comment_id": 5, "comment_author": "VirajBagal", "commentT": "2020-08-28T17:42:29Z", "comment_text": "\n \t\tIt seems xla does not support the  operation on 1-dimensional tensors. <denchmark-link:https://github.com/zcain117>@zcain117</denchmark-link>\n  could you help us out?  seems to be throwing the error mentioned when called. PyTorch usually returns 1d tensors as is.\n \t\t"}}}, "commit": {"commit_id": "3910ad033074367f6abfe0001562db725a75cb73", "commit_author": "Lezwon Castelino", "commitT": "2020-09-01 09:17:52-04:00", "commit_complexity": {"commit_NLOC": "0.07407407407407407", "commit_CCN": "1.0", "commit_Nprams": "1.0"}, "changed_files": {"file_0": {"file_change_type": "MODIFY", "file_Nmethod": 1, "file_old_name": "pytorch_lightning\\callbacks\\early_stopping.py", "file_new_name": "pytorch_lightning\\callbacks\\early_stopping.py", "file_complexity": {"file_NLOC": "180", "file_CCN": "36", "file_NToken": "966"}, "hunks": {"hunk_0": {"Ismethod": 1, "added_lines": "232", "deleted_lines": "232", "method_info": {"method_name": "_stop_distributed_training", "method_params": "self,trainer,pl_module", "method_startline": "221", "method_endline": "234", "method_complexity": {"method_NLOC": "11", "method_CCN": "4", "method_NToken": "133", "method_nesting_level": "1"}}}}}, "file_1": {"file_change_type": "MODIFY", "file_Nmethod": 2, "file_old_name": "pytorch_lightning\\core\\step_result.py", "file_new_name": "pytorch_lightning\\core\\step_result.py", "file_complexity": {"file_NLOC": "511", "file_CCN": "129", "file_NToken": "3308"}, "hunks": {"hunk_0": {"Ismethod": 1, "added_lines": "848", "deleted_lines": "846", "method_info": {"method_name": "weighted_mean", "method_params": "result,weights", "method_startline": "846", "method_endline": "850", "method_complexity": {"method_NLOC": "5", "method_CCN": "1", "method_NToken": "58", "method_nesting_level": "0"}}}, "hunk_1": {"Ismethod": 1, "added_lines": "302,303", "deleted_lines": null, "method_info": {"method_name": "__copy__", "method_params": "self", "method_startline": "299", "method_endline": "305", "method_complexity": {"method_NLOC": "7", "method_CCN": "3", "method_NToken": "52", "method_nesting_level": "1"}}}}}, "file_2": {"file_change_type": "MODIFY", "file_Nmethod": 1, "file_old_name": "tests\\models\\test_tpu.py", "file_new_name": "tests\\models\\test_tpu.py", "file_complexity": {"file_NLOC": "203", "file_CCN": "15", "file_NToken": "1297"}, "hunks": {"hunk_0": {"Ismethod": 1, "added_lines": "248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276", "deleted_lines": null, "method_info": {"method_name": "test_result_obj_on_tpu", "method_params": "tmpdir", "method_startline": "248", "method_endline": "276", "method_complexity": {"method_NLOC": "25", "method_CCN": "1", "method_NToken": "127", "method_nesting_level": "0"}}}}}}}}