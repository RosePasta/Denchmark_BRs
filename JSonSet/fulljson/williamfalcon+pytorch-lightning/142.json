{"BR": {"BR_id": "142", "BR_author": "sebftw", "BRopenT": "2019-08-18T23:07:54Z", "BRcloseT": "2019-08-23T12:22:12Z", "BR_text": {"BRsummary": "AttributeError: 'xxx' object has no attribute 'tng_dataloader' continued...", "BRdescription": "\n This is the same issue as mentioned in <denchmark-link:https://github.com/PyTorchLightning/pytorch-lightning/issues/125>#125</denchmark-link>\n .\n Describe the bug\n Whenever a @property raises an AttributeError, it will be looked up in __getattr__ (if defined), and then the original error message is lost. And LightingModule inherits __getattr__ from torch.nn.Module.\n This makes debugging difficult as you lose line number and you get an error message that is misleading - the attribute exists! Look at the minimal example in the next section to see what I mean.\n To Reproduce\n <denchmark-code>import torch\n \n class Foo(torch.nn.Module):\n     @property\n     def bar(self):\n         return torch.does_not_exist  # Raises an AttributeError.\n \n Foo().bar\n </denchmark-code>\n \n The output produced:\n <denchmark-code>Traceback (most recent call last):\n   File \"C:/minimal.py\", line 8, in <module>\n     Foo().bar\n   File \"C:\\Program Files\\Python37\\lib\\site-packages\\torch\\nn\\modules\\module.py\", line 591, in __getattr__\n     type(self).__name__, name))\n AttributeError: 'Foo' object has no attribute 'bar'\n </denchmark-code>\n \n The trace says the  attribute does not exist, but it does. It is the  attribute that is nonexistent. Now if you look in the stack trace in <denchmark-link:https://github.com/PyTorchLightning/pytorch-lightning/issues/125>#125</denchmark-link>\n  it is even worse.\n Expected behavior\n One would expect the stack trace to be\n <denchmark-code>Traceback (most recent call last):\n   File \"C:/minimal.py\", line 7, in bar\n     return torch.does_not_exist  # Raises an AttributeError.\n AttributeError: module 'torch' has no attribute 'does_not_exist'\n </denchmark-code>\n \n I think it could be very useful to add try...catch to the pl.data_loader.\n One could also make a pl.attribute decorator that users (and pl.data_loader) can use, and document its use case in the docs. It should simply extend the usual @attribute with a try...catch.\n An example of a more desirable stack trace\n <denchmark-code>Traceback (most recent call last):\n   File \"C:/minimal.py\", line 7, in bar\n     return torch.does_not_exist  # Raises an AttributeError.\n AttributeError: module 'torch' has no attribute 'does_not_exist'\n \n The above exception was the direct cause of the following exception:\n \n Traceback (most recent call last):\n   File \"C:/minimal.py\", line 11, in <module>\n     Foo().bar\n   File \"C:/minimal.py\", line 9, in bar\n     raise RuntimeError('An AttributeError was encountered in Foo.bar.') from e\n RuntimeError: An AttributeError was encountered in Foo.bar.\n </denchmark-code>\n \n In this case the error is correctly shown to be at line 7.\n This stack trace is achieved by replacing line 7 with:\n <denchmark-code>try:\n     return torch.does_not_exist  # Raises an AttributeError.\n except AttributeError as e:\n     raise RuntimeError('An AttributeError was encountered in Foo.bar.') from e\n </denchmark-code>\n \n \n See also the discussion in <denchmark-link:https://github.com/pytorch/pytorch/issues/13981>pytorch/pytorch#13981</denchmark-link>\n  of the problem. It seems to be a <denchmark-link:https://bugs.python.org/issue24983>troublesome</denchmark-link>\n  design decision of the language that will be hard to get around.\n Do you think @pl.attribute is a good idea?\n There seem to be no other way around the issue if we must use nn.Module and @attribute.\n \t"}, "comments": {"comments_0": {"comment_id": 1, "comment_author": "sebftw", "commentT": "2019-08-18T23:10:59Z", "comment_text": "\n \t\t<denchmark-link:https://github.com/sebftw>@sebftw</denchmark-link>\n  read my mind haha. was about to add this bug! want to give it a shot?\n \t\t"}, "comments_1": {"comment_id": 2, "comment_author": "sebftw", "commentT": "2019-08-18T23:12:15Z", "comment_text": "\n \t\t<denchmark-link:https://github.com/sebftw>@sebftw</denchmark-link>\n  it probably has to catch all exceptions though. the attribute doesn't exist is hiding whatever issue the dataloader code has (ie: user error), so we want to forward that to the user via \n \t\t"}, "comments_2": {"comment_id": 3, "comment_author": "sebftw", "commentT": "2019-08-18T23:13:58Z", "comment_text": "\n \t\t<denchmark-link:https://github.com/williamFalcon>@williamFalcon</denchmark-link>\n  Yeah. I can try and look into it tomorrow. I think we only have to catch AttributeError as other exceptions will produce a normal stack trace.\n \t\t"}, "comments_3": {"comment_id": 4, "comment_author": "sebftw", "commentT": "2019-08-19T15:20:51Z", "comment_text": "\n \t\tI have made a sketch of the implementation and how to test it.\n <denchmark-code>import torch.nn as nn\n import pytest\n \n # ------------------------------------------------------------------------\n # IMPLEMENTATION\n # ------------------------------------------------------------------------\n \n errormessage = 'An AttributeError was encountered: '\n def safe_property(fn):\n     @property\n     def wrapper(*args, **kwargs):\n         try:\n             return fn(*args, **kwargs)\n         except AttributeError as e:\n             raise RuntimeError(errormessage + str(e)) from e\n     return wrapper\n \n \n # ------------------------------------------------------------------------\n # TESTS\n # ------------------------------------------------------------------------\n \n returnexample = 1\n exceptionexample = ZeroDivisionError\n informative_error_message = \"module 'torch.nn' has no attribute 'does_not_exist'\"\n \n class PropertyTest(nn.Module): # Note it is an nn.Module.\n     @property\n     def test_property(self):\n         return returnexample\n \n     @safe_property\n     def test_safe_property(self):\n         return returnexample\n \n     @property\n     def test_property_attributeerror(self):\n         raise AttributeError(informative_error_message)\n         # ^ Equivalent to: return nn.does_not_exist, which will also raise AttributeError.\n \n     @safe_property\n     def test_safe_property_attributeerror(self):\n         raise AttributeError(informative_error_message)\n \n     @property\n     def test_property_error(self):\n         raise exceptionexample(informative_error_message)\n \n     @safe_property\n     def test_safe_property_error(self):\n         raise exceptionexample(informative_error_message)\n \n \n def test_same_return():\n     testobj = PropertyTest()\n     # Test that they both return the same.\n     assert testobj.test_property == testobj.test_safe_property\n \n def test_same_interface():\n     # This is a design decision we haven't discussed.\n     # Only include if we find it important that the safe property doesn't do anything more\n     #  than a normal property, i.e. has the same interface and all.\n     assert dir(PropertyTest.test_property) == dir(PropertyTest.test_property)\n     assert isinstance(PropertyTest.test_safe_property, type(PropertyTest.test_property))  # <class 'property'>\n \n def test_error():\n     # In this we test that normal exceptions are raised normally.\n     testobj = PropertyTest()\n     # We expect an exception to be raised and propagated if it is of any type other than AttributeError.\n     with pytest.raises(exceptionexample) as exc_info:\n         testobj.test_property_error\n \n     # This checks that in this case the exception and message matches that of a normal property.\n     with pytest.raises(exc_info.type, match=exc_info.value.args[0]):\n         testobj.test_safe_property_error\n \n def test_attributeerror():\n     # In this we test that AttributeErrors are better handled by the safe_property.\n     testobj = PropertyTest()\n     # In the case of an AttributeError, we expect an uninformative error message from nn.Module.\n     with pytest.raises(AttributeError) as exc_info:\n         testobj.test_property_attributeerror\n \n     # Check that PyTorch has indeed removed the informative message completely.\n     # This is the reason we are making a safe_property, so if this test fails we may not even\n     #  need the decorator we are testing here.\n     assert informative_error_message not in exc_info.value.args[0]\n \n     # This tests that safe_attribute raises an exception still containing the\n     #  informative error message.\n     with pytest.raises(BaseException, match=informative_error_message):\n         testobj.test_safe_property_attributeerror\n \n if __name__ == '__main__':\n     pytest.main([__file__])\n </denchmark-code>\n \n With this code, accessing test_safe_property_attributeerror will raise a RuntimeError with the message An AttributeError was encountered: module 'torch.nn' has no attribute 'does_not_exist'.\n I am not sure how the tests are structured - I am new to using pytest - but I'll make a pull request for the safe property now.\n \t\t"}, "comments_4": {"comment_id": 5, "comment_author": "sebftw", "commentT": "2019-08-19T19:05:38Z", "comment_text": "\n \t\t<denchmark-link:https://github.com/sebftw>@sebftw</denchmark-link>\n  let's do this as a simple try catch in the dataloader decorator. A principle of lightning is to give users less to remember.\n \t\t"}, "comments_5": {"comment_id": 6, "comment_author": "sebftw", "commentT": "2019-08-19T22:12:36Z", "comment_text": "\n \t\tGood idea\n \t\t"}, "comments_6": {"comment_id": 7, "comment_author": "sebftw", "commentT": "2019-08-21T14:37:20Z", "comment_text": "\n \t\t<denchmark-link:https://github.com/sebftw>@sebftw</denchmark-link>\n  any updates on this?\n \t\t"}, "comments_7": {"comment_id": 8, "comment_author": "sebftw", "commentT": "2019-08-22T12:53:19Z", "comment_text": "\n \t\t<denchmark-link:https://github.com/williamFalcon>@williamFalcon</denchmark-link>\n  I made a PR. <denchmark-link:https://github.com/PyTorchLightning/pytorch-lightning/pull/161>#161</denchmark-link>\n \n \t\t"}, "comments_8": {"comment_id": 9, "comment_author": "sebftw", "commentT": "2019-08-23T12:22:12Z", "comment_text": "\n \t\t<denchmark-link:https://github.com/sebftw>@sebftw</denchmark-link>\n  thanks for the PR! merged\n \t\t"}, "comments_9": {"comment_id": 10, "comment_author": "sebftw", "commentT": "2019-08-30T09:06:28Z", "comment_text": "\n \t\t<denchmark-link:https://github.com/williamFalcon>@williamFalcon</denchmark-link>\n  <denchmark-link:https://github.com/sebftw>@sebftw</denchmark-link>\n  Does it only fix the suppresion of  inside the dataloader and not the other user errors?\n \t\t"}, "comments_10": {"comment_id": 11, "comment_author": "sebftw", "commentT": "2019-08-30T09:44:01Z", "comment_text": "\n \t\t<denchmark-link:https://github.com/metrofun>@metrofun</denchmark-link>\n  Yes\n \t\t"}, "comments_11": {"comment_id": 12, "comment_author": "sebftw", "commentT": "2019-08-30T10:12:58Z", "comment_text": "\n \t\tUnless I misunderstood the context, wouldn't it be more reasonable to surface any kind of errors from the user defined code, not just the AttributeError?\n \t\t"}, "comments_12": {"comment_id": 13, "comment_author": "sebftw", "commentT": "2019-08-31T12:51:23Z", "comment_text": "\n \t\t<denchmark-link:https://github.com/metrofun>@metrofun</denchmark-link>\n  Other exceptions are not supressed, so they will surface as normal. It is just  which is an odd case, so we catch it and re-raise it as a  as our fix.\n \t\t"}, "comments_13": {"comment_id": 14, "comment_author": "sebftw", "commentT": "2019-08-31T14:32:55Z", "comment_text": "\n \t\t@sebtfw Oh, I see, thanks for the explanation\n \t\t"}}}, "commit": {"commit_id": "b31539f62e60e1ad370214e05003c214298d2431", "commit_author": "Sebastian Pr\u00e6sius", "commitT": "2019-08-23 08:21:39-04:00", "commit_complexity": {"commit_NLOC": "1.0", "commit_CCN": "1.0", "commit_Nprams": "1.0"}, "changed_files": {"file_0": {"file_change_type": "MODIFY", "file_Nmethod": 2, "file_old_name": "pytorch_lightning\\root_module\\decorators.py", "file_new_name": "pytorch_lightning\\root_module\\decorators.py", "file_complexity": {"file_NLOC": "14", "file_CCN": "4", "file_NToken": "72"}, "hunks": {"hunk_0": {"Ismethod": 1, "added_lines": "13,14,15,16,17,18,19,20,21,22", "deleted_lines": "13,14,15", "method_info": {"method_name": "data_loader", "method_params": "fn", "method_startline": "2", "method_endline": "24", "method_complexity": {"method_NLOC": "5", "method_CCN": "1", "method_NToken": "19", "method_nesting_level": "0"}}}, "hunk_1": {"Ismethod": 1, "added_lines": "13,14,15,16,17,18,19,20,21,22", "deleted_lines": "13,14,15", "method_info": {"method_name": "data_loader._data_loader", "method_params": "self", "method_startline": "12", "method_endline": "22", "method_complexity": {"method_NLOC": "10", "method_CCN": "3", "method_NToken": "53", "method_nesting_level": "1"}}}}}}}}