{"BR": {"BR_id": "8176", "BR_author": "rkooo567", "BRopenT": "2020-04-25T05:25:54Z", "BRcloseT": "2020-04-25T16:32:39Z", "BR_text": {"BRsummary": "Ray async api is not working with uvloop.", "BRdescription": "\n <denchmark-h:h3>What is the problem?</denchmark-h>\n \n Current Ray async api uses asyncio event loop's internal attribute to identify if the loop is running in the current current thread.\n     loop = asyncio.get_event_loop()\n     if loop.is_running():\n         if loop._thread_id != threading.get_ident():\n             # If the loop is runing outside current thread, we actually need\n             # to do this to make sure the context is initialized.\n             asyncio.run_coroutine_threadsafe(_async_init(), loop=loop)\n This causes a problem when we uses Ray APIs inside Fast API because Fast API uses uvloop as its main event loop, and uvloop doesn't have _thread_id attribute.\n <denchmark-link:https://github.com/simon-mo>@simon-mo</denchmark-link>\n  Any good idea to fix this? It doesn't seem to be trivial. What about we do async_init() whenever asyncio loop is created in a different thread instead of checking if the event loop's thread id? I assume the only use case where asyncio loop is defined in a different thread is only inside async actor?\n <denchmark-h:h3>Reproduction (REQUIRED)</denchmark-h>\n \n Please provide a script that can be run to reproduce the issue. The script should have no external library dependencies (i.e., use fake or mock data / environments):\n import time\n import asyncio \n \u200b\n import ray\n import psutil\n from fastapi import FastAPI, APIRouter\n \u200b\n \u200b\n app = FastAPI(\n     title=\"API template\",\n     description=\"Template to build upon for API serving and distributed computation\",\n     version=\"0.1.0\",\n     openapi_url=\"/openapi.json\",\n     docs_url=\"/docs\",\n )\n \u200b\n @app.on_event(\"startup\")\n def startup_event():\n     ray.init(num_cpus=2)\n \u200b\n \u200b\n \u200b\n @app.on_event(\"shutdown\")\n def shutdown_event():\n     ray.shutdown()\n \u200b\n \u200b\n @app.get('/async')\n async def non_seq_async_process():\n     \"\"\"\n     async distributed execution\n     \"\"\"\n     @ray.remote\n     def slow_function(i):\n         time.sleep(i)\n         return i\n \u200b\n     start_time = time.time()\n \u200b\n     # result_ids = []\n     # for i in range(10, 60, 10):\n     #     result_ids.append(slow_function.remote(i))\n     \n     # results = ray.get(result_ids)\n \u200b\n     results = await asyncio.wait([slow_function.remote(i) for i in range(10, 60, 10)])\n \u200b\n     \n     duration = time.time() - start_time\n     out = \"Executing the for loop took {:.3f} seconds.\\n\".format(duration)\n     out += f\"The results are: {results}\\n\"\n If we cannot run your script, we cannot fix your issue.\n \n  I have verified my script runs in a clean environment and reproduces the issue.\n  I have verified the issue also occurs with the latest wheels.\n \n \t"}, "comments": {"comments_0": {"comment_id": 1, "comment_author": "rkooo567", "commentT": "2020-04-25T09:38:05Z", "comment_text": "\n \t\tSounds promising!\n \t\t"}}}, "commit": {"commit_id": "13c14eac076c81227a96e24f749392f5b75aa2ce", "commit_author": "Simon Mo", "commitT": "2020-04-25 09:32:38-07:00", "commit_complexity": {"commit_NLOC": "0.0", "commit_CCN": "0.0", "commit_Nprams": "0.0"}, "changed_files": {"file_0": {"file_change_type": "MODIFY", "file_Nmethod": 0, "file_old_name": "python\\ray\\_raylet.pyx", "file_new_name": "python\\ray\\_raylet.pyx", "file_complexity": {"file_NLOC": "None", "file_CCN": "None", "file_NToken": "None"}, "hunks": {"hunk_0": {"Ismethod": 0, "added_lines": "1145,1146", "deleted_lines": "1145,1146"}}}, "file_1": {"file_change_type": "MODIFY", "file_Nmethod": 2, "file_old_name": "python\\ray\\experimental\\async_api.py", "file_new_name": "python\\ray\\experimental\\async_api.py", "file_complexity": {"file_NLOC": "23", "file_CCN": "6", "file_NToken": "122"}, "hunks": {"hunk_0": {"Ismethod": 1, "added_lines": "13", "deleted_lines": "13", "method_info": {"method_name": "_async_init", "method_params": "", "method_startline": "13", "method_endline": "20", "method_complexity": {"method_NLOC": "8", "method_CCN": "2", "method_NToken": "47", "method_nesting_level": "0"}}}, "hunk_1": {"Ismethod": 1, "added_lines": "10,11,12,13", "deleted_lines": "13", "method_info": {"method_name": "init", "method_params": "", "method_startline": "10", "method_endline": "20", "method_complexity": {"method_NLOC": "9", "method_CCN": "2", "method_NToken": "56", "method_nesting_level": "0"}}}}}, "file_2": {"file_change_type": "MODIFY", "file_Nmethod": 1, "file_old_name": "python\\ray\\tests\\test_asyncio.py", "file_new_name": "python\\ray\\tests\\test_asyncio.py", "file_complexity": {"file_NLOC": "129", "file_CCN": "29", "file_NToken": "920"}, "hunks": {"hunk_0": {"Ismethod": 1, "added_lines": "116,117", "deleted_lines": "116,117", "method_info": {"method_name": "test_asyncio_get", "method_params": "ray_start_regular_shared,event_loop", "method_startline": "110", "method_endline": "158", "method_complexity": {"method_NLOC": "27", "method_CCN": "1", "method_NToken": "183", "method_nesting_level": "0"}}}}}}}}