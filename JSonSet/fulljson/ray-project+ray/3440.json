{"BR": {"BR_id": "3440", "BR_author": "raulchen", "BRopenT": "2018-11-30T03:44:40Z", "BRcloseT": "2020-03-04T00:51:27Z", "BR_text": {"BRsummary": "[bug] Actor handle cannot be handled twice", "BRdescription": "\n Script to reproduce:\n <denchmark-code>ray.init()\n \n @ray.remote\n class Foo(object):\n     def method(self):\n \tpass\n \n f = Foo.remote()\n ray.get(f.method.remote())\n f1 = ray.worker.pickle.loads(ray.worker.pickle.dumps(f))\n ray.get(f1.method.remote())\n f2 = ray.worker.pickle.loads(ray.worker.pickle.dumps(f1))\n ray.get(f2.method.remote())\n </denchmark-code>\n \n Right now, the above script will fail, because when we pickle and unpickle f1 to get f2. f1._ray_actor_handle_id is None. Then this line will fail: \n \n \n ray/python/ray/actor.py\n \n \n          Line 756\n       in\n       07d8cbf\n \n \n \n \n \n \n  state[\"previous_actor_handle_id\"])) \n \n \n \n \n .\n However, if it's also wrong to simply change that line to previous_actor_handle_id=ray.ObjectID(state[\"previous_actor_handle_id\"])) if state[\"previous_actor_handle_id\"] else None. Because then f2's previous_actor_handle_id will be None and it will be considered as the original handle.\n Also, If I let f2 share f1's previous_actor_handle_id, this script still doesn't work. because f1.method.remote() and f2.method.remote() will use the same handle id (because of compute_actor_handle_id_non_forked) and counter to submit task. The latter task will be dropped by raylet, because raylet thinks it's a duplicate task submission.\n <denchmark-link:https://github.com/robertnishihara>@robertnishihara</denchmark-link>\n  <denchmark-link:https://github.com/stephanie-wang>@stephanie-wang</denchmark-link>\n  what do you think is the best way to fix this issue?\n \t"}, "comments": {"comments_0": {"comment_id": 1, "comment_author": "raulchen", "commentT": "2018-11-30T18:19:16Z", "comment_text": "\n \t\tRelated to <denchmark-link:https://github.com/ray-project/ray/issues/2115>#2115</denchmark-link>\n .\n This is a bit tricky. Actor handles are a bit brittle currently in the way they can be used and passed around.\n \t\t"}, "comments_1": {"comment_id": 2, "comment_author": "raulchen", "commentT": "2018-12-20T03:17:44Z", "comment_text": "\n \t\tIn <denchmark-link:https://github.com/ray-project/ray/pull/3560>#3560</denchmark-link>\n , I'm changing this to always set an actor handle ID, so we no longer store .\n How does the following solution sound?\n \n The original handle has num_forks = 0, handle_id = nil.\n If the handle is passed into another task, then we do handle.num_forks += 1 and store the new handle ID as handle_id' = hash(handle.handle_id || num_forks). When the handle is unpickled as part of the task argument, it uses handle_id' as its handle ID directly.\n If the handle is pickled, then we do handle.num_forks += 1 and store the new handle ID as handle_id' = hash(handle.handle_id || num_forks). When the handle is manually unpickled, it takes the stored value and hashes it with the current task ID, so its ID will be hash(handle_id' || worker.current_task_id).\n \n \t\t"}, "comments_2": {"comment_id": 3, "comment_author": "raulchen", "commentT": "2018-12-21T08:37:16Z", "comment_text": "\n \t\t<denchmark-link:https://github.com/stephanie-wang>@stephanie-wang</denchmark-link>\n  sounds good to me.\n It looks like that in <denchmark-link:https://github.com/ray-project/ray/pull/3560>#3560</denchmark-link>\n , you change the code to generate a permanent handle id when the handle is unpickled. So this issue should be easy to fix.\n Previously, the handle will be computed dynamically every time when we submit a task. <denchmark-link:https://github.com/robertnishihara>@robertnishihara</denchmark-link>\n  commented with a counter example in that PR, but I didn't understand that example. I also left a comment there.\n \t\t"}, "comments_3": {"comment_id": 4, "comment_author": "raulchen", "commentT": "2020-03-04T00:51:33Z", "comment_text": "\n \t\tNo longer relevant.\n \t\t"}}}, "commit": {"commit_id": "34bab6291c78ed064fe50917aa29ed26da4241df", "commit_author": "Stephanie Wang", "commitT": "2018-12-20 16:37:21-08:00", "commit_complexity": {"commit_NLOC": "1.0", "commit_CCN": "1.0", "commit_Nprams": "1.0"}, "changed_files": {"file_0": {"file_change_type": "MODIFY", "file_Nmethod": 6, "file_old_name": "python\\ray\\actor.py", "file_new_name": "python\\ray\\actor.py", "file_complexity": {"file_NLOC": "522", "file_CCN": "59", "file_NToken": "2673"}, "hunks": {"hunk_0": {"Ismethod": 1, "added_lines": "720,722,723,724,725,726,727,728,729,730,731,732,733,734,753", "deleted_lines": "714,717,726,727,748,749,750,752", "method_info": {"method_name": "_deserialization_helper", "method_params": "self,state,ray_forking", "method_startline": "708", "method_endline": "753", "method_complexity": {"method_NLOC": "23", "method_CCN": "4", "method_NToken": "162", "method_nesting_level": "1"}}}, "hunk_1": {"Ismethod": 1, "added_lines": "501", "deleted_lines": "492,493,494,495", "method_info": {"method_name": "__init__", "method_params": "self,actor_id,module_name,class_name,actor_cursor,actor_method_names,method_signatures,method_num_return_vals,actor_creation_dummy_object_id,actor_method_cpus,actor_driver_id,actor_handle_id", "method_startline": "490", "method_endline": "501", "method_complexity": {"method_NLOC": "12", "method_CCN": "1", "method_NToken": "29", "method_nesting_level": "1"}}}, "hunk_2": {"Ismethod": 1, "added_lines": "678,679,680,681,682,683,686,694", "deleted_lines": null, "method_info": {"method_name": "_serialization_helper", "method_params": "self,ray_forking", "method_startline": "668", "method_endline": "706", "method_complexity": {"method_NLOC": "26", "method_CCN": "5", "method_NToken": "149", "method_nesting_level": "1"}}}, "hunk_3": {"Ismethod": 1, "added_lines": "47,62", "deleted_lines": "47,48,62,64,65,71", "method_info": {"method_name": "compute_actor_handle_id_non_forked", "method_params": "actor_handle_id,current_task_id", "method_startline": "47", "method_endline": "72", "method_complexity": {"method_NLOC": "7", "method_CCN": "1", "method_NToken": "58", "method_nesting_level": "0"}}}, "hunk_4": {"Ismethod": 1, "added_lines": "501,502,503,506", "deleted_lines": "503,510,511", "method_info": {"method_name": "__init__", "method_params": "self,actor_id,module_name,class_name,actor_cursor,actor_counter,actor_method_names,method_signatures,method_num_return_vals,actor_creation_dummy_object_id,actor_method_cpus,actor_driver_id,actor_handle_id,previous_actor_handle_id", "method_startline": "498", "method_endline": "511", "method_complexity": {"method_NLOC": "14", "method_CCN": "1", "method_NToken": "35", "method_nesting_level": "1"}}}, "hunk_5": {"Ismethod": 1, "added_lines": "47", "deleted_lines": "47,48", "method_info": {"method_name": "compute_actor_handle_id_non_forked", "method_params": "actor_id,actor_handle_id,current_task_id", "method_startline": "47", "method_endline": "48", "method_complexity": {"method_NLOC": "2", "method_CCN": "1", "method_NToken": "9", "method_nesting_level": "0"}}}}}}}}