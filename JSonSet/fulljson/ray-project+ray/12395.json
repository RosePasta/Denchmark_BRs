{"BR": {"BR_id": "12395", "BR_author": "TanjaBayer", "BRopenT": "2020-11-25T09:28:20Z", "BRcloseT": "2020-12-14T18:38:25Z", "BR_text": {"BRsummary": "[serve] Actor Ram size increases when sending large data", "BRdescription": "\n <denchmark-h:h3>What is the problem?</denchmark-h>\n \n When sending video data (binary data and numpy arrays) to a ray serve endpoint the ram size of that worker encreases on each call.\n <denchmark-link:https://user-images.githubusercontent.com/30770185/100204164-d16e3480-2f03-11eb-85d4-5fcc5e8a72bc.gif></denchmark-link>\n \n While in the same time no object storage is used:\n <denchmark-link:https://user-images.githubusercontent.com/30770185/100204374-16926680-2f04-11eb-8a5b-d6a0348fb2a2.png></denchmark-link>\n \n Setup:\n \n Ray: 1.0.1\n OS: Ubuntu 18.04\n Python: 3.7.5\n \n <denchmark-h:h3>Reproduction (REQUIRED)</denchmark-h>\n \n I was able to reproduce it with that script:\n import time\n import requests\n from ray import serve\n \n client = serve.start()\n \n def echo(flask_request):\n     return \"hello \" + flask_request.args.get(\"name\", \"serve!\")\n \n client.create_backend(\"hello\", echo)\n client.create_endpoint(\"hello\", backend=\"hello\", route=\"/hello\")\n url = \"http://localhost:8000/hello\"\n payload = {}\n \n while True:\n     \n     files = [\n         ('test', (\n             'my_video-53.webm', open('./my_video-53.webm', 'rb'),\n             'video/webm'))\n         ]\n     headers = {\n         'apikey': 'asdfasfwerqexcz'\n         }\n \n     response = requests.request(\"GET\", url, headers=headers, data=payload, files=files)\n     time.sleep(1)\n The videos I used hat between 1MB and 4MB, if it is smaller the changes are not that obvious\n \n [x ] I have verified my script runs in a clean environment and reproduces the issue.\n  I have verified the issue also occurs with the latest wheels. -> I am not able to check that because the console is broken (#11932) and does not display anything there\n \n \t"}, "comments": {"comments_0": {"comment_id": 1, "comment_author": "TanjaBayer", "commentT": "2020-11-25T21:43:09Z", "comment_text": "\n \t\tHi <denchmark-link:https://github.com/TanjaBayer>@TanjaBayer</denchmark-link>\n , thanks for this report! I was able to reproduce it with the following script (swapped video file with np array) on latest master\n import time\n import requests\n from ray import serve\n import numpy as np\n import io\n \n client = serve.start()\n \n def echo(flask_request):\n     return \"hello \" + flask_request.args.get(\"name\", \"serve!\")\n \n client.create_backend(\"hello\", echo)\n client.create_endpoint(\"hello\", backend=\"hello\", route=\"/hello\")\n url = \"http://localhost:8000/hello\"\n payload = {}\n \n while True:\n     \n     files = [\n         ('test', (\n             'my_video-53.webm', io.BytesIO(np.zeros(4*1024*1024, dtype=np.uint8).tobytes()),\n             'video/webm'))\n         ]\n     headers = {\n         'apikey': 'asdfasfwerqexcz'\n         }\n \n     response = requests.request(\"GET\", url, headers=headers, data=payload, files=files)\n     time.sleep(1)\n At start:\n <denchmark-link:https://user-images.githubusercontent.com/21118851/100284249-c4613d80-2f23-11eb-9573-069d2c0da2af.png></denchmark-link>\n \n After a minute\n <denchmark-link:https://user-images.githubusercontent.com/21118851/100284387-f6729f80-2f23-11eb-8c19-930f95abbcbf.png></denchmark-link>\n \n (cc <denchmark-link:https://github.com/edoakes>@edoakes</denchmark-link>\n  )\n \t\t"}, "comments_1": {"comment_id": 2, "comment_author": "TanjaBayer", "commentT": "2020-11-25T21:50:04Z", "comment_text": "\n \t\t<denchmark-link:https://github.com/simon-mo>@simon-mo</denchmark-link>\n  nice. Does the memory grow unbounded or does it stabilize after running for awhile? That would be the first thing I'd check here.\n \t\t"}, "comments_2": {"comment_id": 3, "comment_author": "TanjaBayer", "commentT": "2020-11-25T22:15:54Z", "comment_text": "\n \t\tIt kept growing!\n <denchmark-link:https://user-images.githubusercontent.com/21118851/100286990-af3add80-2f28-11eb-9302-91404abc2ef2.png></denchmark-link>\n \n \t\t"}, "comments_3": {"comment_id": 4, "comment_author": "TanjaBayer", "commentT": "2020-11-26T07:36:04Z", "comment_text": "\n \t\t\n It kept growing!\n \n Yes same for us, as the data we are handling is even larger our service crashes after some time, because it runs out of memory\n \t\t"}, "comments_4": {"comment_id": 5, "comment_author": "TanjaBayer", "commentT": "2020-11-30T17:36:05Z", "comment_text": "\n \t\tAdding a call to the Python garbage collector inside of the backend solves the issue for me:\n <denchmark-code>def echo(flask_request):\n     import gc; gc.collect()\n     return \"hello \" + flask_request.args.get(\"name\", \"serve!\")\n </denchmark-code>\n \n This indicates that we probably have a reference cycle somewhere in the code that prevents the data from being cleaned up until the garbage collector is invoked. <denchmark-link:https://github.com/TanjaBayer>@TanjaBayer</denchmark-link>\n  you could use manual calls to  as a workaround for now, though it will degrade performance. We will try to track down the reference cycle and address it in Serve.\n \t\t"}, "comments_5": {"comment_id": 6, "comment_author": "TanjaBayer", "commentT": "2020-11-30T17:40:54Z", "comment_text": "\n \t\tOutput of using gc.DEBUG_SAVEALL indicates that the HTTP request object is indeed caught in a ref cycle:\n <denchmark-code>def echo(flask_request):\n     import gc\n     gc.set_debug(gc.DEBUG_SAVEALL)\n     gc.collect()\n     for item in gc.garbage:\n         print(item)\n     return \"hello \" + flask_request.args.get(\"name\", \"serve!\")\n </denchmark-code>\n \n Output (repeated for each request):\n <denchmark-code>(pid=13929) {'REQUEST_METHOD': 'GET', 'SCRIPT_NAME': '', 'PATH_INFO': '/hello', 'QUERY_STRING': '', 'SERVER_PROTOCOL': 'HTTP/1.1', 'wsgi.version': (1, 0), 'wsgi.url_scheme': 'http', 'wsgi.input': <_io.BytesIO object at 0x7f8b480cfb80>, 'wsgi.errors': <_io.BytesIO object at 0x7f8b480cfcc0>, 'wsgi.multithread': True, 'wsgi.multiprocess': True, 'wsgi.run_once': False, 'SERVER_NAME': '127.0.0.1', 'SERVER_PORT': '8000', 'REMOTE_ADDR': '127.0.0.1', 'HTTP_HOST': 'localhost:8000', 'HTTP_USER_AGENT': 'python-requests/2.24.0', 'HTTP_ACCEPT_ENCODING': 'gzip, deflate', 'HTTP_ACCEPT': '*/*', 'HTTP_CONNECTION': 'keep-alive', 'HTTP_APIKEY': 'asdfasfwerqexcz', 'CONTENT_LENGTH': '4194482', 'CONTENT_TYPE': 'multipart/form-data; boundary=05115f20499502f3d299bfebc81645d5', 'werkzeug.request': <Request 'http://localhost:8000/hello' [GET]>}\n (pid=13929) <_io.BytesIO object at 0x7f8b480cfb80>\n (pid=13929) <_io.BytesIO object at 0x7f8b480cfcc0>\n (pid=13929) ImmutableMultiDict([])\n (pid=13929) <Request 'http://localhost:8000/hello' [GET]>\n </denchmark-code>\n \n Note that there is no garbage collected when using the ServeHandle interface, so this must be specific to the flask request object.\n \t\t"}, "comments_6": {"comment_id": 7, "comment_author": "TanjaBayer", "commentT": "2020-12-01T15:54:35Z", "comment_text": "\n \t\t<denchmark-link:https://github.com/edoakes>@edoakes</denchmark-link>\n  thats an interesting insight, actually we are only useing  but the setup is really nested, so I tried to reproduce it in a really simple way and thought it was the same issue when using the flask handle.\n But so far I was not able to find a minimal sample which shows the same behavior with the serveHandle than the one we are facing. I will try tomorrow to find out more on that...\n \t\t"}, "comments_7": {"comment_id": 8, "comment_author": "TanjaBayer", "commentT": "2020-12-04T13:33:28Z", "comment_text": "\n \t\tSo I tried to reproduce my exact issue with the ServerHandle but was not able to do so, so I assume the large increase of ram size is a mixture of tow things:\n \n some problem with some of our models, which really increase indefinitely, which I need to examine more in detail\n a behavior of ray which I don't know is a bug or not, but has a hugh impact on the RAM size in any way:\n \n When sending data between endpoints the RAM of the workers changes by the size of the data we need to handle, which makes completely sense, because the data needs to be kept in memory while working with it. But the ram does not decrease after the call (which might be a feature, because it might make sense to block the memory for the future, but I am not sure if that is really the case, just a guess \ud83d\ude04 )\n But the thing which is strange in my opinion is that when making the next call the actor increases again, approx same size as before, but now shows the behavior that this is only for the time the request is beeing executed, it returns to the size from before.\n When I run this code, I see the following behavior:\n import asyncio\n import time\n import uuid\n \n import ray\n from ray import serve\n from ray.serve.utils import ServeRequest\n \n client = serve.start(detached=True)\n \n import numpy as np\n \n \n async def nested_one(request: ServeRequest):\n     case_id = request.args[\"case_id\"]\n \n     print(f'{case_id}: Received Batch data, forward it')\n     nested_handle = client.get_handle('nested_one_one')\n     task_handle = nested_handle.remote(batch=request.args.get(\"batch\"), case_id=case_id)\n     await asyncio.sleep(5)\n     await task_handle\n     print(f'{case_id}: did some work and waited for task')\n     return []\n \n \n async def nested_one_one(request: ServeRequest):\n     await asyncio.sleep(5)\n     # Just creating random variables, that should not increase the model ram size after the task\n     # has been finished\n     [np.random.randint(0, 255, (1280, 720, 3), dtype=np.uint8) for _ in\n      range(0, 150)]\n     return []\n \n \n client.create_backend(\"nested_one\", nested_one)\n client.create_endpoint(\"nested_one\", backend=\"nested_one\")\n \n client.create_backend(\"nested_one_one\", nested_one_one)\n client.create_endpoint(\"nested_one_one\", backend=\"nested_one_one\")\n \n time.sleep(5)\n \n client = serve.connect()\n while True:\n     nested_one = client.get_handle('nested_one')\n     case_id = str(uuid.uuid4())\n     batch_of_numpys = [np.random.randint(0, 255, (1280, 720, 3), dtype=np.uint8) for _ in\n                        range(0, 150)]\n     print(ray.get(nested_one.remote(case_id=case_id, batch=batch_of_numpys)))\n \n     time.sleep(15)\n <denchmark-h:h2>Before any request</denchmark-h>\n \n <denchmark-link:https://user-images.githubusercontent.com/30770185/101168729-21ec3d00-363c-11eb-811b-1b28df4b8f66.png></denchmark-link>\n \n <denchmark-h:h2>During 1st request</denchmark-h>\n \n <denchmark-link:https://user-images.githubusercontent.com/30770185/101168753-2dd7ff00-363c-11eb-93f0-b4d858d4ec28.png></denchmark-link>\n \n <denchmark-h:h2>After 1st request</denchmark-h>\n \n <denchmark-link:https://user-images.githubusercontent.com/30770185/101168781-3a5c5780-363c-11eb-9e5a-ce673ebff60b.png></denchmark-link>\n \n <denchmark-h:h2>Second request</denchmark-h>\n \n <denchmark-link:https://user-images.githubusercontent.com/30770185/101168767-34667680-363c-11eb-901e-262e18e651f1.png></denchmark-link>\n \n <denchmark-h:h2>After second request</denchmark-h>\n \n <denchmark-link:https://user-images.githubusercontent.com/30770185/101168810-48aa7380-363c-11eb-9fb9-14da85599bb7.png></denchmark-link>\n \n <denchmark-h:h2>After some more requests</denchmark-h>\n \n <denchmark-link:https://user-images.githubusercontent.com/30770185/101169163-d38b6e00-363c-11eb-8e1e-8df0dc7afaf0.png></denchmark-link>\n \n So it does not seem to grow endlessly, but still I do not understand the largely increased memory of the idle actors, maybe there is some reason for it?\n And that blows up fast, if you have some more endpoints handling same amount of data.\n \t\t"}, "comments_8": {"comment_id": 9, "comment_author": "TanjaBayer", "commentT": "2020-12-10T18:11:35Z", "comment_text": "\n \t\tHi <denchmark-link:https://github.com/TanjaBayer>@TanjaBayer</denchmark-link>\n , can you try the nightly build and see if it fixes your issue?  It fixes it for me.  Also, the next release will be out fairly soon (in about 1 week).\n On the nightly, the script doesn\u2019t run as written, you have to add the line client = serve.connect() in the body of nested_one to prevent the error \u201cray.serve.exceptions.RayServeException: Ray Serve client cannot be serialized. Please use serve.connect() to get a client from within a backend.\u201d\n Once that is done, the issue appears to be resolved:\n After 0 requests:\n <denchmark-link:https://user-images.githubusercontent.com/5459654/101811925-8c372e80-3acf-11eb-8e9e-e209cc24f72d.png></denchmark-link>\n \n After 1 request:\n <denchmark-link:https://user-images.githubusercontent.com/5459654/101811952-93f6d300-3acf-11eb-81f0-85ffa1e11f22.png></denchmark-link>\n \n After 2 requests, 3 requests, 4 requests, and so on:\n <denchmark-link:https://user-images.githubusercontent.com/5459654/101811989-9fe29500-3acf-11eb-90b4-2d9a6f423583.png></denchmark-link>\n \n The situation stabilizes after 2 requests (the memory doesn\u2019t keep increasing.)\n \t\t"}, "comments_9": {"comment_id": 10, "comment_author": "TanjaBayer", "commentT": "2020-12-10T19:06:46Z", "comment_text": "\n \t\tLet's keep it open until <denchmark-link:https://github.com/TanjaBayer>@TanjaBayer</denchmark-link>\n  can verify it with nightly. Thanks!\n \t\t"}, "comments_10": {"comment_id": 11, "comment_author": "TanjaBayer", "commentT": "2020-12-11T13:28:51Z", "comment_text": "\n \t\t<denchmark-link:https://github.com/simon-mo>@simon-mo</denchmark-link>\n  <denchmark-link:https://github.com/architkulkarni>@architkulkarni</denchmark-link>\n  I verified it with latest nightly, I see the same behavior now as <denchmark-link:https://github.com/architkulkarni>@architkulkarni</denchmark-link>\n  mentioned (only one_one grows in first and second call, the other stay stable), I will also check it with our more complex version if that changes anything.\n But what I still don't get, why does it grow twice?\n Update: I am not able to check with our more complex version, because I am not able to see the dashbord with nightly\n \t\t"}, "comments_11": {"comment_id": 12, "comment_author": "TanjaBayer", "commentT": "2020-12-11T16:25:49Z", "comment_text": "\n \t\t<denchmark-link:https://github.com/TanjaBayer>@TanjaBayer</denchmark-link>\n  I'm not completely sure, but I'd guess that this is just because Python/numpy is ing on the first few requests and not relinquishing the memory as an optimization. You could try to verify this by running the same inference call in a local Python process and seeing if it's the same behavior.\n \t\t"}, "comments_12": {"comment_id": 13, "comment_author": "TanjaBayer", "commentT": "2020-12-14T18:38:44Z", "comment_text": "\n \t\t<denchmark-link:https://github.com/TanjaBayer>@TanjaBayer</denchmark-link>\n  is there an open issue for the issue you're seeing with the dashboard?\n \t\t"}, "comments_13": {"comment_id": 14, "comment_author": "TanjaBayer", "commentT": "2020-12-14T19:05:02Z", "comment_text": "\n \t\t<denchmark-link:https://github.com/edoakes>@edoakes</denchmark-link>\n  not yet but there is an open discussion in slack about it\n \t\t"}}}, "commit": {"commit_id": "1f7a4806ff41d270f94e0fa1f58ca09a70a087e3", "commit_author": "Simon Mo", "commitT": "2020-12-03 10:45:04-06:00", "commit_complexity": {"commit_NLOC": "None", "commit_CCN": "None", "commit_Nprams": "None"}, "changed_files": {"file_0": {"file_change_type": "MODIFY", "file_Nmethod": 1, "file_old_name": "python\\ray\\serve\\http_util.py", "file_new_name": "python\\ray\\serve\\http_util.py", "file_complexity": {"file_NLOC": "79", "file_CCN": "15", "file_NToken": "521"}, "hunks": {"hunk_0": {"Ismethod": 1, "added_lines": "14,15,16,17", "deleted_lines": "14", "method_info": {"method_name": "build_flask_request", "method_params": "asgi_scope_dict,request_body", "method_startline": "7", "method_endline": "17", "method_complexity": {"method_NLOC": "3", "method_CCN": "1", "method_NToken": "27", "method_nesting_level": "0"}}}}}, "file_1": {"file_change_type": "MODIFY", "file_Nmethod": 2, "file_old_name": "python\\ray\\serve\\tests\\test_regression.py", "file_new_name": "python\\ray\\serve\\tests\\test_regression.py", "file_complexity": {"file_NLOC": "46", "file_CCN": "8", "file_NToken": "321"}, "hunks": {"hunk_0": {"Ismethod": 1, "added_lines": "45,46,47,48", "deleted_lines": null, "method_info": {"method_name": "test_backend_worker_memory_growth.gc_unreachable_objects", "method_params": "flask_request", "method_startline": "45", "method_endline": "48", "method_complexity": {"method_NLOC": "4", "method_CCN": "1", "method_NToken": "25", "method_nesting_level": "1"}}}, "hunk_1": {"Ismethod": 1, "added_lines": "41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63", "deleted_lines": null, "method_info": {"method_name": "test_backend_worker_memory_growth", "method_params": "serve_instance", "method_startline": "41", "method_endline": "63", "method_complexity": {"method_NLOC": "14", "method_CCN": "3", "method_NToken": "97", "method_nesting_level": "0"}}}}}}}}