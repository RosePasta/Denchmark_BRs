{"BR": {"BR_id": "11030", "BR_author": "robbertvc", "BRopenT": "2020-09-25T10:53:16Z", "BRcloseT": "2020-11-30T11:10:23Z", "BR_text": {"BRsummary": "Using asyncio.wait on a ray ObjectRef can result in InvalidStateError logs", "BRdescription": "\n <denchmark-h:h3>What is the problem?</denchmark-h>\n \n <denchmark-h:h4>Versions</denchmark-h>\n \n $ python --version\n Python 3.6.12 :: Anaconda, Inc.\n $ python -c \"import ray; print('VERSION:', ray.__version__, 'COMMIT:', ray.__commit__)\"\n VERSION: 0.8.7 COMMIT: 56810e136587432ed4758d882bf8894b930355e3\n <denchmark-h:h4>Context</denchmark-h>\n \n We use this construct to wait for an actor's result. The actor could fail (e.g. by going OOM) so we also do some periodic health checks on it. asyncio.wait is used to check for both the result and the health check concurrently.\n <denchmark-h:h4>Problem</denchmark-h>\n \n When using asyncio.wait on a ray ObjectRef which represents an aync actor method call, sometimes (with high probability) the set_result callback is ran twice, resulting in an InvalidStateError. Since this exception is thrown in the callback itself, the code does not crash but it does result in some spammy error logs.\n <denchmark-h:h4>Related</denchmark-h>\n \n <denchmark-link:https://github.com/ray-project/ray/issues/8841>#8841</denchmark-link>\n  seems to be related, but I have created a new ticket because:\n \n I cannot reproduce the original error from that ticket anymore using the latest releases.\n \n import ray\n import time\n import asyncio\n \n ray.init()\n @ray.remote\n def f():\n     time.sleep(5)\n \n async def test():\n     oid = f.remote()\n     try:\n         await asyncio.wait_for(oid, timeout=1)\n     except asyncio.TimeoutError:\n         pass\n     try:\n         await asyncio.wait_for(oid, timeout=1)\n     except asyncio.TimeoutError:\n         pass\n \n asyncio.get_event_loop().run_until_complete(test())\n \n The changes the ticket introduced are not in master anymore (https://github.com/ray-project/ray/pull/8842/files)\n \n <denchmark-h:h3>Reproduction</denchmark-h>\n \n import ray\n import asyncio\n import logging\n from typing import NoReturn\n from ray.actor import ActorHandle\n from contextlib import suppress\n \n logging.basicConfig(level=logging.INFO)\n ray.init()\n \n # =============================================================================\n # test setup\n # =============================================================================\n \n @ray.remote\n class AsyncActor:\n \n     async def ping(self) -> str:\n         \"\"\"Health check method.\n \n         Used to determine if the actor is still alive.\n         \"\"\"\n         return \"OK\"\n \n     async def run(self) -> str:\n         \"\"\"Long running job.\n \n         Can fail and can even crash the ray worker process.\n         \"\"\"\n         await asyncio.sleep(5)\n         return \"DONE\"\n \n \n async def periodic_ping(actor_handle: ActorHandle) -> NoReturn:\n     while True:\n         asyncio.sleep(0.5)\n         try:\n             await actor_handle.ping.remote()\n         except asyncio.CancelledError:\n             pass\n         except Exception as e:\n             logging.exception(\"Actor is dead!\")\n             raise\n \n async def run(actor_handle):\n \n     loop = asyncio.get_event_loop()\n \n     try:\n         health_check = loop.create_task(periodic_ping(actor_handle))\n         get_result = actor_handle.run.remote()\n         done, pending = await asyncio.wait(\n             [get_result, health_check],\n             return_when=asyncio.FIRST_COMPLETED,\n         )\n \n         # The health check can only raise, so first task in done state\n         # is the response from the ResultsActor.\n         result = next(iter(done)).result()\n \n     finally:\n         with suppress(asyncio.CancelledError):\n             health_check.cancel()\n \n     return result\n \n # =============================================================================\n # run the test\n # =============================================================================\n \n async def test():\n \n     actor_handle = AsyncActor.remote()\n \n     # This actually completes fine, but somehow the `set_future` callback\n     # can run twice, resulting in an ERROR log statement. It doesn't happen\n     # everytime, but should be easily reproducible by running the script a few\n     # times.\n     #\n     #    ERROR:asyncio:Exception in callback async_set_result.<locals>.set_future()\n     #    handle: <Handle async_set_result.<locals>.set_future()>\n     #    Traceback (most recent call last):\n     #    File \".../lib/python3.6/asyncio/events.py\", line 145, in _run\n     #       self._callback(*self._args)\n     #    File \"python/ray/_raylet.pyx\", line 1361, in ray._raylet.async_set_result.set_future\n     #    asyncio.base_futures.InvalidStateError: invalid state\n \n     result = await run(actor_handle)\n \n     print(result)\n \n if __name__ == \"__main__\":\n \n     loop = asyncio.get_event_loop()\n     loop.run_until_complete(test())\n If we cannot run your script, we cannot fix your issue.\n \n [\u2714\ufe0f] I have verified my script runs in a clean environment and reproduces the issue.\n [\u2714\ufe0f] I have verified the issue also occurs with the latest wheels.\n \n Some clarification:\n The issue does not manifest itself every time the script is run. It can take a few times.\n Only tested with the latest stable wheels.\n \t"}, "comments": {"comments_0": {"comment_id": 1, "comment_author": "robbertvc", "commentT": "2020-09-25T17:44:15Z", "comment_text": "\n \t\tcc <denchmark-link:https://github.com/ijrsvt>@ijrsvt</denchmark-link>\n  <denchmark-link:https://github.com/simon-mo>@simon-mo</denchmark-link>\n  Isn't it supposed to be fixed right? Was it pushed after 0.8.7?\n <denchmark-link:https://github.com/robbertvc>@robbertvc</denchmark-link>\n  Is it possible to try the latest commit and see if it still occurs?\n \t\t"}, "comments_1": {"comment_id": 2, "comment_author": "robbertvc", "commentT": "2020-10-07T11:16:21Z", "comment_text": "\n \t\t<denchmark-link:https://github.com/rkooo567>@rkooo567</denchmark-link>\n  Hi Sang, unfortunately we can still reproduce it with the official ray 1.0.0 release. Subjectively, it seems to take a bit longer to reproduce though, this time it took  around 20 runs of the script.\n \t\t"}, "comments_2": {"comment_id": 3, "comment_author": "robbertvc", "commentT": "2020-10-12T05:38:54Z", "comment_text": "\n \t\t<denchmark-link:https://github.com/simon-mo>@simon-mo</denchmark-link>\n  Can we close after <denchmark-link:https://github.com/robbertvc>@robbertvc</denchmark-link>\n  tries this one more time? <denchmark-link:https://github.com/robbertvc>@robbertvc</denchmark-link>\n  Would you mind trying the latest master and see if it is reproduced?\n \t\t"}, "comments_3": {"comment_id": 4, "comment_author": "robbertvc", "commentT": "2020-10-12T05:58:19Z", "comment_text": "\n \t\tSure. This is automatically closed by the PR merge.\n \t\t"}, "comments_4": {"comment_id": 5, "comment_author": "robbertvc", "commentT": "2020-11-30T09:43:14Z", "comment_text": "\n \t\tSorry for the delay, but good news: we cannot reproduce this anymore using ray 1.0.1 \ud83c\udf89\n \t\t"}}}, "commit": {"commit_id": "0d09a17c646de4cf7269ae673cf15f8945208313", "commit_author": "Simon Mo", "commitT": "2020-10-11 22:33:58-07:00", "commit_complexity": {"commit_NLOC": "None", "commit_CCN": "None", "commit_Nprams": "None"}, "changed_files": {"file_0": {"file_change_type": "MODIFY", "file_Nmethod": 0, "file_old_name": "python\\ray\\_raylet.pyx", "file_new_name": "python\\ray\\_raylet.pyx", "file_complexity": {"file_NLOC": "None", "file_CCN": "None", "file_NToken": "None"}, "hunks": {"hunk_0": {"Ismethod": 0, "added_lines": "1518,1519,1520,1521,1522,1523,1524,1530", "deleted_lines": null}}}}}}