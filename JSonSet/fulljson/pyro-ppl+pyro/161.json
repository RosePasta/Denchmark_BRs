{"BR": {"BR_id": "161", "BR_author": "fritzo", "BRopenT": "2017-09-27T21:20:25Z", "BRcloseT": "2017-10-04T05:45:13Z", "BR_text": {"BRsummary": "Dirichlet distribution treats shape inconsistently", "BRdescription": "\n While the tests for pyro.distributions.dirichlet test with a 1-dimensional tensor alpha, the Dirichlet constructor uses ad hoc logic to ensure there are at least 2 dimensions in the alpha. Moreover the ad hoc 2-dimensional tensor does not work, and is preventing me from using Dirichlet as a prior on component weights in a mixture model.\n See <denchmark-link:https://github.com/pyro-ppl/pyro/issues/153>#153</denchmark-link>\n  for more comprehensive solution.\n Example excerpt:\n # This is inside a model:\n ps = pyro.sample('ps', Dirichlet(alpha=Variable(torch.ones(10) / 0.5)))\n Error message:\n \n ---------------------------------------------------------------------------\n ValueError                                Traceback (most recent call last)\n  in ()\n       1 get_ipython().magic(u'pdb off')\n ----> 2 inference(data)\n /Users/fritzobermeyer/github/uber/pyro/pyro/infer/kl_qp.pyc in call(self, *args, **kwargs)\n 51\n 52     def call(self, *args, **kwargs):\n ---> 53         return self.step(*args, **kwargs)\n 54\n 55     def populate_traces(self, *args, **kwargs):\n /Users/fritzobermeyer/github/uber/pyro/pyro/infer/kl_qp.pyc in step(self, *args, **kwargs)\n 160\n 161         if 'loss_and_params' not in kwargs.keys():\n --> 162             [loss, all_trainable_params] = self.eval_grad(*args, **kwargs)\n 163         else:\n 164             [loss, all_trainable_params] = kwargs['loss_and_params']\n /Users/fritzobermeyer/github/uber/pyro/pyro/infer/kl_qp.pyc in eval_grad(self, *args, **kwargs)\n 109         \"\"\"\n 110\n --> 111         [model_traces, guide_traces, log_r_per_sample] = self.populate_traces(*args, **kwargs)\n 112\n 113         elbo = 0.0\n /Users/fritzobermeyer/github/uber/pyro/pyro/infer/kl_qp.pyc in populate_traces(self, *args, **kwargs)\n 64             guide_trace = poutine.trace(self.guide)(*args, **kwargs)\n 65             model_trace = poutine.trace(\n ---> 66                 poutine.replay(self.model, guide_trace))(*args, **kwargs)\n 67\n 68             log_r = model_trace.log_pdf() - guide_trace.log_pdf()\n /Users/fritzobermeyer/github/uber/pyro/pyro/poutine/init.pyc in _fn(*args, **kwargs)\n 25     def _fn(*args, **kwargs):\n 26         p = TracePoutine(fn)\n ---> 27         return p(*args, **kwargs)\n 28\n 29     return _fn\n /Users/fritzobermeyer/github/uber/pyro/pyro/poutine/poutine.pyc in call(self, *args, **kwargs)\n 28\n 29             # run the original function overloading the fcts\n ---> 30             base_r_val = self.orig_fct(*args, **kwargs)\n 31\n 32             # then return the pyro global fcts to their previous state\n /Users/fritzobermeyer/github/uber/pyro/pyro/poutine/init.pyc in _fn(*args, **kwargs)\n 49     def _fn(*args, **kwargs):\n 50         p = ReplayPoutine(fn, trace, sites=sites)\n ---> 51         return p(*args, **kwargs)\n 52\n 53     return _fn\n /Users/fritzobermeyer/github/uber/pyro/pyro/poutine/poutine.pyc in call(self, *args, **kwargs)\n 28\n 29             # run the original function overloading the fcts\n ---> 30             base_r_val = self.orig_fct(*args, **kwargs)\n 31\n 32             # then return the pyro global fcts to their previous state\n  in model(data)\n 6     # Global parameters.\n 7     if use_dirichlet_prior:\n ----> 8         ps = pyro.sample('ps', Dirichlet(alpha=Variable(torch.ones(K) * 0.5)))\n 9     else:\n 10         # FIXME I would put a Dirichlet prior here, but Dirichlet is buggy.\n /Users/fritzobermeyer/github/uber/pyro/pyro/init.pyc in sample(name, fn, *args, **kwargs)\n 105         }\n 106         # apply the stack and return its return value\n --> 107         out_msg = apply_stack(msg)\n 108         return out_msg[\"ret\"]\n 109\n /Users/fritzobermeyer/github/uber/pyro/pyro/init.pyc in apply_stack(initial_msg, stack)\n 71     # go until time to stop?\n 72     for j in range(0, len(stack)):\n ---> 73         msg = stack[j].up(msg)\n 74         if msg[\"stop\"]:\n 75             break\n /Users/fritzobermeyer/github/uber/pyro/pyro/poutine/poutine.pyc in up(self, msg)\n 67             ret = self._pyro_sample(msg, msg[\"name\"],\n 68                                     msg[\"fn\"],\n ---> 69                                     *msg[\"args\"], **msg[\"kwargs\"])\n 70         elif msg[\"type\"] == \"observe\":\n 71             ret = self._pyro_observe(msg, msg[\"name\"],\n /Users/fritzobermeyer/github/uber/pyro/pyro/poutine/replay_poutine.pyc in _pyro_sample(self, msg, name, fn, *args, **kwargs)\n 67         # case 2: dict, negative: sample from model\n 68         elif name not in self.sites:\n ---> 69             return super(ReplayPoutine, self)._pyro_sample(msg, name, fn, *args, **kwargs)\n 70         else:\n 71             raise ValueError(\n /Users/fritzobermeyer/github/uber/pyro/pyro/poutine/poutine.pyc in _pyro_sample(self, msg, name, fn, *args, **kwargs)\n 128         if msg[\"done\"]:\n 129             return msg[\"ret\"]\n --> 130         val = fn(*args, **kwargs)\n 131         msg[\"done\"] = True\n 132         return val\n /Users/fritzobermeyer/github/uber/pyro/pyro/distributions/distribution.pyc in call(self, *args, **kwargs)\n 16         Samples on call\n 17         \"\"\"\n ---> 18         return self.sample(*args, **kwargs)\n 19\n 20     def sample(self, *args, **kwargs):\n /Users/fritzobermeyer/github/uber/pyro/pyro/distributions/dirichlet.pyc in sample(self, alpha, *args, **kwargs)\n 45         # _alpha = Variable(torch.Tensor([[1,2],[3,4]]))\n 46         x = Variable(torch.Tensor(spr.dirichlet.rvs(\n ---> 47                      _alpha.data.numpy()))\n 48                      .type_as(_alpha.data)).squeeze(0)\n 49         return x\n /Users/fritzobermeyer/miniconda2/envs/pyro2/lib/python2.7/site-packages/scipy/stats/_multivariate.pyc in rvs(self, alpha, size, random_state)\n 1355\n 1356         \"\"\"\n -> 1357         alpha = _dirichlet_check_parameters(alpha)\n 1358         random_state = self._get_random_state(random_state)\n 1359         return random_state.dirichlet(alpha, size=size)\n /Users/fritzobermeyer/miniconda2/envs/pyro2/lib/python2.7/site-packages/scipy/stats/_multivariate.pyc in _dirichlet_check_parameters(alpha)\n 1075     elif alpha.ndim != 1:\n 1076         raise ValueError(\"Parameter vector 'a' must be one dimensional, \"\n -> 1077                        \"but a.shape = %s.\" % (alpha.shape, ))\n 1078     return alpha\n 1079\n ValueError: Parameter vector 'a' must be one dimensional, but a.shape = (1, 2).\n \n \n \t"}, "comments": {"comments_0": {"comment_id": 1, "comment_author": "fritzo", "commentT": "2017-09-27T21:21:19Z", "comment_text": "\n \t\tIt's also concerning that we're not testing the codepath\n x = Dirichlet(alpha=anything_other_than_None)\n Has this codepath ever worked? What is its intended behavior?\n \t\t"}, "comments_1": {"comment_id": 2, "comment_author": "fritzo", "commentT": "2017-09-27T22:21:21Z", "comment_text": "\n \t\tgood call, the scipy Dirichlet only takes 1-d alphas, which mean that the expand in the constructor should be removed. This also means that you can never call batch_log_pdf on it because these samples are one dimensional. thats kind of annoying, we might need to implement batched alphas ourselves. numpy allows you to sample a specific shape, but those are using the same alpha and drawing m x n samples\n \t\t"}}}, "commit": {"commit_id": "00b5688ecb1535f844ee4575ec590f2166dd8a62", "commit_author": "Fritz Obermeyer", "commitT": "2017-10-03 22:45:12-07:00", "commit_complexity": {"commit_NLOC": "0.19230769230769232", "commit_CCN": "0.19230769230769232", "commit_Nprams": "0.07692307692307693"}, "changed_files": {"file_0": {"file_change_type": "MODIFY", "file_Nmethod": 6, "file_old_name": "pyro\\distributions\\dirichlet.py", "file_new_name": "pyro\\distributions\\dirichlet.py", "file_complexity": {"file_NLOC": "81", "file_CCN": "24", "file_NToken": "778"}, "hunks": {"hunk_0": {"Ismethod": 1, "added_lines": "59,60,61,63,64,65,66,67", "deleted_lines": "59,60,61,62", "method_info": {"method_name": "__init__", "method_params": "self,alpha,batch_size,args,kwargs", "method_startline": "57", "method_endline": "69", "method_complexity": {"method_NLOC": "8", "method_CCN": "2", "method_NToken": "69", "method_nesting_level": "1"}}}, "hunk_1": {"Ismethod": 1, "added_lines": "22,23,25,28", "deleted_lines": "21,24,25", "method_info": {"method_name": "_sanitize_input", "method_params": "self,alpha", "method_startline": "19", "method_endline": "28", "method_complexity": {"method_NLOC": "8", "method_CCN": "4", "method_NToken": "45", "method_nesting_level": "1"}}}, "hunk_2": {"Ismethod": 1, "added_lines": "73,75,77,78,80,81,82,83,84,85,86,87,88,89,90", "deleted_lines": null, "method_info": {"method_name": "sample", "method_params": "self,alpha,args,kwargs", "method_startline": "71", "method_endline": "90", "method_complexity": {"method_NLOC": "13", "method_CCN": "4", "method_NToken": "142", "method_nesting_level": "1"}}}, "hunk_3": {"Ismethod": 1, "added_lines": "51,52,53,54,55", "deleted_lines": "51,53,54,55", "method_info": {"method_name": "log_pdf", "method_params": "self,x,alpha,args,kwargs", "method_startline": "51", "method_endline": "55", "method_complexity": {"method_NLOC": "5", "method_CCN": "1", "method_NToken": "57", "method_nesting_level": "1"}}}, "hunk_4": {"Ismethod": 1, "added_lines": "30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55", "deleted_lines": "30,32,33,34,35,41,42,44,45,46,47,48,49,51,53,54,55", "method_info": {"method_name": "_expand_dims", "method_params": "self,x,alpha", "method_startline": "30", "method_endline": "55", "method_complexity": {"method_NLOC": "21", "method_CCN": "11", "method_NToken": "296", "method_nesting_level": "1"}}}, "hunk_5": {"Ismethod": 1, "added_lines": "94,95,96,97,98,99,100,101,102,103,104,105,106,107,109,110,111,112", "deleted_lines": null, "method_info": {"method_name": "batch_log_pdf", "method_params": "self,x,alpha,batch_size,args,kwargs", "method_startline": "93", "method_endline": "115", "method_complexity": {"method_NLOC": "9", "method_CCN": "1", "method_NToken": "104", "method_nesting_level": "1"}}}}}, "file_1": {"file_change_type": "MODIFY", "file_Nmethod": 1, "file_old_name": "pyro\\util.py", "file_new_name": "pyro\\util.py", "file_complexity": {"file_NLOC": "164", "file_CCN": "51", "file_NToken": "1397"}, "hunks": {"hunk_0": {"Ismethod": 1, "added_lines": "121,122,123,124,125,126,127,128", "deleted_lines": null, "method_info": {"method_name": "log_beta", "method_params": "t", "method_startline": "120", "method_endline": "135", "method_complexity": {"method_NLOC": "9", "method_CCN": "2", "method_NToken": "81", "method_nesting_level": "0"}}}}}}}}