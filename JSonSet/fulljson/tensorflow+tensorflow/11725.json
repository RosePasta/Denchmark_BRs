{"BR": {"BR_id": "11725", "BR_author": "shamoya", "BRopenT": "2017-07-24T20:01:58Z", "BRcloseT": "2017-08-24T05:21:42Z", "BR_text": {"BRsummary": "tf_cnn_benchmarks.py stuck when running with multiple GPUs and ImageNet data with protocol grpc+verbs", "BRdescription": "\n <denchmark-h:h3>System information</denchmark-h>\n \n \n Have I written custom code (as opposed to using a stock example script provided in TensorFlow): No, running tf_cnn_benchmarks.py from benchmarks repo\n OS Platform and Distribution (e.g., Linux Ubuntu 16.04): Ubuntu 16.04.2 LTS\n TensorFlow installed from (source or binary): Unmodified source with RDMA Verbs enabled\n TensorFlow version (use command below): 1.3.0-rc0\n Python version: 2.7.12\n Bazel version (if compiling from source): 0.5.1\n CUDA/cuDNN version: 8.0/6\n GPU model and memory: NVIDIA Tesla P100 PCIe 16GB (8 per node)\n Exact command to reproduce:\n \n PS: CUDA_VISIBLE_DEVICES='' python tf_cnn_benchmarks.py --ps_hosts 12.12.12.43:20000 --worker_hosts 12.12.12.44:20000,12.12.12.41:20000 --batch_size=64 --model=inception3 --variable_update=parameter_server --local_parameter_device=cpu --job_name=ps --task_index=0 --server_protocol grpc+verbs\n Worker0: CUDA_VISIBLE_DEVICES='0,1,2,3,4,5,6,7' python tf_cnn_benchmarks.py --ps_hosts 12.12.12.43:20000 --worker_hosts 12.12.12.44:20000,12.12.12.41:20000 --batch_size=64 --model=inception3 --variable_update=parameter_server --local_parameter_device=cpu --job_name=worker --task_index=0 --num_gpus=8 --data_dir=/data/imagenet_data/ --train_dir=/data/imagenet_train/ --server_protocol grpc+verbs\n Worker1: CUDA_VISIBLE_DEVICES='0,1,2,3,4,5,6,7' python tf_cnn_benchmarks.py --ps_hosts 12.12.12.43:20000 --worker_hosts 12.12.12.44:20000,12.12.12.41:20000 --batch_size=64 --model=inception3 --variable_update=parameter_server --local_parameter_device=cpu --job_name=worker --task_index=1 --num_gpus=8 --data_dir=/data/imagenet_data/ --train_dir=/data/imagenet_train/ --server_protocol grpc+verbs\n \n RDMA driver version: MLNX_OFED_LINUX-4.1-1.0.2.0\n \n <denchmark-h:h3>Describe the problem</denchmark-h>\n \n When running the above commands (Inception V3 synchronized data parallelism training with 2 workers and 1 external ps), the tf_cnn_benchmarks application hangs forever after some iterations (usually in warm up).\n It happens only when real data is involved (ImageNet), and with >4 GPUs. (More GPUs, less iterations before it hangs). Doesn't happen with grpc protocol, or when running with \"synthetic\" data.\n The master_service in the workers is stuck <denchmark-link:https://github.com/tensorflow/tensorflow/blob/master/tensorflow/core/distributed_runtime/master_session.cc#L608>here</denchmark-link>\n , which I guess means some operations in the computation have not been completed.\n The RDMA protocol looks valid and clean, all messages corresponds to the protocol (see below logs).\n There some tensors requested by the workers which they don't receive, but they are passed by the RDMA Verbs transport to the BaseRendezvoudMgr with RecvLocalAsync in a valid way, and for some reason the higher level worker service doesn't trigger the Send kernel on those tensors.\n Any help is much appreciated!\n If there are some debug mechanisms I can use to understand which tensors/operations have not been completed it can greatly help. I was mostly debugging this from the RDMA Verbs layer till now, without much success, and I feel I don't have enough information there to understand what's missing.\n Also I feel we don't have enough knowledge on how the step_id acts (diving into this in the code now, but there's some higher level documentation it can greatly help).\n My initial guess was an occurrence of a racy condition when loading the data, since it creates a gap in execution time (worker0 starts the first training step 30-60 seconds after worker1, since it does the preprocessing of the data twice for a reason I couldn't understand yet), but after the first iteration (which usually passes successfully) the time is synchronized between workers.\n <denchmark-h:h3>Source code / logs</denchmark-h>\n \n Those are the logs of the runtime after moving the logging in <denchmark-link:https://github.com/tensorflow/tensorflow/blob/master/tensorflow/contrib/verbs/rdma.cc>rdma.cc</denchmark-link>\n  to VLOG(0) (also adding Tensor name and step id for all cases, in some cases the step_id doesn't mean anything like BUFFER_REQUEST/RESPONSE for example), and also some VLOG in <denchmark-link:https://github.com/tensorflow/tensorflow/blob/master/tensorflow/core/distributed_runtime/master_session.cc>master_session.cc</denchmark-link>\n \n <denchmark-link:https://gist.github.com/shamoya/15a42f421e088473b8f02bf00c16d0fc>worker0</denchmark-link>\n \n <denchmark-link:https://gist.github.com/shamoya/dd3126c02c73990a6e28b534d9a9ddf6>worker1</denchmark-link>\n \n <denchmark-link:https://gist.github.com/shamoya/0c856365802ae4d42b38baf988149574>ps</denchmark-link>\n \n Unfortunately they are fairly large, but it's better then to cut the log files IMO.\n Example for analysis I did in the verbs layer, comparing the Sent Tensor requests to the actual received tensors writes in both workers:\n worker 0:\n \n /job:ps/replica:0/task:0/cpu:0;f3c10d28b54074c0;/job:worker/replica:0/task:0/gpu:0;edge_116943_group_deps_2/NoOp_1;0:0 80661058974090965\n /job:worker/replica:0/task:1/cpu:0;1a50d5c51cd9c5d1;/job:worker/replica:0/task:0/gpu:0;edge_116947_group_deps_3/NoOp_1;0:0 80661058974090965\n /job:worker/replica:0/task:1/gpu:2;7f00fadabfe781f5;/job:worker/replica:0/task:0/gpu:0;edge_111078_group_deps_1/NoOp_2;0:0 80661058974090965\n /job:worker/replica:0/task:1/gpu:4;b07185dd19f62088;/job:worker/replica:0/task:0/gpu:0;edge_111080_group_deps_1/NoOp_4;0:0 80661058974090965\n \n worker 1:\n \n /job:ps/replica:0/task:0/cpu:0;f3c10d28b54074c0;/job:worker/replica:0/task:1/cpu:0;edge_155113_AssignAdd;0:0 80661058974090965\n /job:worker/replica:0/task:0/gpu:0;f3df8abf03739fe8;/job:worker/replica:0/task:1/cpu:0;edge_116948_group_deps_3;0:0 80661058974090965\n \n The tensors requests received well by the other side and passed to RecvLocalAsync, but are not called later.\n Thanks a lot.\n \t"}, "comments": {"comments_0": {"comment_id": 1, "comment_author": "shamoya", "commentT": "2017-07-24T23:11:14Z", "comment_text": "\n \t\tI was able to reproduce the issue. I also tried 'alexnet', it hung as well. I will take a close look in the coming days. Thanks for reporting.\n \t\t"}, "comments_1": {"comment_id": 2, "comment_author": "shamoya", "commentT": "2017-07-25T00:14:15Z", "comment_text": "\n \t\tThank you for looking into this <denchmark-link:https://github.com/junshi15>@junshi15</denchmark-link>\n !\n \t\t"}, "comments_2": {"comment_id": 3, "comment_author": "shamoya", "commentT": "2017-07-25T11:01:18Z", "comment_text": "\n \t\t<denchmark-link:https://github.com/mrry>@mrry</denchmark-link>\n  <denchmark-link:https://github.com/jhseu>@jhseu</denchmark-link>\n  <denchmark-link:https://github.com/poxvoculi>@poxvoculi</denchmark-link>\n  , just a small question.\n I'm trying to understand why execution hangs in <denchmark-link:https://github.com/tensorflow/tensorflow/blob/master/tensorflow/core/distributed_runtime/master_session.cc#L608>here</denchmark-link>\n .\n What (I think) I need is to get the Executor(s) which doesn't end in <denchmark-link:https://github.com/tensorflow/tensorflow/blob/master/tensorflow/core/distributed_runtime/graph_mgr.cc#L541>here</denchmark-link>\n .\n I tried passing tf.RunOptions(trace_level=tf.RunOptions.FULL_TRACE) to sess.run but then I get a huge file I can't really understand.  Is this the right way ?\n \t\t"}, "comments_3": {"comment_id": 4, "comment_author": "shamoya", "commentT": "2017-07-25T11:51:33Z", "comment_text": "\n \t\tI have met stuck problem(I think it may happen in warm up if I'm right.) when all workers finished all steps. I think  should be protected by a lock.I raised <denchmark-link:https://github.com/tensorflow/benchmarks/issues/38>an issue</denchmark-link>\n . I'm not sure if tensorflow has some special code for .\n \t\t"}, "comments_4": {"comment_id": 5, "comment_author": "shamoya", "commentT": "2017-07-25T16:41:12Z", "comment_text": "\n \t\tWhen I'm trying to debug a hung concurrent program the first step is\n usually to try to find a small case that exhibits the problem, i.e. try to\n find the least number of workers and GPUs that still hangs.  It's much\n easier to debug a small case than a large one.  Then, if it's a really\n small case you might be able to set the logging level high and read all the\n log files.  Usually though, I form some hypotheses about where the problem\n might be (e.g. a missing lock, a race that might result in deadlock, logic\n error that always deadlocks) and start putting in LOG(INFO) statements\n around the suspicious points to confirm or refute each hypothesis.\n <denchmark-link:#>\u2026</denchmark-link>\n \n \n On Tue, Jul 25, 2017 at 4:53 AM, Ziming Dong ***@***.***> wrote:\n  I think global_step should be protected by a lock.I raised an issue\n  <tensorflow/benchmarks#38>. I'm not sure if\n  tensorflow has some special code for global_step.\n \n  \u2014\n  You are receiving this because you were mentioned.\n  Reply to this email directly, view it on GitHub\n  <#11725 (comment)>,\n  or mute the thread\n  <https://github.com/notifications/unsubscribe-auth/AO818aHj9Ak6IS6emES-wdAhL-n1M4oUks5sRdcmgaJpZM4OhqyQ>\n  .\n \n \n \n \t\t"}, "comments_5": {"comment_id": 6, "comment_author": "shamoya", "commentT": "2017-07-25T17:09:14Z", "comment_text": "\n \t\t<denchmark-link:https://github.com/tfboyd>@tfboyd</denchmark-link>\n  I'm unassigning myself because I know very little about the RPC layer and know nothing about VERBs. I don't think this is a bug with tf_cnn_benchmarks, because <denchmark-link:https://github.com/tensorflow/tensorflow/issues/11416>#11416</denchmark-link>\n  also has the same issue with a different model.\n <denchmark-link:https://github.com/suiyuan2009>@suiyuan2009</denchmark-link>\n  I don't think <denchmark-link:https://github.com/tensorflow/benchmarks/issues/38>tensorflow/benchmarks#38</denchmark-link>\n  is the same issue, since this issue only occurs with verbs, and it occurs with another model with verbs. I'll take a look at <denchmark-link:https://github.com/tensorflow/benchmarks/issues/38>tensorflow/benchmarks#38</denchmark-link>\n  though.\n \t\t"}, "comments_6": {"comment_id": 7, "comment_author": "shamoya", "commentT": "2017-07-26T13:26:29Z", "comment_text": "\n \t\tThanks <denchmark-link:https://github.com/poxvoculi>@poxvoculi</denchmark-link>\n \n Sadly the smallest case which repro the issue is 3 nodes (2 workers 1 ps) with InveptionV3 and ImageNet, with the tf_cnn_benchmark.py (haven't checked others).\n I had ~15 hypotheses which turn out to be false.\n Added a lot of prints, but still couldn't understand which tensor is the rebel.\n I feel the trace_log mechanism (tf.RunOptions(trace_level=tf.RunOptions.FULL_TRACE)) can help me here, but I have no idea how to parse it. Is there a parsing tool or format for it ?\n \t\t"}, "comments_7": {"comment_id": 8, "comment_author": "shamoya", "commentT": "2017-07-26T14:19:07Z", "comment_text": "\n \t\tafter adding  a lock to global step, I didn't meet stuck problem.\n but I got error when running vgg benchmark code, maybe my network environment is a little unstable.\n <denchmark-code>2017-07-26 21:21:26.691844: F tensorflow/contrib/verbs/rdma.cc:683] Check failed: status.ok() RecvLocalAsync was not ok, key/job:worker/replica:0/task:2/gpu:1;b0903effc6e4881e;/job:ps/replica:0/task:0/cpu:0;edge_2493_Mul_1;0:0;138139939197237012 error message: Step 138139939197237012\n </denchmark-code>\n \n \t\t"}, "comments_8": {"comment_id": 9, "comment_author": "shamoya", "commentT": "2017-07-26T15:11:05Z", "comment_text": "\n \t\t<denchmark-link:https://github.com/suiyuan2009>@suiyuan2009</denchmark-link>\n  Your error might be caused by another process (PS or worker) in your job. We have met the same problem and it turns out when one process terminated the connection, its peers will print out such odd error log.\n \t\t"}, "comments_9": {"comment_id": 10, "comment_author": "shamoya", "commentT": "2017-07-26T15:13:50Z", "comment_text": "\n \t\t<denchmark-link:https://github.com/shamoya>@shamoya</denchmark-link>\n  For a simpler model, you could try  (the default one) and set your number of batches to a smaller value.\n Sorry that I am busying working on migrating my own patch and have little time to reproduce this particular bug right now.\n \t\t"}, "comments_10": {"comment_id": 11, "comment_author": "shamoya", "commentT": "2017-07-26T15:45:04Z", "comment_text": "\n \t\t<denchmark-link:https://github.com/shamoya>@shamoya</denchmark-link>\n  Can you try what <denchmark-link:https://github.com/suiyuan2009>@suiyuan2009</denchmark-link>\n  and <denchmark-link:https://github.com/byronyi>@byronyi</denchmark-link>\n  suggested.\n \n \n try the simple model to see if it hangs --model=trivial.\n \n \n With inception3, add a lock around global_step. something like\n \n \n <denchmark-code>  with self.lock:\n         inc_global_step = global_step.assign_add(1)\n         fetches.append(inc_global_step)\n </denchmark-code>\n \n some where in the init function, you define the lock:\n self.lock = threading.Lock()\n I was unable to get an infiniband setup yesterday. I will try again today.\n \t\t"}, "comments_11": {"comment_id": 12, "comment_author": "shamoya", "commentT": "2017-07-26T16:48:34Z", "comment_text": "\n \t\t<denchmark-link:https://github.com/shamoya>@shamoya</denchmark-link>\n \n The tracing data is available in a pre-parsed (protobuf) format.  See the run_metadata option to Session.run, which returns tracing data in StepStats.\n \t\t"}, "comments_12": {"comment_id": 13, "comment_author": "shamoya", "commentT": "2017-07-26T17:39:51Z", "comment_text": "\n \t\t<denchmark-link:https://github.com/junshi15>@junshi15</denchmark-link>\n  <denchmark-link:https://github.com/shamoya>@shamoya</denchmark-link>\n \n note that  is also a part of computing graph,  op has a  arg.\n \t\t"}, "comments_13": {"comment_id": 14, "comment_author": "shamoya", "commentT": "2017-07-26T21:32:04Z", "comment_text": "\n \t\t<denchmark-link:https://github.com/byronyi>@byronyi</denchmark-link>\n  , you're the best ! it's reproduced on trivial case (with ImageNet data).\n Now it will be much easier to debug, going full VLOG now - let's hope I'll have update soon.\n <denchmark-link:https://github.com/suiyuan2009>@suiyuan2009</denchmark-link>\n , it's not related to the global_step.\n I changed to have only the chief increment it and it doesn't have any affect.\n \t\t"}, "comments_14": {"comment_id": 15, "comment_author": "shamoya", "commentT": "2017-07-27T02:43:39Z", "comment_text": "\n \t\t<denchmark-link:https://github.com/byronyi>@byronyi</denchmark-link>\n , do your GDR patch have met same problem like stuck or failure?\n \t\t"}, "comments_15": {"comment_id": 16, "comment_author": "shamoya", "commentT": "2017-07-27T05:52:22Z", "comment_text": "\n \t\tNo I have not met such kind of problems, at least not during our internal testing. But my patch uses vastly different design compared to current verbs implementation so there is little I can tell about this particular issue.\n \t\t"}, "comments_16": {"comment_id": 17, "comment_author": "shamoya", "commentT": "2017-07-27T06:47:04Z", "comment_text": "\n \t\tMy observation agrees with <denchmark-link:https://github.com/shamoya>@shamoya</denchmark-link>\n  's.\n \n the program got stuck with the trivial model, but it needed 8 GPUs per worker. Even 7 GPUs do not result in hang (after running 1000 iterations).\n the program got stuck either at warm-up or early iterations (< 100).\n locking global_step does not help.\n At the very beginning, some tensors changed size as shown below. This may not be an issue, but it will be good to find out why.\n \n <denchmark-code>tensor and buffer size do not agree! buffer_size = 653 requested tensor size = 593 Tensor<type: int64 shape: [0,1] values: > key = /job:ps/replica:0/task:0/cpu:0;ccc0db7aa974ba53;/job:worker/replica:0/task:0/gpu:0;edge_37_report_uninitialized_variables/boolean_mask/Where;0:0\n \n tensor and buffer size do not agree! buffer_size = 649 requested tensor size = 589 Tensor<type: int64 shape: [0] values: > key = /job:worker/replica:0/task:0/gpu:0;62e354fc58da5afa;/job:ps/replica:0/task:0/cpu:0;edge_39_report_uninitialized_variables/boolean_mask/Squeeze;0:0\n </denchmark-code>\n \n \t\t"}, "comments_17": {"comment_id": 18, "comment_author": "shamoya", "commentT": "2017-07-27T14:49:16Z", "comment_text": "\n \t\t<denchmark-link:https://github.com/katyakats>@katyakats</denchmark-link>\n  <denchmark-link:https://github.com/bkovalev>@bkovalev</denchmark-link>\n \n Ok, after reviewing the full logs, this is what we think is the root cause:\n A single GPU (in worker1) doesn't complete loading of the model parameters from the CPU.\n For this GPU we don't see \"Async kernel done\" for the SEND/RECV operation (CPU:0 -> GPU:x locally).\n The reason why it happens only with RDMA (and not with gRPC) is not known yet.\n Thought about possible interrupts issue due to excessive interrupts (8 GPUs + NIC + NVMe drive which holds the ImageNet data, all on the same PCIe bus). however polling mode of Process_CQ (no interrupts from the NIC at all) didn't resolve the issue.\n <denchmark-link:https://gist.github.com/shamoya/824d452be527d95902f20b59f868b391>This</denchmark-link>\n  is the problematic GPU relevant logs.\n This is what I get from grepping one of the model parameters tensors  in the problematic GPU log (as above) VS one of the other valid GPUs:\n idos@MTR-IDOS $cat gpu2.log | grep \"affine1/biases\"\n 2017-07-27 16:04:48.740960: I tensorflow/core/common_runtime/executor.cc:1558] Process node: 8 step 286 v/affine1/biases/read_G109 = _Recv<denchmark-link:>client_terminated=false, recv_device=\"/job:worker/replica:0/task:1/gpu:2\", send_device=\"/job:worker/replica:0/task:1/cpu:0\", send_device_incarnation=-5325932350616196133, tensor_name=\"edge_609_v/affine1/biases/read\", tensor_type=DT_FLOAT, _device=\"/job:worker/replica:0/task:1/gpu:2\"</denchmark-link>\n  is dead: 0\n 2017-07-27 16:04:48.748463: I tensorflow/core/common_runtime/executor.cc:1558] Process node: 35506 step 286 v/affine1/biases/read_G108 = _Send<denchmark-link:v/affine1/biases/read>T=DT_FLOAT, client_terminated=false, recv_device=\"/job:worker/replica:0/task:1/gpu:2\", send_device=\"/job:worker/replica:0/task:1/cpu:0\", send_device_incarnation=-5325932350616196133, tensor_name=\"edge_609_v/affine1/biases/read\", _device=\"/job:worker/replica:0/task:1/cpu:0\"</denchmark-link>\n  is dead: 0\n idos@MTR-IDOS $cat gpu4.log | grep \"affine1/biases\"\n 2017-07-27 16:04:48.740332: I tensorflow/core/common_runtime/executor.cc:1558] Process node: 8 step 286 v/affine1/biases/read_G105 = _Recv<denchmark-link:>client_terminated=false, recv_device=\"/job:worker/replica:0/task:1/gpu:4\", send_device=\"/job:worker/replica:0/task:1/cpu:0\", send_device_incarnation=-5325932350616196133, tensor_name=\"edge_605_v/affine1/biases/read\", tensor_type=DT_FLOAT, _device=\"/job:worker/replica:0/task:1/gpu:4\"</denchmark-link>\n  is dead: 0\n 2017-07-27 16:04:48.748482: I tensorflow/core/common_runtime/executor.cc:1558] Process node: 35508 step 286 v/affine1/biases/read_G104 = _Send<denchmark-link:v/affine1/biases/read>T=DT_FLOAT, client_terminated=false, recv_device=\"/job:worker/replica:0/task:1/gpu:4\", send_device=\"/job:worker/replica:0/task:1/cpu:0\", send_device_incarnation=-5325932350616196133, tensor_name=\"edge_605_v/affine1/biases/read\", _device=\"/job:worker/replica:0/task:1/cpu:0\"</denchmark-link>\n  is dead: 0\n 2017-07-27 16:04:48.764311: I tensorflow/core/common_runtime/executor.cc:1612] 0x7f1fc4e67ab0 Async kernel done: v/affine1/biases/read_G105 = _Recv<denchmark-link:>client_terminated=false, recv_device=\"/job:worker/replica:0/task:1/gpu:4\", send_device=\"/job:worker/replica:0/task:1/cpu:0\", send_device_incarnation=-5325932350616196133, tensor_name=\"edge_605_v/affine1/biases/read\", tensor_type=DT_FLOAT, _device=\"/job:worker/replica:0/task:1/gpu:4\"</denchmark-link>\n \n 2017-07-27 16:04:48.765221: I tensorflow/core/common_runtime/executor.cc:1558] Process node: 69 step 286 v_4/tower_4/gradients/v_4/tower_4/L2Loss_3_grad/mul = Mul[T=DT_FLOAT, _device=\"/job:worker/replica:0/task:1/gpu:4\"](v/affine1/biase\n /read_G105, v_4/tower_4/gradients/v_4/tower_4/mul_1_grad/Reshape_1) is dead: 0\n 2017-07-27 16:04:48.765199: I tensorflow/core/common_runtime/executor.cc:1558] Process node: 9 step 286 v_4/tower_4/L2Loss_3 = L2Loss<denchmark-link:v/affine1/biases/read_G105>T=DT_FLOAT, _device=\"/job:worker/replica:0/task:1/gpu:4\"</denchmark-link>\n  is dead: 0\n 2017-07-27 16:04:48.765338: I tensorflow/core/common_runtime/executor.cc:1558] Process node: 38 step 286 v_4/tower_4/affine1/add = Add[T=DT_FLOAT, _device=\"/job:worker/replica:0/task:1/gpu:4\"](v_4/tower_4/affine1/MatMul, v/affine1/biase\n /read_G105) is dead: 0\n \t\t"}, "comments_18": {"comment_id": 19, "comment_author": "shamoya", "commentT": "2017-07-27T16:33:53Z", "comment_text": "\n \t\tJust a wild guess, if the callback passed into the local async recv kernel is an erroneous remote send, would it appear to be stuck at the local recv? What's the downstream operator of that local recv?\n \t\t"}, "comments_19": {"comment_id": 20, "comment_author": "shamoya", "commentT": "2017-07-27T20:01:26Z", "comment_text": "\n \t\t<denchmark-link:https://github.com/shamoya>@shamoya</denchmark-link>\n  intriguing discovery. Local tensor transfer is handled by BaseRemoteRendezvous. There is one difference between gRPC and RDMA: tolerate_dup_recv is set to  in <denchmark-link:https://github.com/tensorflow/tensorflow/blob/r1.3/tensorflow/core/distributed_runtime/rpc/rpc_rendezvous_mgr.cc#L42>the former</denchmark-link>\n  and  in <denchmark-link:https://github.com/tensorflow/tensorflow/blob/r1.3/tensorflow/contrib/verbs/rdma_rendezvous_mgr.cc#L34>the latter</denchmark-link>\n . The reason: gRPC only receives a tensor once, with verbs we have multiple receive attempts, since the tx/rx buffer may not be ready at early attempts. I ran some experiments by changing that to  in gPRC model, no hang was observed. However <denchmark-link:https://github.com/tensorflow/tensorflow/commit/cbfd50ff0f01e1825922230a8bc6e5766da98dd7#diff-b9ae16e68ba80801fe243bb5e19bac51>this patch</denchmark-link>\n  totally broke the verbs code. I had to raise an issue <denchmark-link:https://github.com/tensorflow/tensorflow/issues/11825>here</denchmark-link>\n . Something to worry about after this debug.\n A correction to what I said early, I finally saw hang with 7 GPUs per worker, after 2000 steps.\n \t\t"}, "comments_20": {"comment_id": 21, "comment_author": "shamoya", "commentT": "2017-07-27T20:48:27Z", "comment_text": "\n \t\tThanks <denchmark-link:https://github.com/junshi15>@junshi15</denchmark-link>\n  for noticing this commit.\n Not sure I understand why you say BaseRemoteRendezvous is used in the case of local tensor transfer between GPU and CPU on the same worker.\n <denchmark-link:https://gist.github.com/shamoya/36beb1d093d4b95a523e27d4deda16ea>This</denchmark-link>\n  is a more detailed log of the all the occurences of affine1/biases in the last iteration in worker1. We can see the RdmaRemoteRendezvous has completed successfully from the PS.\n I'm not so sure anymore this issue is even related to the Verbs code.\n \t\t"}, "comments_21": {"comment_id": 22, "comment_author": "shamoya", "commentT": "2017-07-27T21:53:37Z", "comment_text": "\n \t\t<denchmark-link:https://github.com/shamoya>@shamoya</denchmark-link>\n  RdmaRemoteRendezvous is a derived class of BaseRemoteRendezvous. The local send/receive functions are defined in the base class. RdmaRemoteRendezvous only overrides RecvFromRemoteAsync().\n \t\t"}, "comments_22": {"comment_id": 23, "comment_author": "shamoya", "commentT": "2017-08-07T16:53:00Z", "comment_text": "\n \t\t<denchmark-link:https://github.com/katyakats>@katyakats</denchmark-link>\n  When you reverted commit <denchmark-link:https://github.com/tensorflow/tensorflow/commit/626d8d905aa412aaca02d171e5e0b4a1c407656b>626d8d9</denchmark-link>\n  (Improve RDMA rendezvous speed), where did the code hang? SetProtoFromGPUSync?\n \t\t"}, "comments_23": {"comment_id": 24, "comment_author": "shamoya", "commentT": "2017-08-08T07:31:17Z", "comment_text": "\n \t\t<denchmark-link:https://github.com/junshi15>@junshi15</denchmark-link>\n  thank you! we will check this direction!\n I did not check what method is stuck when I reverted the commit. Will check this as well\n \t\t"}, "comments_24": {"comment_id": 25, "comment_author": "shamoya", "commentT": "2017-08-09T13:15:21Z", "comment_text": "\n \t\tHi <denchmark-link:https://github.com/junshi15>@junshi15</denchmark-link>\n  , following the discussion <denchmark-link:https://github.com/tensorflow/tensorflow/issues/11825>here</denchmark-link>\n  and in this bug and after I review the code, I think we have a serious issue with tolerate_dup_recv mechanism (maybe this is why it was removed ? ).\n I think <denchmark-link:https://github.com/tensorflow/tensorflow/blob/r1.3/tensorflow/core/framework/rendezvous.cc#L209>this</denchmark-link>\n  is wrong in case we don't do a duplicate receive (if we have a buffer already in some step), becasue no one will UnRef it, in case the Recv will not be called.\n Do u think it might be the issue ?\n \t\t"}, "comments_25": {"comment_id": 26, "comment_author": "shamoya", "commentT": "2017-08-09T13:34:36Z", "comment_text": "\n \t\t<denchmark-link:https://github.com/shamoya>@shamoya</denchmark-link>\n  UnRef is in <denchmark-link:https://github.com/tensorflow/tensorflow/blob/r1.3/tensorflow/core/framework/rendezvous.cc#L264>Recv</denchmark-link>\n . In what case Recv will not be called? In verbs case, Send only is only called once, but Recv is called multiple times.\n \t\t"}, "comments_26": {"comment_id": 27, "comment_author": "shamoya", "commentT": "2017-08-09T13:39:02Z", "comment_text": "\n \t\tIf Recv was called before the SEND ?\n It doesn't have to be called multiple times (only first tensor appearance)\n \t\t"}, "comments_27": {"comment_id": 28, "comment_author": "shamoya", "commentT": "2017-08-09T14:31:56Z", "comment_text": "\n \t\tIf the first Recv is called before Send, then the waiting table does not have the tensor yet, Recv will put a callback in the table and return. Now, if a second Recv is called and still before Send, I think there is an issue since we allow multiple Recvs. In this case, <denchmark-link:https://github.com/tensorflow/tensorflow/blob/r1.3/tensorflow/core/framework/rendezvous.cc#L246>an empty tensor will be received</denchmark-link>\n . We will have trouble in the downstream. Is this what you are referring to?\n \t\t"}, "comments_28": {"comment_id": 29, "comment_author": "shamoya", "commentT": "2017-08-09T19:48:02Z", "comment_text": "\n \t\tNo <denchmark-link:https://github.com/junshi15>@junshi15</denchmark-link>\n , you didn't follow me, I'll try to be more clear.\n Let's say RECV is called before SEND, and puts <denchmark-link:https://github.com/tensorflow/tensorflow/blob/master/tensorflow/contrib/verbs/rdma.cc#L678>this</denchmark-link>\n  callback in the table as u said. And let's say there's already a buffer for this tensor, meaning this callback will be called once (trigger TENSOR_WRITE).\n now SEND flow performs <denchmark-link:https://github.com/tensorflow/tensorflow/blob/r1.3/tensorflow/core/framework/rendezvous.cc#L209>this</denchmark-link>\n  Ref() before calling the callback, since it assumes the RECV  be duplicated and called again.\n But in this case it doesn't, and no one will do <denchmark-link:https://github.com/tensorflow/tensorflow/blob/r1.3/tensorflow/core/framework/rendezvous.cc#L264>this</denchmark-link>\n  Unref.\n When we are stuck in the bug, I noticed there's a huge diff between Refs and Unref on the GPU that is \"stuck\" (hundernds).\n Now, I do see <denchmark-link:https://github.com/tensorflow/tensorflow/blob/r1.3/tensorflow/core/framework/rendezvous.cc#L323>this</denchmark-link>\n  Unref, in the Item destructor, which might do the missing Unref, but I need to check if it happens.\n \t\t"}, "comments_29": {"comment_id": 30, "comment_author": "shamoya", "commentT": "2017-08-09T21:51:43Z", "comment_text": "\n \t\t<denchmark-link:https://github.com/shamoya>@shamoya</denchmark-link>\n  Thanks for the explanation. A Recv-Send sequence does increase the reference count by one for send_dev_context. This can be a problem. I tried adding Unref right after <denchmark-link:https://github.com/tensorflow/tensorflow/blob/r1.3/tensorflow/core/framework/rendezvous.cc#L219>this</denchmark-link>\n , it crashed right away.\n <denchmark-link:https://github.com/katyakats>@katyakats</denchmark-link>\n  mentioned hang at . I see similar issue. Here is a <denchmark-link:https://gist.github.com/junshi15/af3063e5bd22c911c30fcaafee060fa1>stack trace</denchmark-link>\n  I captured with gdb when the program hung. It was stuck while trying to lock a mutex. Frame <denchmark-link:https://github.com/tensorflow/tensorflow/issues/2>#2</denchmark-link>\n  is  and Frame <denchmark-link:https://github.com/tensorflow/tensorflow/issues/20>#20</denchmark-link>\n  is . Note both of them call , which uses the same lock. So a nesting call like this tries to acquire a already obtained lock, a recipe for hang. Not sure what caused this situation.\n \t\t"}, "comments_30": {"comment_id": 31, "comment_author": "shamoya", "commentT": "2017-08-10T11:42:11Z", "comment_text": "\n \t\tWowww <denchmark-link:https://github.com/junshi15>@junshi15</denchmark-link>\n , looks like this is it !\n I've ran the test with inter/intra_op_parallelism_threads = 500 and it passed (multiple times).\n It workaround the problem by reducing the probability to have this scenario (Schedule of the threadpool more likely to choose an idle thread).\n It also explains why it happens when working with real data (queue readers also use the same threads)!\n <denchmark-link:https://github.com/poxvoculi>@poxvoculi</denchmark-link>\n \n Really not clear to me how Schedule is possible on a thread which holds a mutex.\n Can't understand also where the context switch happens in this thread while it performs ThenExecute.\n Thanks <denchmark-link:https://github.com/junshi15>@junshi15</denchmark-link>\n  !\n \t\t"}, "comments_31": {"comment_id": 32, "comment_author": "shamoya", "commentT": "2017-08-10T13:29:50Z", "comment_text": "\n \t\tBy reducing the number of threads to 1 inter_thread I managed to reproduce the bug in a system with 2 GPUs per host and 2 hosts only  (2ps + 2 workers). I believe its the same issue because it occurs only when using verbs and I am getting the same backtrace as <denchmark-link:https://github.com/junshi15>@junshi15</denchmark-link>\n  did. so I think we are close.\n But I don't think ThenExecute's lock is the problem.\n I've added VLOG prints before and after the critical section, And counted them afterward. No one seems to be 'stuck' inside (locks and unlocks were equal).\n \t\t"}, "comments_32": {"comment_id": 33, "comment_author": "shamoya", "commentT": "2017-08-10T13:38:46Z", "comment_text": "\n \t\t<denchmark-link:https://github.com/shamoya>@shamoya</denchmark-link>\n  Glad we are making some progress.\n <denchmark-link:https://github.com/yanivbl6>@yanivbl6</denchmark-link>\n   Thanks for your help. This <denchmark-link:https://gist.github.com/junshi15/af3063e5bd22c911c30fcaafee060fa1#file-gistfile1-txt-L2>line</denchmark-link>\n  seems to be waiting for a mutex. We need to identify the mutex inside .\n \t\t"}, "comments_33": {"comment_id": 34, "comment_author": "shamoya", "commentT": "2017-08-10T13:50:16Z", "comment_text": "\n \t\tThis <denchmark-link:https://gist.github.com/junshi15/af3063e5bd22c911c30fcaafee060fa1#file-gistfile1-txt-L37>line</denchmark-link>\n  is not  itself. It looks like a lambda function (callback?) inside .\n \t\t"}, "comments_34": {"comment_id": 35, "comment_author": "shamoya", "commentT": "2017-08-10T13:51:18Z", "comment_text": "\n \t\tI think this line relate to the condition variable of \"Notification n\", which requires a mutex. (for waiting).\n If I got this right The condition variable is waiting for the callback, that was scheduled after the stream in ThenExecute.\n \t\t"}, "comments_35": {"comment_id": 36, "comment_author": "shamoya", "commentT": "2017-08-14T12:18:13Z", "comment_text": "\n \t\tI think the problem rises because the Sync deviceToDevice operation blocks the thread, preventing the earlier Async Device to Device operation from finishing- which, for some reason, blocks the later operation.\n What I did to check this was change the <denchmark-link:https://github.com/tensorflow/tensorflow/blob/master/tensorflow/contrib/verbs/rdma.cc#L724>call to the wrapper sync function</denchmark-link>\n  to a call to the async function, and inserted the rest of the code (that which is executed after the sync wrapper) into then lambda callback function (\"done\"). With this setting, the application no longer hangs (Tested multipile times, few of which in 8 gpus system).\n <denchmark-link:https://github.com/junshi15>@junshi15</denchmark-link>\n  , is there an additional motivation for the usage of the sync wrappers, beside the pending operations we execute after the operation is completed?\n \t\t"}, "comments_36": {"comment_id": 37, "comment_author": "shamoya", "commentT": "2017-08-14T20:30:58Z", "comment_text": "\n \t\t<denchmark-link:https://github.com/yanivbl6>@yanivbl6</denchmark-link>\n  Thanks for looking into it. There is another sync wrapper function, <denchmark-link:https://github.com/tensorflow/tensorflow/blob/master/tensorflow/contrib/verbs/rdma.cc#L730>SetProtoFromGPUSync</denchmark-link>\n . We should convert that back to async as well.\n The motivation for using sync wrapper is mainly for simplicity. Otherwise, you end up with chained call-backs, which is actually fairly common in tensorflow code.\n Please submit a PR if you have a fix.\n \t\t"}, "comments_37": {"comment_id": 38, "comment_author": "shamoya", "commentT": "2017-08-15T11:48:05Z", "comment_text": "\n \t\tGreat job <denchmark-link:https://github.com/yanivbl6>@yanivbl6</denchmark-link>\n  , looks like this is it.\n Waiting for the PR with the fix.\n Looking now in the gRPC code, they are doing this flow aysnc, this is probably why we didn't see it when running with gRPC.\n \t\t"}, "comments_38": {"comment_id": 39, "comment_author": "shamoya", "commentT": "2017-08-15T12:49:08Z", "comment_text": "\n \t\tThanks to all to solve it! Great job!  Go to check it !\n Need to put it in r1.3 and master.\n \t\t"}, "comments_39": {"comment_id": 40, "comment_author": "shamoya", "commentT": "2017-08-17T18:01:29Z", "comment_text": "\n \t\t<denchmark-link:https://github.com/poxvoculi>@poxvoculi</denchmark-link>\n  We found some of <denchmark-link:https://github.com/tensorflow/tensorflow/blob/master/tensorflow/contrib/verbs/verbs_util.cc#L23-L70>the wrapper functions</denchmark-link>\n  caused hang. Do you know whether we are not supposed to use the sync version of these functions? I know CPU/GPU transfer can be slow,  but I did not expect it to hang. Thanks.\n \t\t"}, "comments_40": {"comment_id": 41, "comment_author": "shamoya", "commentT": "2017-08-17T18:11:21Z", "comment_text": "\n \t\tI would avoid using any sync version of a function where an async version with callback is available.  The sync versions suspend a thread which could lead to a deadlock if you run out of threads.  It may be that by blocking you've also introduced a deadlock some other way, where the callback is waiting on something whose execution would have been triggered after the async invocation returned.\n \t\t"}, "comments_41": {"comment_id": 42, "comment_author": "shamoya", "commentT": "2017-08-17T20:00:04Z", "comment_text": "\n \t\t<denchmark-link:https://github.com/poxvoculi>@poxvoculi</denchmark-link>\n  What we saw matches your description. Hang happens when 4+ GPUs are used. It goes away when we increase the number of threads. <denchmark-link:https://github.com/yanivbl6>@yanivbl6</denchmark-link>\n  is working on a <denchmark-link:https://github.com/tensorflow/tensorflow/pull/12361>fix</denchmark-link>\n .\n \t\t"}, "comments_42": {"comment_id": 43, "comment_author": "shamoya", "commentT": "2017-08-24T05:21:42Z", "comment_text": "\n \t\t<denchmark-link:https://github.com/tensorflow/tensorflow/pull/12361>#12361</denchmark-link>\n  merged to master\n \t\t"}, "comments_43": {"comment_id": 44, "comment_author": "shamoya", "commentT": "2018-10-19T23:59:26Z", "comment_text": "\n \t\t\n @poxvoculi What we saw matches your description. Hang happens when 4+ GPUs are used. It goes away when we increase the number of threads. @yanivbl6 is working on a fix.\n \n <denchmark-link:https://github.com/junshi15>@junshi15</denchmark-link>\n   Cool thanks, I hit a very similar problem and got stuck during the warm up. As you suggested, I increased  to work around the problem.\n before changing the number of threads, I couldn't get this far.\n 2018-10-20 01:54:02.736996: I tensorflow/stream_executor/dso_loader.cc:151] successfully opened CUDA library libcupti.so.9.2 locally\n \t\t"}, "comments_44": {"comment_id": 45, "comment_author": "shamoya", "commentT": "2018-10-20T12:46:14Z", "comment_text": "\n \t\t<denchmark-link:https://github.com/nicolefinnie>@nicolefinnie</denchmark-link>\n  - did you experience an hang with grpc+verbs?\n This issue was (At least, to my knowledge) fixed already.\n What TF version are you experiencing this issue with?\n \t\t"}, "comments_45": {"comment_id": 46, "comment_author": "shamoya", "commentT": "2018-10-20T18:51:58Z", "comment_text": "\n \t\t<denchmark-link:https://github.com/yanivbl6>@yanivbl6</denchmark-link>\n   Thanks for your response. It's tensorflow  and I didn't specify the server protocol so it's  by default.\n \t\t"}, "comments_46": {"comment_id": 47, "comment_author": "shamoya", "commentT": "2018-10-21T02:17:21Z", "comment_text": "\n \t\t<denchmark-link:https://github.com/nicolefinnie>@nicolefinnie</denchmark-link>\n  The thread is about an issue related to grpc+verbs, and it has been fixed by <denchmark-link:https://github.com/yanivbl6>@yanivbl6</denchmark-link>\n .\n I do not know why you are experiencing the issue with grpc only.\n \t\t"}, "comments_47": {"comment_id": 48, "comment_author": "shamoya", "commentT": "2018-10-21T04:38:19Z", "comment_text": "\n \t\tI experienced an hang with the master branch and vanilla grpc about a week ago, and it was already fixed in master. I would suggest trying to pull the latest commit.\n \t\t"}}}, "commit": {"commit_id": "e650dcfb462a9efc9236e33cae87ac5bbf55d9f7", "commit_author": "yanivbl6", "commitT": "2017-08-23 21:57:07-07:00", "commit_complexity": {"commit_NLOC": "0.0", "commit_CCN": "0.0", "commit_Nprams": "0.0"}, "changed_files": {"file_0": {"file_change_type": "MODIFY", "file_Nmethod": 2, "file_old_name": "tensorflow\\contrib\\verbs\\rdma.cc", "file_new_name": "tensorflow\\contrib\\verbs\\rdma.cc", "file_complexity": {"file_NLOC": "713", "file_CCN": "103", "file_NToken": "5501"}, "hunks": {"hunk_0": {"Ismethod": 1, "added_lines": "774,775,776,777,778,779,780,781,782,783,784,785,786,787,788,789,790,791,792,793,794,795,796,797,798,799,800,801,802,803,804,805,806,807,808,809,810,811,812,813,814,815,816,817,818,819,820,821,822,823,824,825,826,827,828,829,830,831,832,833,834,835,836,837,838,839,840,841,842,843,844,845,846,847,848", "deleted_lines": "774,775,776,777,778,779,780,781,782,783,784,785,786,787,788,789,790,791,792,793,794,795,796,797,798,799,800,801,802,803,804,805,806,807,808,809,810,811,812,813,814,815,816,817,818,819,820", "method_info": {"method_name": "tensorflow::RdmaTensorBuffer::PostCopyOperations", "method_params": "can_memcpy,buffer_size,tensor_bytes,key,in,step_id,is_dead,key_with_step_id,copy,proto,copy_buf", "method_startline": "774", "method_endline": "848", "method_complexity": {"method_NLOC": "67", "method_CCN": "15", "method_NToken": "536", "method_nesting_level": "1"}}}, "hunk_1": {"Ismethod": 1, "added_lines": "723,724,725,726,727,728,729,730,731,732,733,734,735,737,738,739,740,741,742,743,744,745,746,747,748,749,753,756,759,761,762,763,764,768", "deleted_lines": "710,724,725,726,727,729,730,731,732,741,742,743,744,745,748,749,750,751,752,753,754,755,756,757,758,759,760,761,762,763,764,765,766,767,768,769,770,771,772", "method_info": {"method_name": "tensorflow::RdmaTensorBuffer::SendNextItem", "method_params": "", "method_startline": "659", "method_endline": "772", "method_complexity": {"method_NLOC": "101", "method_CCN": "7", "method_NToken": "747", "method_nesting_level": "1"}}}}}, "file_1": {"file_change_type": "MODIFY", "file_Nmethod": 0, "file_old_name": "tensorflow\\contrib\\verbs\\rdma.h", "file_new_name": "tensorflow\\contrib\\verbs\\rdma.h", "file_complexity": {"file_NLOC": "224", "file_CCN": "11", "file_NToken": "1221"}, "hunks": {"hunk_0": {"Ismethod": 0, "added_lines": "31,229,230,231,232,233,234", "deleted_lines": null}}}, "file_2": {"file_change_type": "MODIFY", "file_Nmethod": 2, "file_old_name": "tensorflow\\contrib\\verbs\\rdma_rendezvous_mgr.cc", "file_new_name": "tensorflow\\contrib\\verbs\\rdma_rendezvous_mgr.cc", "file_complexity": {"file_NLOC": "157", "file_CCN": "16", "file_NToken": "1241"}, "hunks": {"hunk_0": {"Ismethod": 1, "added_lines": "122,123,124,125,126,127,128,129,130,131,132,133,152", "deleted_lines": "116,117,118,119,138,139,140,141,142,143,144,145,146,147,148,149", "method_info": {"method_name": "tensorflow::RdmaRemoteRendezvous::RecvFromRemoteAsync", "method_params": "parsed,recv_args,done", "method_startline": "54", "method_endline": "164", "method_complexity": {"method_NLOC": "106", "method_CCN": "11", "method_NToken": "921", "method_nesting_level": "1"}}}, "hunk_1": {"Ismethod": 1, "added_lines": "166,167,168,169,170,171,172,173,174,175,176,177,178,179,180", "deleted_lines": null, "method_info": {"method_name": "tensorflow::RdmaRemoteRendezvous::RecvPostCopyOps", "method_params": "key,key_with_step_id,recv_args,done,rm,rc,val,s", "method_startline": "166", "method_endline": "180", "method_complexity": {"method_NLOC": "15", "method_CCN": "1", "method_NToken": "126", "method_nesting_level": "1"}}}}}, "file_3": {"file_change_type": "MODIFY", "file_Nmethod": 3, "file_old_name": "tensorflow\\contrib\\verbs\\verbs_util.cc", "file_new_name": "tensorflow\\contrib\\verbs\\verbs_util.cc", "file_complexity": {"file_NLOC": "18", "file_CCN": "2", "file_NToken": "129"}, "hunks": {"hunk_0": {"Ismethod": 1, "added_lines": null, "deleted_lines": "41,42,43,44,45,46,47,48,49,50,51,52,53,54,55", "method_info": {"method_name": "tensorflow::VerbsUtil::CopyCPUTensorToGPUSync", "method_params": "cpu_tensor,device_context,gpu_device,gpu_tensor", "method_startline": "41", "method_endline": "55", "method_complexity": {"method_NLOC": "15", "method_CCN": "1", "method_NToken": "78", "method_nesting_level": "1"}}}, "hunk_1": {"Ismethod": 1, "added_lines": null, "deleted_lines": "24,25,26,27,28,29,30,31,32,33,34,35,36,37,38", "method_info": {"method_name": "tensorflow::VerbsUtil::CopyGPUTensorToCPUSync", "method_params": "gpu_device,device_context,gpu_tensor,cpu_tensor", "method_startline": "24", "method_endline": "38", "method_complexity": {"method_NLOC": "15", "method_CCN": "1", "method_NToken": "78", "method_nesting_level": "1"}}}, "hunk_2": {"Ismethod": 1, "added_lines": null, "deleted_lines": "58,59,60,61,62,63,64,65,66,67,68,69,70", "method_info": {"method_name": "tensorflow::VerbsUtil::SetProtoFromGPUSync", "method_params": "tensor,dev,device_context,proto,is_dead", "method_startline": "58", "method_endline": "70", "method_complexity": {"method_NLOC": "13", "method_CCN": "1", "method_NToken": "83", "method_nesting_level": "1"}}}}}, "file_4": {"file_change_type": "MODIFY", "file_Nmethod": 0, "file_old_name": "tensorflow\\contrib\\verbs\\verbs_util.h", "file_new_name": "tensorflow\\contrib\\verbs\\verbs_util.h", "file_complexity": {"file_NLOC": "13", "file_CCN": "0", "file_NToken": "53"}, "hunks": {"hunk_0": {"Ismethod": 0, "added_lines": null, "deleted_lines": "31,32,33,34,35,36,37,38,39,40,41,42,43,44"}}}}}}