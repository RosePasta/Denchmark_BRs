{"BR": {"BR_id": "9931", "BR_author": "galeone", "BRopenT": "2017-05-16T08:52:31Z", "BRcloseT": "2017-05-17T20:01:53Z", "BR_text": {"BRsummary": "Go: SIGSEGV when using int32 instead of int64 and missing error in Resize functions", "BRdescription": "\n <denchmark-h:h2>Problem</denchmark-h>\n \n In Go, some operation causes a SIGSEGV when using an int32 instead of an int64 (and I have reasons to believe that the same will happen when using float instead of double and vice-versa).\n The Resize* operations don't define the output shape correctly when the input is not a \"batch\": they just let the dimensions undefined instead of raising some errors.\n The tests below are commented so I hope that's enough to let you understand what the problems are.\n <denchmark-h:h3>Source code / logs</denchmark-h>\n \n package poc_test\n \n import (\n         \"fmt\"\n         //tf \"github.com/tensorflow/tensorflow/tensorflow/go\"\n         \"github.com/tensorflow/tensorflow/tensorflow/go/op\"\n         \"testing\"\n )\n \n func TestResizeWithoutBatchIsNoSense(t *testing.T) {\n         // Create root scope\n         root := op.NewScope()\n \n         // Define graph\n \n         // 1: read image content\n         imagePath := \"test.jpg\"\n         contents := op.ReadFile(root.SubScope(\"ReadFile\"), op.Const(root.SubScope(\"filename\"), imagePath))\n \n         // 2: decode Jpeg\n         value := op.DecodeJpeg(root.SubScope(\"DecodeJpeg\"), contents, op.DecodeJpegChannels(3))\n \n         // I'd like to add noise to the image, so I'd like to define a nose tensor with the same shape of the image\n         // Just to be sure that the image shape is fully defined, I resize it\n         resize1 := op.ResizeNearestNeighbor(root.SubScope(\"ResizeArea\"), value, op.Const(root.SubScope(\"size\"), []int32{int32(80), int32(80)}))\n \n         // If the size parameter is an int32, no error is raised but the operation is no sense\n         // Because it returns ? instead of [80, 80, 3]\n         // The reason is taht Resize* methods requires a batch of images: should raise an error?\n         fmt.Println(\"Shape with int32: \", resize1.Shape().String())\n         if dims64, err := resize1.Shape().ToSlice(); err != nil {                                                                                                                                                                                                              \n                 fmt.Println(dims64)                                                                                                                                                                                                                                            \n         } else {                                                                                                                                                                                                                                                               \n                 t.Error(\"Error: \", err.Error())                                                                                                                                                                                                                                \n         }                                                                                                                                                                                                                                                                      \n                                                                                                                                                                                                                                                                                \n         // I expect a fully defined shape                                                                                                                                                                                                                                      \n         if !resize1.Shape().IsFullySpecified() {                                                                                                                                                                                                                               \n                 t.Error(\"Not defined shape\")                                                                                                                                                                                                                                   \n         }                                                                                                                                                                                                                                                                      \n                                                                                                                                                                                                                                                                                \n         // create the batch and see how things changes                                                                                                                                                                                                                         \n         batch := op.ExpandDims(root.SubScope(\"expand\"), value, op.Const(root.SubScope(\"axis\"), []int32{0}))                                                                                                                                                                    \n         resize1 = op.ResizeNearestNeighbor(root.SubScope(\"ResizeArea\"), batch, op.Const(root.SubScope(\"size\"), []int32{int32(80), int32(80)}))                                                                                                                                 \n         fmt.Println(\"Shape with int32 and input as a batch: \", resize1.Shape().String())                                                                                                                                                                                       \n         if dims64, err := resize1.Shape().ToSlice(); err == nil {                                                                                                                                                                                                              \n                 fmt.Println(dims64)                                                                                                                                                                                                                                            \n         } else {                                                                                                                                                                                                                                                               \n                 fmt.Println(\"Error: \", err.Error())                                                                                                                                                                                                                            \n         }                                                                                                                                                                                                                                                                      \n         // Now the things have sense and the shape is defined and equals to [ 1, 80, 80, 3]                                                                                                                                                                                    \n }                                                                                                                                                                                                                                                                              \n                                                                                                                                                                                                                                                                                \n func TestResizeWithIn64ShapeSigSegvs(t *testing.T) {                                                                                                                                                                                                                           \n         defer func() {                                                                                                                                                                                                                                                         \n                 if r := recover(); r != nil {                                                                                                                                                                                                                                  \n                         t.Error(\"Panic!\")                                                                                                                                                                                                                                      \n                 }                                                                                                                                                                                                                                                              \n         }()\n         // Create root scope\n         root := op.NewScope()\n \n         // Define graph\n \n         // 1: read image content\n         imagePath := \"test.jpg\"\n         contents := op.ReadFile(root.SubScope(\"ReadFile\"), op.Const(root.SubScope(\"filename\"), imagePath))\n \n         // 2: decode Jpeg\n         value := op.DecodeJpeg(root.SubScope(\"DecodeJpeg\"), contents, op.DecodeJpegChannels(3))\n \n         // However, changing int32 with int64 breaks everyting (no matter if I use `batch` or `value`)\n         resize2 := op.ResizeArea(root.SubScope(\"ResizeArea2\"), value, op.Const(root.SubScope(\"size2\"), []int64{int64(80), int64(80)}))\n         // This operation causes a SIGSEGV\n         fmt.Println(\"Shape value: \", resize2.Shape())\n         fmt.Println(\"Shape with int64: \", resize2.Shape().String())\n \n         // In short, chaning int32 with int64 causes SIGSEGV. It looks like kernels are not registered to handle both types\n \n         // This can bring the code to be a mess to debug, because If I'd like to, for example, add noise to an image\n         // I have to generate a set of values with the same shape of the input images.\n         // Using the one with the defined shape (the batch) I'd like to use the output of Shape().ToSlice()\n         // But I can't.\n }\n \n func TestGenerateNoiseWithInt32Shape(t *testing.T) {\n         defer func() {\n                 if r := recover(); r != nil {\n                         t.Error(\"Panic!\")\n                 }\n         }()\n         // Create root scope\n         root := op.NewScope()\n \n         // Define graph\n \n         // 1: read image content\n         imagePath := \"test.jpg\"\n         contents := op.ReadFile(root.SubScope(\"ReadFile\"), op.Const(root.SubScope(\"filename\"), imagePath))\n         // 2: decode Jpeg\n         value := op.DecodeJpeg(root.SubScope(\"DecodeJpeg\"), contents, op.DecodeJpegChannels(3))\n         batch := op.ExpandDims(root.SubScope(\"expand\"), value, op.Const(root.SubScope(\"axis\"), []int32{0}))\n         resize1 := op.ResizeNearestNeighbor(root.SubScope(\"ResizeArea\"), batch, op.Const(root.SubScope(\"size\"), []int32{int32(80), int32(80)}))\n         fmt.Println(\"Shape with int32 and input as a batch: \", resize1.Shape().String())\n         if dims64, err := resize1.Shape().ToSlice(); err != nil {\n                 fmt.Println(dims64)\n         } else {\n                 fmt.Println(\"Error: \", err.Error())\n         }\n \n         dims64, _ := resize1.Shape().ToSlice()\n         noise := op.ParameterizedTruncatedNormal(root.SubScope(\"ParameterizedTruncatedNormal\"),\n                 op.Const(root.SubScope(\"shape\"), dims64),\n                 op.Const(root.SubScope(\"means\"), 0.),\n                 op.Const(root.SubScope(\"stddev\"), 1.),\n                 op.Const(root.SubScope(\"minvals\"), 0.),\n                 op.Const(root.SubScope(\"maxvals\"), 1.))\n         fmt.Println(noise)\n \n         // ^ This operation causes SIGSEGV\n         // I have to convert dims64 to a slice of int32 and then the operation works\n \n }\n \n func TestGenerateNoiseWithInt64Shape(t *testing.T) {\n         // Create root scope\n         root := op.NewScope()\n \n         // Define graph\n \n         // 1: read image content\n         imagePath := \"test.jpg\"\n         contents := op.ReadFile(root.SubScope(\"ReadFile\"), op.Const(root.SubScope(\"filename\"), imagePath))\n         // 2: decode Jpeg\n         value := op.DecodeJpeg(root.SubScope(\"DecodeJpeg\"), contents, op.DecodeJpegChannels(3))\n         batch := op.ExpandDims(root.SubScope(\"expand\"), value, op.Const(root.SubScope(\"axis\"), []int32{0}))\n         resize1 := op.ResizeNearestNeighbor(root.SubScope(\"ResizeArea\"), batch, op.Const(root.SubScope(\"size\"), []int32{int32(80), int32(80)}))\n         fmt.Println(\"Shape with int32 and input as a batch: \", resize1.Shape().String())\n         if dims64, err := resize1.Shape().ToSlice(); err != nil {\n                 fmt.Println(dims64)\n         } else {\n                 fmt.Println(\"Error: \", err.Error())\n         }\n \n         dims64, _ := resize1.Shape().ToSlice()\n \n         var dims []int32 = make([]int32, len(dims64))\n         for i, dim := range dims64 {\n                 dims[i] = int32(dim)\n         }\n \n         noise := op.ParameterizedTruncatedNormal(root.SubScope(\"ParameterizedTruncatedNormal\"),\n                 op.Const(root.SubScope(\"shape\"), dims64),\n                 op.Const(root.SubScope(\"means\"), 0.),\n                 op.Const(root.SubScope(\"stddev\"), 1.),\n                 op.Const(root.SubScope(\"minvals\"), 0.),\n                 op.Const(root.SubScope(\"maxvals\"), 1.))\n         fmt.Println(noise.Shape().String())\n }\n <denchmark-h:h3>System information</denchmark-h>\n \n \n Have I written custom code (as opposed to using a stock example script provided in TensorFlow): yes\n OS Platform and Distribution (e.g., Linux Ubuntu 16.04): Archlinux\n TensorFlow installed from (source or binary): source\n TensorFlow version (use command below): 1.1.0-rc2\n Bazel version (if compiling from source): 0.4.5\n CUDA/cuDNN version: cuda 8, cudnn 5.1\n GPU model and memory:  GeForce GTX 1080\n Exact command to reproduce: go test\n \n \t"}, "comments": {"comments_0": {"comment_id": 1, "comment_author": "galeone", "commentT": "2017-05-16T16:13:55Z", "comment_text": "\n \t\tThanks for the report <denchmark-link:https://github.com/galeone>@galeone</denchmark-link>\n  , there are multiple things going on here.\n \n \n There was a bug in the underlying C API where it was suppressing errors during graph construction. That is fixed at head in 7d785f1, so it will be available with the 1.2 release of the TensorFlow C API\n \n \n The Scope type follows the \"builder pattern\" for graph construction. So, while op.ResizeNearestNeighbor(Scope*, ...) doesn't return an error, errors are collected in Scope.Err. This allows for more compact graph definitions (see the package example for the op package), at the cost of forgetting to check the error. Setting aside comments on the merits of this design, before using any of the returned tf.Outputs from the functions in the op package, one is encouraged to check the error. So, in line 30 of the snippet above for example, I'd suggest:\n resize1 := op.ResizeNearestNeighbor(root.SubScope(\"ResizeArea\"), value, op.Const(root.SubScope(\"size\"), []int32{int32(80), int32(80)}))\n if err := root.Err(); err != nil {\n     t.Fatal(err)\n }\n \n // If the size parameter is an int32, no error is raised but the operation is no sense\n // Because it returns ? instead of [80, 80, 3]\n // The reason is taht Resize* methods requires a batch of images: should raise an error?\n fmt.Println(\"Shape with int32: \", resize1.Shape().String())\n \n \n Regardless, the Go API should never end up with segfaults from the underlying C API (in this case, providing an invalid TF_Operation pointer). So I'm going to send a fix for that.\n \n \n Long story short: A couple of fixes will ensure error messages/panics that are more useful than the cryptic segfaults. Additionally, it's good practice to check the error on the Scope object.\n Hope that helps (will update this issue with the fix mentioned above). Comments/thoughts welcome.\n \t\t"}, "comments_1": {"comment_id": 2, "comment_author": "galeone", "commentT": "2017-05-16T17:59:55Z", "comment_text": "\n \t\tThank you for the suggestion on how to properly check for errors!\n Is somewhere documented the Scope follows the builder pattern? I guess it would be nice to put this in Scope's go-doc.\n About the point 3: what is the problem? Why it segfaults? That op has a kernel registered to handle both types or the fix is to register the missing type?\n \t\t"}, "comments_2": {"comment_id": 3, "comment_author": "galeone", "commentT": "2017-05-16T19:33:41Z", "comment_text": "\n \t\t<denchmark-link:https://github.com/galeone>@galeone</denchmark-link>\n  : I'm probably misusing the phrase \"builder pattern\" :), but yeah, it does want you to check for errors. If you'd like to contribute or suggest some changes to  or other files to help improve documentation, we'd be more than happy to look at them.\n Regarding point 3: It isn't that the kernel isn't registered, it's that the operation requires that the  argument be an int32 Tensor (see <denchmark-link:https://godoc.org/github.com/tensorflow/tensorflow/tensorflow/go/op#ResizeNearestNeighbor>godoc</denchmark-link>\n ).\n Between <denchmark-link:https://github.com/tensorflow/tensorflow/commit/7d785f1e18af9d22d940f18aac6e8c9ffd268b22>7d785f1</denchmark-link>\n  and a fix I'm about to make on the Go side, you shouldn't see any segfaults in the C API - but you may see a nil-pointer dereference in Go (because  will return nil and an error after the fix).\n Hope that helps (the fix should be in sometime tomorrow I think)\n \t\t"}, "comments_3": {"comment_id": 4, "comment_author": "galeone", "commentT": "2017-05-16T20:08:11Z", "comment_text": "\n \t\tI'll be happy to contribute! In the next days, as soon as I have time, I'm going to give a better look.\n However, since every size argument of every function requires an int32, why the .Shape() method returns a []int64? I mean, it seems not coherent. The documentation talks about int32 almost everywhere and this int64 just makes operations like the creation of a new tensor with a predefined shape (like the noise in my previous example) a problem because of the required casts.\n Isn't just better to use an int32 everywhere and thus avoid the problem? I'm pretty sure that no one will create a tensor with a dimension > 2^32 -1\n \t\t"}, "comments_4": {"comment_id": 5, "comment_author": "galeone", "commentT": "2017-05-16T20:22:50Z", "comment_text": "\n \t\tI believe the use of int32 in many operations predates efforts to accept int64 as well (see for example <denchmark-link:https://github.com/tensorflow/tensorflow/commit/91ce95d497ec2957535b2ce6a965cd8269d723e5>91ce95d</denchmark-link>\n ). So, I think some of these ops need to be updated to accept int64 as well.\n In general, having Tensors that reach > 2^32-1 dimensions isn't unheard of, especially when reshaping large batches of multi-dimensional tensors.\n \t\t"}, "comments_5": {"comment_id": 6, "comment_author": "galeone", "commentT": "2017-05-17T07:11:10Z", "comment_text": "\n \t\tAlright, thus instead of using int32 everywhere I suggest using int64 everywhere in order to maintain consistency. Or, if not everywhere, at leat use the same type for attributes that works togeather, i.e. shape and dimensions (as input and/or output parameters) should be both int64.\n \t\t"}, "comments_6": {"comment_id": 7, "comment_author": "galeone", "commentT": "2017-05-17T20:01:52Z", "comment_text": "\n \t\tThis issue should be resolved at head (and with C library compiled from head), so I'm going to close this out.\n Contributions for making more operations accept int64 for shape similar to <denchmark-link:https://github.com/tensorflow/tensorflow/commit/91ce95d497ec2957535b2ce6a965cd8269d723e5>91ce95d</denchmark-link>\n  are welcome.\n <denchmark-link:https://github.com/galeone>@galeone</denchmark-link>\n  : Hope that helps. Feel free to open a new issue if you run into more trouble. Thanks!\n \t\t"}}}, "commit": {"commit_id": "fe41d05e7c8343ed53fc788d6c312792b390f679", "commit_author": "Asim Shankar", "commitT": "2017-05-16 13:11:36-07:00", "commit_complexity": {"commit_NLOC": "1.0", "commit_CCN": "1.0", "commit_Nprams": "1.0"}, "changed_files": {"file_0": {"file_change_type": "MODIFY", "file_Nmethod": 1, "file_old_name": "tensorflow\\go\\graph.go", "file_new_name": "tensorflow\\go\\graph.go", "file_complexity": {"file_NLOC": "244", "file_CCN": "58", "file_NToken": "1854"}, "hunks": {"hunk_0": {"Ismethod": 1, "added_lines": "188,189,190,192", "deleted_lines": "188,189,190,192", "method_info": {"method_name": "AddOperation", "method_params": "OpSpec", "method_startline": "147", "method_endline": "193", "method_complexity": {"method_NLOC": "38", "method_CCN": "10", "method_NToken": "290", "method_nesting_level": "0"}}}}}, "file_1": {"file_change_type": "MODIFY", "file_Nmethod": 2, "file_old_name": "tensorflow\\go\\op\\op_test.go", "file_new_name": "tensorflow\\go\\op\\op_test.go", "file_complexity": {"file_NLOC": "35", "file_CCN": "8", "file_NToken": "248"}, "hunks": {"hunk_0": {"Ismethod": 1, "added_lines": "47,48,49,50,51,52,53,54,55,56,57", "deleted_lines": null, "method_info": {"method_name": "", "method_params": "", "method_startline": "47", "method_endline": "57", "method_complexity": {"method_NLOC": "11", "method_CCN": "4", "method_NToken": "50", "method_nesting_level": "0"}}}, "hunk_1": {"Ismethod": 1, "added_lines": "38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60", "deleted_lines": null, "method_info": {"method_name": "TestAddOperationFailure", "method_params": "T", "method_startline": "38", "method_endline": "60", "method_complexity": {"method_NLOC": "10", "method_CCN": "2", "method_NToken": "82", "method_nesting_level": "0"}}}}}, "file_2": {"file_change_type": "MODIFY", "file_Nmethod": 1, "file_old_name": "tensorflow\\go\\operation.go", "file_new_name": "tensorflow\\go\\operation.go", "file_complexity": {"file_NLOC": "69", "file_CCN": "16", "file_NToken": "487"}, "hunks": {"hunk_0": {"Ismethod": 1, "added_lines": "116,117,118,119,120", "deleted_lines": null, "method_info": {"method_name": "c", "method_params": "", "method_startline": "115", "method_endline": "122", "method_complexity": {"method_NLOC": "6", "method_CCN": "2", "method_NToken": "49", "method_nesting_level": "0"}}}}}}}}