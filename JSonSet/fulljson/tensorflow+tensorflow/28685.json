{"BR": {"BR_id": "28685", "BR_author": "EFanZh", "BRopenT": "2019-05-14T01:17:34Z", "BRcloseT": "2019-05-29T18:10:46Z", "BR_text": {"BRsummary": "The cycle detection algorithm in the variable creation has bad performance", "BRdescription": "\n System information\n \n Have I written custom code (as opposed to using a stock example script provided in TensorFlow): Yes\n OS Platform and Distribution (e.g., Linux Ubuntu 16.04): Arch Linux\n Mobile device (e.g. iPhone 8, Pixel 2, Samsung Galaxy) if the issue happens on mobile device: Don\u2019t know\n TensorFlow installed from (source or binary): Binary\n TensorFlow version (use command below): 1.13.1\n Python version: 3.7.3\n Bazel version (if compiling from source): Not used\n GCC/Compiler version (if compiling from source): Not used\n CUDA/cuDNN version: Not related\n GPU model and memory: Not related\n \n Describe the current behavior\n Maybe related: <denchmark-link:https://github.com/tensorflow/tensorflow/issues/17439>#17439</denchmark-link>\n .\n I noticed some slow variable creations. It happens when the initial value is a tensor with complex dependencies.  After some digging, I found that it may be caused by the algorithm used in the cycle detection code:\n \n \n \n tensorflow/tensorflow/python/ops/variables.py\n \n \n         Lines 2505 to 2517\n       in\n       d102214\n \n \n \n \n \n \n  def _has_cycle(op, path): \n \n \n \n  \"\"\"Detect cycles in the dependencies of `initial_value`.\"\"\" \n \n \n \n  if op.name in path: \n \n \n \n  return True \n \n \n \n  path.add(op.name) \n \n \n \n  for op_input in op.inputs: \n \n \n \n  if _has_cycle(op_input.op, path): \n \n \n \n  return True \n \n \n \n  for op_control_input in op.control_inputs: \n \n \n \n  if _has_cycle(op_control_input, path): \n \n \n \n  return True \n \n \n \n  path.remove(op.name) \n \n \n \n  return False \n \n \n \n \n \n Describe the expected behavior\n Creating a variable should be completed within acceptable time.\n Code to reproduce the issue\n You can reproduce the problem using the following code:\n import time\n \n import tensorflow as tf\n \n \n def _build_tensor(depth):\n     fibonacci = [tf.zeros(shape=()), tf.ones(shape=())]\n \n     for _ in range(depth):\n         fibonacci.append(fibonacci[-2] + fibonacci[-1])\n \n     return fibonacci[-1]\n \n \n def main():\n     for depth in range(15, 25):\n         with tf.Graph().as_default():\n             tensor = _build_tensor(depth)\n \n             start_time = time.perf_counter()\n             tf.Variable(initial_value=tensor)\n             end_time = time.perf_counter()\n \n             print('Depth = {}, Time = {}'.format(depth, end_time - start_time))\n \n \n if __name__ == '__main__':\n     main()\n Other info / logs\n Here is my output from running the code:\n <denchmark-code>Depth = 15, Time = 0.008952808999310946\n Depth = 16, Time = 0.014324793000014324\n Depth = 17, Time = 0.019670226999551232\n Depth = 18, Time = 0.03077544999996462\n Depth = 19, Time = 0.04785999100022309\n Depth = 20, Time = 0.07621835800000554\n Depth = 21, Time = 0.12341592400025547\n Depth = 22, Time = 0.19620911800029717\n Depth = 23, Time = 0.31814610099991114\n Depth = 24, Time = 0.5071976489998633\n </denchmark-code>\n \n Notice the time used for creating a variable grows exponentially.\n <denchmark-h:hr></denchmark-h>\n \n The cycle detection algorithm could be optimized to have a linear time complexity. Also, the algorithm should avoid stack overflow if the initial value has a long dependency chain.\n \t"}, "comments": {"comments_0": {"comment_id": 1, "comment_author": "EFanZh", "commentT": "2019-05-15T09:24:40Z", "comment_text": "\n \t\t<denchmark-link:https://github.com/EFanZh>@EFanZh</denchmark-link>\n   It looks like you haven't used a template to create this issue. Please resubmit your issue using a template from <denchmark-link:https://github.com/tensorflow/tensorflow/issues/new/choose>here</denchmark-link>\n . We ask users to use the template because it reduces overall time to resolve a new issue by avoiding extra communication to get to the root of the issue. We will close this issue in lieu of the new one you will create from the template. Thank you for your cooperation.\n \t\t"}, "comments_1": {"comment_id": 2, "comment_author": "EFanZh", "commentT": "2019-05-16T02:38:21Z", "comment_text": "\n \t\t<denchmark-link:https://github.com/muddham>@muddham</denchmark-link>\n  I have updated my issue, please check.\n \t\t"}, "comments_2": {"comment_id": 3, "comment_author": "EFanZh", "commentT": "2019-05-16T05:27:36Z", "comment_text": "\n \t\t<denchmark-link:https://github.com/EFanZh>@EFanZh</denchmark-link>\n  Able to reproduce the issue with the provided code.\n Depth = 15, Time = 0.014409996000040337\n Depth = 16, Time = 0.018489084000066214\n Depth = 17, Time = 0.02723818900005881\n Depth = 18, Time = 0.048183349999931124\n Depth = 19, Time = 0.07164499200007413\n Depth = 20, Time = 0.11124446999997417\n Depth = 21, Time = 0.17927562900001703\n Depth = 22, Time = 0.2863872639999272\n Depth = 23, Time = 0.4592743739999605\n Depth = 24, Time = 0.7376542980000522\n \t\t"}, "comments_3": {"comment_id": 4, "comment_author": "EFanZh", "commentT": "2019-05-29T11:10:48Z", "comment_text": "\n \t\tThanks a lot for reporting this <denchmark-link:https://github.com/EFanZh>@EFanZh</denchmark-link>\n ! The fix is on the way.\n I'm curious, what was the use-case which triggered this regression for you? In my experience complex initializers are not that common.\n \t\t"}, "comments_4": {"comment_id": 5, "comment_author": "EFanZh", "commentT": "2019-05-29T12:11:32Z", "comment_text": "\n \t\t<denchmark-link:https://github.com/superbobry>@superbobry</denchmark-link>\n  I was creating a variable to store the the result of a complex computation. The problem is that I need to store the computation result multiples, so I think I could utilize the initializer of the variable to to it, by which, I mean setting the initial value of that variable to the computation result and use the initializer as the storing operation, then my program gets stuck.\n Currently, as a workaround, I am using an zero value as the initial value of the variable, and created another assignment operation to store the computation result. But this method has two extra operations created: a tf.zeros and a tf.assign. It is not as clean as using the computation result as the initial value.\n \t\t"}, "comments_5": {"comment_id": 6, "comment_author": "EFanZh", "commentT": "2019-05-29T18:10:49Z", "comment_text": "\n \t\tAre you satisfied with the resolution of your issue?\n <denchmark-link:https://docs.google.com/forms/d/e/1FAIpQLSfaP12TRhd9xSxjXZjcZFNXPGk4kc1-qMdv3gc6bEP90vY1ew/viewform?entry.85265664=Yes&entry.2137816233=28685>Yes</denchmark-link>\n \n <denchmark-link:https://docs.google.com/forms/d/e/1FAIpQLSfaP12TRhd9xSxjXZjcZFNXPGk4kc1-qMdv3gc6bEP90vY1ew/viewform?entry.85265664=No&entry.2137816233=28685>No</denchmark-link>\n \n \t\t"}, "comments_6": {"comment_id": 7, "comment_author": "EFanZh", "commentT": "2019-05-30T00:57:10Z", "comment_text": "\n \t\t<denchmark-link:https://github.com/superbobry>@superbobry</denchmark-link>\n  I see the updated implementation is using recursion, which I think may cause stack overflow if the dependency chain becomes too long. Is it possible to implement cycle detection using a stack and loop to avoid stack overflow?\n Also, the usage of self.cached_session() in testCycleDetectionIsLinear seems unnecessary. Because new graphs are created and used inside the loop, with self.cached_session() has no effect.\n \t\t"}, "comments_7": {"comment_id": 8, "comment_author": "EFanZh", "commentT": "2019-05-30T21:17:19Z", "comment_text": "\n \t\tRecursion is indeed bounded in Python, but the default limit (1000 on Linux) seems reasonable for most (if not all) initializer graphs. Recursion in Python is also slower than iteration, but again, I'm not convinced it is worth optimizing in that particular case.\n Thanks for spotting redundant self.cached_session()!\n \t\t"}}}, "commit": {"commit_id": "fc20e9fe8223336b491cedd4bc428867bf0e7daa", "commit_author": "Sergei Lebedev", "commitT": "2019-05-29 11:08:23-07:00", "commit_complexity": {"commit_NLOC": "1.0", "commit_CCN": "1.0", "commit_Nprams": "1.0"}, "changed_files": {"file_0": {"file_change_type": "MODIFY", "file_Nmethod": 3, "file_old_name": "tensorflow\\python\\kernel_tests\\variables_test.py", "file_new_name": "tensorflow\\python\\kernel_tests\\variables_test.py", "file_complexity": {"file_NLOC": "778", "file_CCN": "64", "file_NToken": "7922"}, "hunks": {"hunk_0": {"Ismethod": 1, "added_lines": "114,115,116,117,118,119,120,121,122", "deleted_lines": null, "method_info": {"method_name": "testCyclicInitializer", "method_params": "self", "method_startline": "114", "method_endline": "122", "method_complexity": {"method_NLOC": "9", "method_CCN": "1", "method_NToken": "66", "method_nesting_level": "1"}}}, "hunk_1": {"Ismethod": 1, "added_lines": "128,129,130,131,132", "deleted_lines": null, "method_info": {"method_name": "testCycleDetectionIsLinear._build_tensor", "method_params": "depth", "method_startline": "128", "method_endline": "132", "method_complexity": {"method_NLOC": "5", "method_CCN": "2", "method_NToken": "58", "method_nesting_level": "2"}}}, "hunk_2": {"Ismethod": 1, "added_lines": "125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145", "deleted_lines": null, "method_info": {"method_name": "testCycleDetectionIsLinear", "method_params": "self", "method_startline": "125", "method_endline": "145", "method_complexity": {"method_NLOC": "12", "method_CCN": "2", "method_NToken": "94", "method_nesting_level": "1"}}}}}, "file_1": {"file_change_type": "MODIFY", "file_Nmethod": 3, "file_old_name": "tensorflow\\python\\ops\\variables.py", "file_new_name": "tensorflow\\python\\ops\\variables.py", "file_complexity": {"file_NLOC": "1414", "file_CCN": "243", "file_NToken": "6914"}, "hunks": {"hunk_0": {"Ismethod": 1, "added_lines": "2517,2518,2519,2520,2522,2523,2525,2526,2527,2528", "deleted_lines": "2516,2518,2520,2521,2522,2523,2524,2525,2527", "method_info": {"method_name": "_has_cycle", "method_params": "op,path", "method_startline": "2516", "method_endline": "2528", "method_complexity": {"method_NLOC": "12", "method_CCN": "6", "method_NToken": "71", "method_nesting_level": "0"}}}, "hunk_1": {"Ismethod": 1, "added_lines": "2512", "deleted_lines": "2511", "method_info": {"method_name": "_try_guard_against_uninitialized_dependencies", "method_params": "name,initial_value", "method_startline": "2482", "method_endline": "2514", "method_complexity": {"method_NLOC": "6", "method_CCN": "3", "method_NToken": "53", "method_nesting_level": "0"}}}, "hunk_2": {"Ismethod": 1, "added_lines": "2520,2522,2523,2525,2526,2527,2528,2529,2530,2532", "deleted_lines": "2520,2521,2522,2523,2524,2525,2527", "method_info": {"method_name": "_has_cycle", "method_params": "op,state", "method_startline": "2520", "method_endline": "2533", "method_complexity": {"method_NLOC": "12", "method_CCN": "6", "method_NToken": "86", "method_nesting_level": "0"}}}}}}}}