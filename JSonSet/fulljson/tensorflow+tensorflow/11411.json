{"BR": {"BR_id": "11411", "BR_author": "ahaider3", "BRopenT": "2017-07-10T15:50:23Z", "BRcloseT": "2018-03-26T20:14:33Z", "BR_text": {"BRsummary": "Fetching data in Distributed Tensorflow has too much latency", "BRdescription": "\n <denchmark-h:h3>System information</denchmark-h>\n \n \n Have I written custom code (as opposed to using a stock example script provided in TensorFlow):\n \n <denchmark-link:https://gist.github.com/ahaider3/ae4f6d2d790d963a93b346bb0138a41d>https://gist.github.com/ahaider3/ae4f6d2d790d963a93b346bb0138a41d</denchmark-link>\n \n The above is a simple benchmark which tests the overhead of distributed TF. It fetches a configurable sized variable from the parameter server and does a matmul on the worker. It also does a matmul from a locally stored variable on the worker. The time difference between these two operations would be the overhead I am measuring.\n \n \n OS Platform and Distribution (e.g., Linux Ubuntu 16.04):\n Linux Redhat\n \n \n TensorFlow installed from (source or binary):\n source\n \n \n TensorFlow version (use command below):\n tensorflow 1.2\n \n \n Python version:\n python 2.7.7\n \n \n Exact command to reproduce:\n \n \n python matmul_benchmark.py --num_features=256 --batch_size=128 --num_hidden=64 --job_name=ps &\n python matmul_benchmark.py --num_features=256 --batch_size=128 --num_hidden=64 --job_name=worker\n By increasing batch_size, the timing difference between local/remote computation eventually becomes negligible.\n However, for small batch sizes the overhead can become 2x/3x:\n For example, here are two runs for different model/dataset sizes:\n \n 128 features, batch size of 32, hidden layer size of 256  returns:\n Local GEMM Time:  0.0002624  Network Fetch GEMM Time: 0.0006798\n \n \n 256 features, batch size of 128, hidden layer size of 128  returns:\n Local GEMM Time: 0.0002995 Network Fetch GEMM Time: 0.0006124\n \n <denchmark-h:h3>Describe the problem</denchmark-h>\n \n Distributed tensorflow introduces overhead due to its communication stack. By overhead I mean the additional time required for workers to receive data from parameter servers when compared to doing the same computation without fetching any remote data.\n This is a problem because due to this overhead I have to use 2/3 nodes to just provide performance on-par with non-distributed (single process) tensorflow. The number of nodes required to be on-par with single process TF increases further when I use gpus.\n Fetching small variables provides a constant overhead which limits scaling and efficiency .\n This overhead creates two issues in Distributed Tensorflow:\n \n I have to add several workers just to equal the performance of a single process.\n The overhead of fetching model parameters doesn't scale but the amount of computation does\n decrease as I add more workers. Thus, once I get to a moderately small batch size for each worker I can't scale because the constant overhead of fetching remote model parameters.\n \n There have been several issues posted with distributed tensorflow. <denchmark-link:https://github.com/tensorflow/tensorflow/issues/6116>#6116</denchmark-link>\n  is an improvement to large tensor transfer while this problem exists for small tensors. <denchmark-link:https://github.com/tensorflow/tensorflow/issues/4498>#4498</denchmark-link>\n  might have been caused by CPU performance bottleneck and not network. However for my problem, network transfer is definitely the bottleneck. I have tried using RDMA and have seen minimal benefit.\n <denchmark-h:h3>Source code / logs</denchmark-h>\n \n <denchmark-link:https://gist.github.com/ahaider3/ae4f6d2d790d963a93b346bb0138a41d>https://gist.github.com/ahaider3/ae4f6d2d790d963a93b346bb0138a41d</denchmark-link>\n \n \t"}, "comments": {"comments_0": {"comment_id": 1, "comment_author": "ahaider3", "commentT": "2017-07-10T18:31:54Z", "comment_text": "\n \t\tThis is a known issue (<denchmark-link:https://github.com/tensorflow/tensorflow/issues/4498>#4498</denchmark-link>\n , <denchmark-link:https://github.com/tensorflow/tensorflow/issues/6116>#6116</denchmark-link>\n , <denchmark-link:https://github.com/tensorflow/tensorflow/issues/11196>#11196</denchmark-link>\n ) with several workarounds:\n \n Wait until #7466 is merged, which gives roughly 2-3x speedup to gRPC large tensor transport.\n Use alternative communication protocol, such as grpc+verbs or grpc+mpi. This requires RDMA capable hardware.\n Refactor your code and try to use intra-process communication.\n \n \t\t"}, "comments_1": {"comment_id": 2, "comment_author": "ahaider3", "commentT": "2017-07-10T22:07:59Z", "comment_text": "\n \t\tI am mostly interested in the performance of small tensors. I have tried grpc+verbs and haven't seen any significant benefits. I will try with MPI.\n \t\t"}, "comments_2": {"comment_id": 3, "comment_author": "ahaider3", "commentT": "2017-07-11T02:03:36Z", "comment_text": "\n \t\tI see both of your model size and batch size is small (128/256?). What's the time spent on computation each round before fetching model parameters from PS? If it only spends tens to hundreds of microseconds, I don't think the current distributed runtime could reach a performance on par to that of a single process, as there's a fixed overhead on setting up interprocess communication.\n \t\t"}, "comments_3": {"comment_id": 4, "comment_author": "ahaider3", "commentT": "2017-07-11T16:03:56Z", "comment_text": "\n \t\tWithout fetching model parameters it only takes a few hundred microseconds. Yes, that's the problem I have. My compute time per iteration is low and so going to distributed requires double/triple the time per iteration due to the fixed overhead.\n I didn't see much benefit when I was testing with grpc+verbs, but that was with larger tensors. Is there a difference between grpc+mpi or grpc+verbs when compared to grpc besides the actual communication protocol? Are tensors still serialized in the same manner? The actual communication across the network is not the bottleneck from my testing.\n \t\t"}, "comments_4": {"comment_id": 5, "comment_author": "ahaider3", "commentT": "2017-07-11T16:11:19Z", "comment_text": "\n \t\tIf you are in doubt, you could try my own GPU Direct patch <denchmark-link:https://github.com/tensorflow/tensorflow/pull/11392>#11392</denchmark-link>\n  which is theoretically of the lowest latency. It does neither memory copy nor serialization. Btw if your computation is not that complicated, you should avoid using GPU; copying data from/to GPU adds nontrivial overhead in your communication pipeline.\n \t\t"}, "comments_5": {"comment_id": 6, "comment_author": "ahaider3", "commentT": "2017-07-11T19:42:04Z", "comment_text": "\n \t\tI'm also interested in this issue, with the application of training small feedforward nets (say 200-100-50-4) as quickly as possible. Note this only has ~100KB of parameters. I'd like to run on an algorithmic minibatch size of 8K, split up among as many workers as possible (so 8 workers means each handles 1K examples per iteration). As I add more workers, the batch size per worker gets smaller, which makes connection overhead more significant (per Amdahl's law).\n I'm working on training these on CPU, storing the variables on a parameter server. I've found the connection overhead destroys parallelism, as this issue points out. The particular problem here is not low throughput for transferring large parameters, it is high latency in moving even very small amounts of data. My guess is this comes from connection setup time, and that steps such as serialization and extra copies do not help.\n I have not tried gprc+verbs or grpc+mpi, and I don't expect them to help significantly as my understanding is these protocols do the same connection establishment and then just move the tensors themselves (tiny amounts of data in my case!) through fast networking. Is this a valid understanding? Is there anywhere (docs or code) that I can learn more about network protocol involved in fetching tensors from parameter server?\n I implemented the same model with data parallelism using MPI (instead of TensorFlow's networking stack) to allreduce the gradients and found hugely better performance (running at 2 nodes results in a ~1.8x speedup instead of a slowdown).\n <denchmark-link:https://github.com/byronyi>@byronyi</denchmark-link>\n  Is their any way to avoid tensor serialization on CPU?\n \t\t"}, "comments_6": {"comment_id": 7, "comment_author": "ahaider3", "commentT": "2017-07-11T20:23:42Z", "comment_text": "\n \t\t<denchmark-link:https://github.com/eamartin>@eamartin</denchmark-link>\n  In my patch, tensors are transferred in terms of direct memory access (DMA) of the underlying tensor buffer, so there is no serialization nor memory copy. It is titled \"GPU Direct RDMA\", but certainly works for CPU as well.\n \t\t"}, "comments_7": {"comment_id": 8, "comment_author": "ahaider3", "commentT": "2017-07-12T23:55:54Z", "comment_text": "\n \t\tThanks for helping our friend <denchmark-link:https://github.com/byronyi>@byronyi</denchmark-link>\n .\n \t\t"}, "comments_8": {"comment_id": 9, "comment_author": "ahaider3", "commentT": "2017-07-13T00:03:00Z", "comment_text": "\n \t\tCan we pause on closing this until the mentioned patch is actually merged? We have not yet confirmed that serialization or memcpy's caused the overhead. Other culprits could be multiple network roundtrips causing extra latency (and killing bandwidth in the small tensor limit).\n \t\t"}, "comments_9": {"comment_id": 10, "comment_author": "ahaider3", "commentT": "2017-07-13T00:59:40Z", "comment_text": "\n \t\tTake a look at <denchmark-link:https://github.com/tensorflow/tensorflow/issues/10530>#10530</denchmark-link>\n  and you may find something that interests you.\n Let me know if you have further questions; I am more than willing to help you out.\n \t\t"}, "comments_10": {"comment_id": 11, "comment_author": "ahaider3", "commentT": "2017-07-13T07:53:35Z", "comment_text": "\n \t\tI run the script provided by@yaroslavvb in <denchmark-link:https://github.com/tensorflow/tensorflow/issues/4498>#4498</denchmark-link>\n , result for  is\n <denchmark-code>Local rate:       15962.31 MB per second\n Distributed rate: 335.68 MB per second\n </denchmark-code>\n \n and grpc+verbs is\n <denchmark-code>Local rate:       15514.35 MB per second\n Distributed rate: 1306.15 MB per second\n </denchmark-code>\n \n I'm using a 56Gbps ib network.\n \t\t"}, "comments_11": {"comment_id": 12, "comment_author": "ahaider3", "commentT": "2017-07-13T09:58:36Z", "comment_text": "\n \t\tI just ran a <denchmark-link:https://gist.github.com/shamoya/731a81a1fe3d12a2b098f8163eaab7dd/>similar script</denchmark-link>\n  in a 40Gbps RoCE setup for my GDR patch, and here's the result:\n <denchmark-code>Adding data in 100 MB chunks\n Local rate: 5243.48 MB per second\n Distributed rate: 2679.18 MB per second\n </denchmark-code>\n \n Numbers for grpc and grpc+verbs are similar to what you got (~300 MB/s and ~1300MB/s).\n To try out the result in your own environment, do change the host to one of the IB interface address you actually use, as my patch will not work for localhost or 127.0.0.1.\n \t\t"}, "comments_12": {"comment_id": 13, "comment_author": "ahaider3", "commentT": "2017-07-13T23:29:12Z", "comment_text": "\n \t\t<denchmark-link:https://github.com/suiyuan2009>@suiyuan2009</denchmark-link>\n  I am not seeing that benefit from  on my ib network. Are your results with an updated patch? I am running with TF 1.2.0.\n Here are tests with different chunk sizes:\n For 100 MB chunks with grpc:\n \n Local rate:       19761.24 MB per second\n Distributed rate: 339.71 MB per second\n \n For 512 KB chunks with grpc:\n \n Local rate:       3538.90 MB per second\n Distributed rate: 616.97 MB per second\n \n So decreasing the chunk size by 200x only increases throughput by 2x. I think the problem of large tensors is important, but small tensor transfer is also slow.\n \t\t"}, "comments_13": {"comment_id": 14, "comment_author": "ahaider3", "commentT": "2017-07-14T00:25:54Z", "comment_text": "\n \t\t<denchmark-link:https://github.com/byronyi>@byronyi</denchmark-link>\n  Please be sure to add  to your commit message in <denchmark-link:https://github.com/tensorflow/tensorflow/pull/11392>#11392</denchmark-link>\n .\n \t\t"}, "comments_14": {"comment_id": 15, "comment_author": "ahaider3", "commentT": "2017-07-14T08:54:12Z", "comment_text": "\n \t\t<denchmark-link:https://github.com/ahaider3>@ahaider3</denchmark-link>\n  , I built from official master branch, I'll try <denchmark-link:https://github.com/byronyi>@byronyi</denchmark-link>\n  's branch. I find there is not much difference between benchmark scripts which run distributed tensorflow on same machine or different machines. The script in <denchmark-link:https://github.com/tensorflow/tensorflow/issues/4498>#4498</denchmark-link>\n  performs bettern on different machines than on a single machine, weird.\n \t\t"}, "comments_15": {"comment_id": 16, "comment_author": "ahaider3", "commentT": "2017-07-14T09:30:20Z", "comment_text": "\n \t\tI find that when test with small data(10MB for example), grpc+rdma 's performance is very bad, speed decreases from 1300MB/s to less than 1000MB/s(300MB/s or 900MB/s, not stable).\n \t\t"}, "comments_16": {"comment_id": 17, "comment_author": "ahaider3", "commentT": "2017-07-14T09:41:58Z", "comment_text": "\n \t\t<denchmark-link:https://github.com/ahaider3>@ahaider3</denchmark-link>\n  <denchmark-link:https://github.com/suiyuan2009>@suiyuan2009</denchmark-link>\n  There is an important patch <denchmark-link:https://github.com/tensorflow/tensorflow/pull/10531>#10531</denchmark-link>\n  got merged after the 1.2 release, so it is expected that the current master is faster than 1.2 for  runtime.\n \t\t"}, "comments_17": {"comment_id": 18, "comment_author": "ahaider3", "commentT": "2017-07-14T11:22:39Z", "comment_text": "\n \t\tI find assign is much slow than assign_add, but I think assign should be as fast as assign_add at least.\n \t\t"}, "comments_18": {"comment_id": 19, "comment_author": "ahaider3", "commentT": "2017-07-14T22:05:29Z", "comment_text": "\n \t\t<denchmark-link:https://github.com/suiyuan2009>@suiyuan2009</denchmark-link>\n \n I've noticed this issue, too. I'm testing my GDR patch using the <denchmark-link:https://gist.github.com/yaroslavvb/e196107b5e0afc834652bd3153030c42>benchmark_grpc_recv.py</denchmark-link>\n  script (courtesy <denchmark-link:https://github.com/yaroslavvb>@yaroslavvb</denchmark-link>\n ).\n For assign, 3 measurements in a row:\n <denchmark-code>Local rate:       6944.22 MB/s\n Distributed rate: 2690.64 MB/s\n ---\n Local rate:       5084.81 MB/s\n Distributed rate: 2910.57 MB/s\n ---\n Local rate:       5864.24 MB/s\n Distributed rate: 2588.69 MB/s\n </denchmark-code>\n \n For assign_add:\n <denchmark-code>Local rate:       16558.85 MB/s\n Distributed rate: 3248.83 MB/s\n ---\n Local rate:       9952.02 MB/s\n Distributed rate: 3681.21 MB/s\n ---\n Local rate:       16090.50 MB/s\n Distributed rate: 3418.83 MB/s\n </denchmark-code>\n \n But the variance of these measurements (running on the same machine) seems to be just as large as the throughput gap. So I would rather not take it as a serious issue or a performance bug.\n \t\t"}, "comments_19": {"comment_id": 20, "comment_author": "ahaider3", "commentT": "2017-08-09T18:22:30Z", "comment_text": "\n \t\t<denchmark-link:https://github.com/eamartin>@eamartin</denchmark-link>\n  As GDR is available in current master <denchmark-link:https://github.com/tensorflow/tensorflow/pull/11392>#11392</denchmark-link>\n , would you mind to try again? It does no tensor serialisation nor memory copies for tensor data.\n Since all three extension protocol still use grpc heavily for the control plane, <denchmark-link:https://github.com/ahaider3>@ahaider3</denchmark-link>\n  you might not see much difference as your computation is way too fast compared to the fixed overhead of setting up each tensor transmission (it is rather a latency issue, not a throughput one). I personally would try to port grpc from HTTP2 to RDMA, but it will be a patch unlikely to be accepted by the grpc project as indicated <denchmark-link:https://github.com/tensorflow/tensorflow/issues/2916#issuecomment-253924638>here</denchmark-link>\n .\n <denchmark-link:https://github.com/jart>@jart</denchmark-link>\n  Any comments?\n \t\t"}, "comments_20": {"comment_id": 21, "comment_author": "ahaider3", "commentT": "2017-08-16T09:21:17Z", "comment_text": "\n \t\t<denchmark-link:https://github.com/caffe2/caffe2/tree/master/caffe2/contrib/gloo>https://github.com/caffe2/caffe2/tree/master/caffe2/contrib/gloo</denchmark-link>\n \n <denchmark-link:https://github.com/facebookincubator/gloo#benchmarking>https://github.com/facebookincubator/gloo#benchmarking</denchmark-link>\n \n \t\t"}, "comments_21": {"comment_id": 22, "comment_author": "ahaider3", "commentT": "2017-08-17T22:47:13Z", "comment_text": "\n \t\tI ran the tests again using TF 1.2 with the different extension protocols that I can run on my system. In my case, I can only use grpc+verbs.\n I found minimal to no benefit from using this protocol for my small model. I am measuring the throughput of fetching a parameter and then doing a GEMM.\n \n 128 features; 32 batch size; 256 hidden layer size\n grpc:  192.81 MB/sec\n grpc+verbs: 179.18 MB/sec\n \n This was the average of three runs. I would conclude that these protocols are limited by GRPC because of the latency it introduces, as suggested by <denchmark-link:https://github.com/byronyi>@byronyi</denchmark-link>\n  .\n There has been interesting work by Uber to make communication all-around more efficient: <denchmark-link:https://github.com/uber/horovod>https://github.com/uber/horovod</denchmark-link>\n \n <denchmark-link:https://github.com/jart>@jart</denchmark-link>\n  what do you think about uber's method for distributed training.\n \t\t"}, "comments_22": {"comment_id": 23, "comment_author": "ahaider3", "commentT": "2017-08-17T23:13:44Z", "comment_text": "\n \t\tHorovod uses NCCL 2, which supports InfiniBand but not RoCE. See <denchmark-link:https://github.com/uber/horovod/issues/5>here</denchmark-link>\n .\n \t\t"}, "comments_23": {"comment_id": 24, "comment_author": "ahaider3", "commentT": "2017-11-03T13:30:27Z", "comment_text": "\n \t\tI report the same problem as <denchmark-link:https://github.com/ahaider3>@ahaider3</denchmark-link>\n  that small mini-batch on small model is terrible for distributed training using cpu.\n When I train a deep&wide model with about 15 feas, embedding_size=32, I tried the 2/3/4 machine of ps+worker and ends up with the same speed as one machine of all in one process.\n Only after increasing embedding_size to 256 give a 2x speed up with 4 machine.\n \t\t"}, "comments_24": {"comment_id": 25, "comment_author": "ahaider3", "commentT": "2017-12-20T19:10:03Z", "comment_text": "\n \t\tIt has been 14 days with no activity and this issue has an assignee.Please update the label and/or status accordingly.\n \t\t"}, "comments_25": {"comment_id": 26, "comment_author": "ahaider3", "commentT": "2018-01-04T19:07:54Z", "comment_text": "\n \t\tIt has been 14 days with no activity and this issue has an assignee.Please update the label and/or status accordingly.\n \t\t"}, "comments_26": {"comment_id": 27, "comment_author": "ahaider3", "commentT": "2018-01-24T13:25:09Z", "comment_text": "\n \t\tNagging Assignee: It has been 14 days with no activity and this issue has an assignee. Please update the label and/or status accordingly.\n \t\t"}, "comments_27": {"comment_id": 28, "comment_author": "ahaider3", "commentT": "2018-02-08T19:33:48Z", "comment_text": "\n \t\tNagging Assignee: It has been 14 days with no activity and this issue has an assignee. Please update the label and/or status accordingly.\n \t\t"}, "comments_28": {"comment_id": 29, "comment_author": "ahaider3", "commentT": "2018-02-23T14:12:27Z", "comment_text": "\n \t\tNagging Assignee: It has been 14 days with no activity and this issue has an assignee. Please update the label and/or status accordingly.\n \t\t"}, "comments_29": {"comment_id": 30, "comment_author": "ahaider3", "commentT": "2018-03-10T13:20:03Z", "comment_text": "\n \t\tNagging Assignee <denchmark-link:https://github.com/jart>@jart</denchmark-link>\n : It has been 14 days with no activity and this issue has an assignee. Please update the label and/or status accordingly.\n \t\t"}, "comments_30": {"comment_id": 31, "comment_author": "ahaider3", "commentT": "2018-03-25T12:40:35Z", "comment_text": "\n \t\tNagging Assignee <denchmark-link:https://github.com/jart>@jart</denchmark-link>\n : It has been 14 days with no activity and this issue has an assignee. Please update the label and/or status accordingly.\n \t\t"}, "comments_31": {"comment_id": 32, "comment_author": "ahaider3", "commentT": "2018-03-26T08:33:11Z", "comment_text": "\n \t\tI think we should close this issue as it appears to be resolved?\n \t\t"}, "comments_32": {"comment_id": 33, "comment_author": "ahaider3", "commentT": "2018-03-26T20:14:33Z", "comment_text": "\n \t\tThanks for the tip. Closing now that PR is merged. <denchmark-link:https://github.com/tensorflow/tensorflow/pull/11392>#11392</denchmark-link>\n \n \t\t"}}}, "commit": {"commit_id": "11e2aef14f7f2d862363c350ca1d67b87ea6a57b", "commit_author": "Bairen Yi", "commitT": "2017-08-09 08:58:12-07:00", "commit_complexity": {"commit_NLOC": "0.24731182795698925", "commit_CCN": "0.43010752688172044", "commit_Nprams": "0.4327956989247312"}, "changed_files": {"file_0": {"file_change_type": "MODIFY", "file_Nmethod": 1, "file_old_name": "configure.py", "file_new_name": "configure.py", "file_complexity": {"file_NLOC": "623", "file_CCN": "128", "file_NToken": "3382"}, "hunks": {"hunk_0": {"Ismethod": 1, "added_lines": "943,944", "deleted_lines": null, "method_info": {"method_name": "main", "method_params": "", "method_startline": "913", "method_endline": "977", "method_complexity": {"method_NLOC": "50", "method_CCN": "8", "method_NToken": "287", "method_nesting_level": "0"}}}}}, "file_1": {"file_change_type": "MODIFY", "file_Nmethod": 0, "file_old_name": "tensorflow\\BUILD", "file_new_name": "tensorflow\\BUILD", "file_complexity": {"file_NLOC": "None", "file_CCN": "None", "file_NToken": "None"}, "hunks": {"hunk_0": {"Ismethod": 0, "added_lines": "185,186,187,188,189,190", "deleted_lines": null}}}, "file_2": {"file_change_type": "MODIFY", "file_Nmethod": 1, "file_old_name": "tensorflow\\c\\c_api.cc", "file_new_name": "tensorflow\\c\\c_api.cc", "file_complexity": {"file_NLOC": "1957", "file_CCN": "439", "file_NToken": "15676"}, "hunks": {"hunk_0": {"Ismethod": 1, "added_lines": "158", "deleted_lines": "158", "method_info": {"method_name": "deallocate_buffer", "method_params": "data,len,arg", "method_startline": "157", "method_endline": "165", "method_complexity": {"method_NLOC": "9", "method_CCN": "3", "method_NToken": "67", "method_nesting_level": "2"}}}}}, "file_3": {"file_change_type": "ADD", "file_Nmethod": 0, "file_old_name": "None", "file_new_name": "tensorflow\\contrib\\gdr\\BUILD", "file_complexity": {"file_NLOC": "None", "file_CCN": "None", "file_NToken": "None"}}, "file_4": {"file_change_type": "ADD", "file_Nmethod": 0, "file_old_name": "None", "file_new_name": "tensorflow\\contrib\\gdr\\README.md", "file_complexity": {"file_NLOC": "None", "file_CCN": "None", "file_NToken": "None"}}, "file_5": {"file_change_type": "ADD", "file_Nmethod": 0, "file_old_name": "None", "file_new_name": "tensorflow\\contrib\\gdr\\gdr.proto", "file_complexity": {"file_NLOC": "None", "file_CCN": "None", "file_NToken": "None"}}, "file_6": {"file_change_type": "ADD", "file_Nmethod": 0, "file_old_name": "None", "file_new_name": "tensorflow\\contrib\\gdr\\gdr_memory_manager.cc", "file_complexity": {"file_NLOC": "551", "file_CCN": "109", "file_NToken": "4099"}}, "file_7": {"file_change_type": "ADD", "file_Nmethod": 0, "file_old_name": "None", "file_new_name": "tensorflow\\contrib\\gdr\\gdr_memory_manager.h", "file_complexity": {"file_NLOC": "25", "file_CCN": "0", "file_NToken": "136"}}, "file_8": {"file_change_type": "ADD", "file_Nmethod": 0, "file_old_name": "None", "file_new_name": "tensorflow\\contrib\\gdr\\gdr_rendezvous_mgr.cc", "file_complexity": {"file_NLOC": "149", "file_CCN": "24", "file_NToken": "966"}}, "file_9": {"file_change_type": "ADD", "file_Nmethod": 0, "file_old_name": "None", "file_new_name": "tensorflow\\contrib\\gdr\\gdr_rendezvous_mgr.h", "file_complexity": {"file_NLOC": "16", "file_CCN": "0", "file_NToken": "61"}}, "file_10": {"file_change_type": "ADD", "file_Nmethod": 0, "file_old_name": "None", "file_new_name": "tensorflow\\contrib\\gdr\\gdr_server_lib.cc", "file_complexity": {"file_NLOC": "95", "file_CCN": "15", "file_NToken": "607"}}, "file_11": {"file_change_type": "ADD", "file_Nmethod": 0, "file_old_name": "None", "file_new_name": "tensorflow\\contrib\\gdr\\gdr_server_lib.h", "file_complexity": {"file_NLOC": "21", "file_CCN": "0", "file_NToken": "114"}}, "file_12": {"file_change_type": "ADD", "file_Nmethod": 0, "file_old_name": "None", "file_new_name": "tensorflow\\contrib\\gdr\\gdr_worker.cc", "file_complexity": {"file_NLOC": "106", "file_CCN": "14", "file_NToken": "684"}}, "file_13": {"file_change_type": "ADD", "file_Nmethod": 0, "file_old_name": "None", "file_new_name": "tensorflow\\contrib\\gdr\\gdr_worker.h", "file_complexity": {"file_NLOC": "14", "file_CCN": "0", "file_NToken": "60"}}, "file_14": {"file_change_type": "MODIFY", "file_Nmethod": 0, "file_old_name": "tensorflow\\core\\BUILD", "file_new_name": "tensorflow\\core\\BUILD", "file_complexity": {"file_NLOC": "None", "file_CCN": "None", "file_NToken": "None"}, "hunks": {"hunk_0": {"Ismethod": 0, "added_lines": "119,1338,1339", "deleted_lines": "1337"}}}, "file_15": {"file_change_type": "MODIFY", "file_Nmethod": 2, "file_old_name": "tensorflow\\core\\common_runtime\\gpu\\gpu_device.cc", "file_new_name": "tensorflow\\core\\common_runtime\\gpu\\gpu_device.cc", "file_complexity": {"file_NLOC": "802", "file_CCN": "138", "file_NToken": "5767"}, "hunks": {"hunk_0": {"Ismethod": 1, "added_lines": "124", "deleted_lines": "123", "method_info": {"method_name": "tensorflow::EigenCudaStreamDevice::deallocate", "method_params": "buffer", "method_startline": "123", "method_endline": "132", "method_complexity": {"method_NLOC": "10", "method_CCN": "3", "method_NToken": "77", "method_nesting_level": "2"}}}, "hunk_1": {"Ismethod": 1, "added_lines": "116,117", "deleted_lines": "116", "method_info": {"method_name": "tensorflow::EigenCudaStreamDevice::allocate", "method_params": "num_bytes", "method_startline": "104", "method_endline": "122", "method_complexity": {"method_NLOC": "19", "method_CCN": "5", "method_NToken": "108", "method_nesting_level": "2"}}}}}, "file_16": {"file_change_type": "MODIFY", "file_Nmethod": 2, "file_old_name": "tensorflow\\core\\common_runtime\\gpu\\process_state.cc", "file_new_name": "tensorflow\\core\\common_runtime\\gpu\\process_state.cc", "file_complexity": {"file_NLOC": "199", "file_CCN": "46", "file_NToken": "1323"}, "hunks": {"hunk_0": {"Ismethod": 1, "added_lines": "240,247", "deleted_lines": "240,247", "method_info": {"method_name": "tensorflow::ProcessState::GetCUDAHostAllocator", "method_params": "numa_node", "method_startline": "202", "method_endline": "262", "method_complexity": {"method_NLOC": "44", "method_CCN": "10", "method_NToken": "313", "method_nesting_level": "1"}}}, "hunk_1": {"Ismethod": 1, "added_lines": "170,195", "deleted_lines": "170,195", "method_info": {"method_name": "tensorflow::ProcessState::GetCPUAllocator", "method_params": "numa_node", "method_startline": "154", "method_endline": "200", "method_complexity": {"method_NLOC": "39", "method_CCN": "6", "method_NToken": "253", "method_nesting_level": "1"}}}}}, "file_17": {"file_change_type": "MODIFY", "file_Nmethod": 1, "file_old_name": "tensorflow\\core\\distributed_runtime\\rpc\\grpc_remote_worker.cc", "file_new_name": "tensorflow\\core\\distributed_runtime\\rpc\\grpc_remote_worker.cc", "file_complexity": {"file_NLOC": "251", "file_CCN": "37", "file_NToken": "1751"}, "hunks": {"hunk_0": {"Ismethod": 1, "added_lines": "136,139,183", "deleted_lines": "132,133,134,135,136,137,138,143,145,146,147,148,149,150,152,153", "method_info": {"method_name": "tensorflow::GrpcRemoteWorker::RecvTensorAsync", "method_params": "call_opts,request,response,done", "method_startline": "128", "method_endline": "184", "method_complexity": {"method_NLOC": "42", "method_CCN": "6", "method_NToken": "343", "method_nesting_level": "2"}}}}}, "file_18": {"file_change_type": "MODIFY", "file_Nmethod": 3, "file_old_name": "tensorflow\\core\\distributed_runtime\\rpc\\grpc_server_lib.cc", "file_new_name": "tensorflow\\core\\distributed_runtime\\rpc\\grpc_server_lib.cc", "file_complexity": {"file_NLOC": "325", "file_CCN": "52", "file_NToken": "2092"}, "hunks": {"hunk_0": {"Ismethod": 1, "added_lines": "250", "deleted_lines": null, "method_info": {"method_name": "tensorflow::GrpcServer::Init", "method_params": "", "method_startline": "250", "method_endline": "250", "method_complexity": {"method_NLOC": "1", "method_CCN": "1", "method_NToken": "17", "method_nesting_level": "1"}}}, "hunk_1": {"Ismethod": 1, "added_lines": "244,245,246,247,248", "deleted_lines": null, "method_info": {"method_name": "tensorflow::GrpcServer::Init", "method_params": "service_func,rendezvous_mgr_func", "method_startline": "244", "method_endline": "248", "method_complexity": {"method_NLOC": "5", "method_CCN": "1", "method_NToken": "24", "method_nesting_level": "1"}}}, "hunk_2": {"Ismethod": 1, "added_lines": "108,109,187,188", "deleted_lines": "108,186,242", "method_info": {"method_name": "tensorflow::GrpcServer::Init", "method_params": "service_func,rendezvous_mgr_func,worker_func", "method_startline": "106", "method_endline": "242", "method_complexity": {"method_NLOC": "107", "method_CCN": "12", "method_NToken": "802", "method_nesting_level": "1"}}}}}, "file_19": {"file_change_type": "MODIFY", "file_Nmethod": 0, "file_old_name": "tensorflow\\core\\distributed_runtime\\rpc\\grpc_server_lib.h", "file_new_name": "tensorflow\\core\\distributed_runtime\\rpc\\grpc_server_lib.h", "file_complexity": {"file_NLOC": "68", "file_CCN": "3", "file_NToken": "408"}, "hunks": {"hunk_0": {"Ismethod": 0, "added_lines": "48,49,50,51,71,72,73,74", "deleted_lines": null}}}, "file_20": {"file_change_type": "MODIFY", "file_Nmethod": 0, "file_old_name": "tensorflow\\core\\distributed_runtime\\rpc\\grpc_worker_service.h", "file_new_name": "tensorflow\\core\\distributed_runtime\\rpc\\grpc_worker_service.h", "file_complexity": {"file_NLOC": "22", "file_CCN": "0", "file_NToken": "105"}, "hunks": {"hunk_0": {"Ismethod": 0, "added_lines": "37,38,39,40", "deleted_lines": "37,38"}}}, "file_21": {"file_change_type": "MODIFY", "file_Nmethod": 0, "file_old_name": "tensorflow\\core\\platform\\default\\build_config.bzl", "file_new_name": "tensorflow\\core\\platform\\default\\build_config.bzl", "file_complexity": {"file_NLOC": "None", "file_CCN": "None", "file_NToken": "None"}, "hunks": {"hunk_0": {"Ismethod": 0, "added_lines": "296,297,298,299,300,301", "deleted_lines": null}}}, "file_22": {"file_change_type": "MODIFY", "file_Nmethod": 0, "file_old_name": "tensorflow\\core\\platform\\default\\build_config_root.bzl", "file_new_name": "tensorflow\\core\\platform\\default\\build_config_root.bzl", "file_complexity": {"file_NLOC": "None", "file_CCN": "None", "file_NToken": "None"}, "hunks": {"hunk_0": {"Ismethod": 0, "added_lines": "42,43,44,45,46,47,48,49", "deleted_lines": null}}}, "file_23": {"file_change_type": "MODIFY", "file_Nmethod": 0, "file_old_name": "tensorflow\\python\\BUILD", "file_new_name": "tensorflow\\python\\BUILD", "file_complexity": {"file_NLOC": "None", "file_CCN": "None", "file_NToken": "None"}, "hunks": {"hunk_0": {"Ismethod": 0, "added_lines": "33,2863,2864", "deleted_lines": "2862"}}}, "file_24": {"file_change_type": "MODIFY", "file_Nmethod": 0, "file_old_name": "tensorflow\\tools\\pip_package\\build_pip_package.sh", "file_new_name": "tensorflow\\tools\\pip_package\\build_pip_package.sh", "file_complexity": {"file_NLOC": "None", "file_CCN": "None", "file_NToken": "None"}, "hunks": {"hunk_0": {"Ismethod": 0, "added_lines": "55,56", "deleted_lines": null}}}}}}