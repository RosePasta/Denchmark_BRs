{"BR": {"BR_id": "3810", "BR_author": "phoenix-meadowlark", "BRopenT": "2020-11-13T00:05:07Z", "BRcloseT": "2020-12-23T21:14:29Z", "BR_text": {"BRsummary": "DeduplicateExecutablesPass is ignoring operands and producing incorrect programs", "BRdescription": "\n While working on new tests for the tensorflow integrations I found two examples of MLIR files with identical functions that appear to be affected by the presence of other function defs during compilation.\n In one case the error happens after compiling a function  to VMLA. In the <denchmark-link:https://gist.github.com/phoenix-meadowlark/ae43e87e3e35490fb77507e08290d842>first file</denchmark-link>\n , compiling  with only  also in the file behaves as expected. In the <denchmark-link:https://gist.github.com/phoenix-meadowlark/9d8b87bd10c3750b5cdfa4e1b847faeb#file-iree_input__multiple_functions__multiply-mlir-L574>second file</denchmark-link>\n , compiling  produces a function which incorrectly returns all zeros:\n <denchmark-code>Trace of tf/math/multiple_functions__iree_vmla/static_dims compiled to 'iree_vmla' on function 'multiply_float32':\n   1. Method: multiply_float32\n     Inputs: 1x1x1x2x2x2x2xf32, 1x1x1x2x2x2x2xf32\n       [[[[[[[ 0.09762701  0.43037874]\n             [ 0.20552675  0.08976637]]\n \n            [[-0.1526904   0.29178822]\n             [-0.12482557  0.78354603]]]\n \n \n           [[[ 0.92732555 -0.23311697]\n             [ 0.5834501   0.05778984]]\n \n            [[ 0.13608912  0.85119325]\n             [-0.85792786 -0.8257414 ]]]]]]]\n       [[[[[[[-0.9595632   0.6652397 ]\n             [ 0.5563135   0.74002427]]\n \n            [[ 0.9572367   0.59831715]\n             [-0.07704128  0.56105834]]]\n \n \n           [[[-0.76345116  0.27984205]\n             [-0.71329343  0.88933784]]\n \n            [[ 0.04369664 -0.17067613]\n             [-0.47088876  0.5484674 ]]]]]]]\n     Outputs: 1x1x1x2x2x2x2xf32\n       [[[[[[[0. 0.]\n             [0. 0.]]\n \n            [[0. 0.]\n             [0. 0.]]]\n \n \n           [[[0. 0.]\n             [0. 0.]]\n \n            [[0. 0.]\n             [0. 0.]]]]]]]\n     Tolerances:\n       rtol=1e-06, atol=1e-06\n </denchmark-code>\n \n In one case the error happens while compiling a function  to LLVM or Vulkan. In the <denchmark-link:https://gist.github.com/phoenix-meadowlark/0145f1967257a1d817e152548c96cf98>first file</denchmark-link>\n , compiling  with only  also in the file behaves as expected. In the <denchmark-link:https://gist.github.com/phoenix-meadowlark/26c4b532ba644d18e83e6044381e8267#file-iree_input__multiple_functions__square-mlir-L741>second file</denchmark-link>\n , compilation results in the following mangled stack trace:\n <denchmark-code>*** END MANGLED STACK TRACE ***\n \n *** Begin stack trace ***\n         tensorflow::CurrentStackTrace()\n \n \n         iree::hal::vmla::Buffer::MakeRange(unsigned int, unsigned int) const\n         iree::StatusOr<absl::lts_2020_02_25::Span<unsigned char> > iree::hal::vmla::Buffer::RangeAs<unsigned char>(unsigned int, unsigned int)\n \n \n \n \n \n         iree_vm_bytecode_dispatch\n \n \n         iree_vm_invoke\n         iree::hal::vmla::VMLAExecutable::DispatchTile(iree::hal::HostExecutable::DispatchState*, std::array<unsigned int, 3ul>)\n         iree::hal::host::SerialCommandProcessor::DispatchGrid(iree::hal::Executable*, int, std::array<unsigned int, 3ul>)\n         iree::hal::host::SerialCommandProcessor::Dispatch(iree::hal::Executable*, int, std::array<unsigned int, 3ul>)\n         iree::hal::host::InProcCommandBuffer::ProcessCmd(iree::hal::host::InProcCommandBuffer::CmdHeader*, iree::hal::CommandBuffer*) const\n         iree::hal::host::InProcCommandBuffer::Process(iree::hal::CommandBuffer*) const\n \n \n         iree::hal::host::SerialSubmissionQueue::ProcessBatch(iree::hal::host::SerialSubmissionQueue::PendingBatch const&, std::function<iree::Status (absl::lts_2020_02_25::Span<iree::hal::CommandBuffer* const>)> const&)\n         iree::hal::host::SerialSubmissionQueue::ProcessBatches(std::function<iree::Status (absl::lts_2020_02_25::Span<iree::hal::CommandBuffer* const>)>)\n         iree::hal::host::AsyncCommandQueue::ThreadMain()\n \n \n         clone\n *** End stack trace ***\n </denchmark-code>\n \n From what I understand the MLIR files should be enough for reproducibility, but I'll also add instructions for reproducing from within the integrations once the code that generates these files is landed.\n \t"}, "comments": {"comments_0": {"comment_id": 1, "comment_author": "phoenix-meadowlark", "commentT": "2020-11-22T06:18:47Z", "comment_text": "\n \t\tHow are you running these? I'm skeptical this may be related to anything in either the compiler or runtime and is more likely in the runner.\n \t\t"}, "comments_1": {"comment_id": 2, "comment_author": "phoenix-meadowlark", "commentT": "2020-11-22T19:22:18Z", "comment_text": "\n \t\tI was able to narrow down the bug to a minimal set of mutually exclusive functions, which let me use iree-run-mlir more reasonably. I listed a number of reproducers below. For the generated IR I removed the f32 functions and reduced the rank to 1, and the bug persists.\n <denchmark-h:h4>Failing: via bazel</denchmark-h>\n \n bazel run integrations/tensorflow/e2e/math:math_test_manual -- \\\n   --target_backends=iree_vmla \\\n   --functions=multiply,square\n This reproduces the stack trace above.\n <denchmark-h:h4>iree_input.mlir for --functions=multiply,square</denchmark-h>\n \n module attributes {tf.versions = {bad_consumers = [], min_consumer = 12 : i32, producer = 586 : i32}}  {\n   func @multiply__2_2__i32__uniform(%arg0: tensor<2xi32> {tf._user_specified_name = \"args_0\"}, %arg1: tensor<2xi32> {tf._user_specified_name = \"args_1\"}) -> tensor<2xi32> attributes {iree.module.export, iree.reflection = {abi = \"sip\", abiv = 1 : i32, sip = \"I12!S9!k0_0k1_1R3!_0\"}, tf._input_shapes = [#tf.shape<2>, #tf.shape<2>]} {\n     %0 = mhlo.multiply %arg0, %arg1 : tensor<2xi32>\n     return %0 : tensor<2xi32>\n   }\n   func @square__2__i32__uniform(%arg0: tensor<2xi32> {tf._user_specified_name = \"args_0\"}) -> tensor<2xi32> attributes {iree.module.export, iree.reflection = {abi = \"sip\", abiv = 1 : i32, sip = \"I8!S5!k0_0R3!_0\"}, tf._input_shapes = [#tf.shape<2>]} {\n     %0 = mhlo.multiply %arg0, %arg0 : tensor<2xi32>\n     return %0 : tensor<2xi32>\n   }\n }\n <denchmark-h:h4>Passing: iree_input.mlir for --functions=multiply</denchmark-h>\n \n module attributes {tf.versions = {bad_consumers = [], min_consumer = 12 : i32, producer = 586 : i32}}  {\n   func @multiply__2_2__i32__uniform(%arg0: tensor<2xi32> {tf._user_specified_name = \"args_0\"}, %arg1: tensor<2xi32> {tf._user_specified_name = \"args_1\"}) -> tensor<2xi32> attributes {iree.module.export, iree.reflection = {abi = \"sip\", abiv = 1 : i32, sip = \"I12!S9!k0_0k1_1R3!_0\"}, tf._input_shapes = [#tf.shape<2>, #tf.shape<2>]} {\n     %0 = mhlo.multiply %arg0, %arg1 : tensor<2xi32>\n     return %0 : tensor<2xi32>\n   }\n }\n bazel run iree/tools:iree-run-mlir -- \\\n   -export-all -iree-hal-target-backends=vmla \\\n   -function-input='2xi32=2 3' \\\n   -function-input='2xi32=5 7' \\\n   /tmp/iree/modules/tf/math/multiply/static_dims/iree_input.mlir\n <denchmark-code>I iree/tools/iree-run-mlir-main.cc:205] Compiling for target backend 'vmla*'...\n I iree/tools/iree-run-mlir-main.cc:325] Evaluating all functions in module for driver 'vmla'...\n I iree/tools/utils/vm_util.cc:227] Creating driver and device for 'vmla'...\n EXEC @multiply__2_2__i32__uniform\n I iree/tools/utils/vm_util.cc:172] result[0]: Buffer<sint32[2]>\n 2xi32=10 21\n </denchmark-code>\n \n <denchmark-h:h4>Passing: iree_input.mlir for --functions=square</denchmark-h>\n \n module attributes {tf.versions = {bad_consumers = [], min_consumer = 12 : i32, producer = 586 : i32}}  {\n   func @square__2__i32__uniform(%arg0: tensor<2xi32> {tf._user_specified_name = \"args_0\"}) -> tensor<2xi32> attributes {iree.module.export, iree.reflection = {abi = \"sip\", abiv = 1 : i32, sip = \"I8!S5!k0_0R3!_0\"}, tf._input_shapes = [#tf.shape<2>]} {\n     %0 = mhlo.multiply %arg0, %arg0 : tensor<2xi32>\n     return %0 : tensor<2xi32>\n   }\n }\n bazel run iree/tools:iree-run-mlir -- \\\n   -export-all -iree-hal-target-backends=vmla \\\n   -function-input='2xi32=2 3' \\\n   /tmp/iree/modules/tf/math/square/static_dims/iree_input.mlir\n <denchmark-code>I iree/tools/iree-run-mlir-main.cc:205] Compiling for target backend 'vmla*'...\n I iree/tools/iree-run-mlir-main.cc:325] Evaluating all functions in module for driver 'vmla'...\n I iree/tools/utils/vm_util.cc:227] Creating driver and device for 'vmla'...\n EXEC @square__2__i32__uniform\n I iree/tools/utils/vm_util.cc:172] result[0]: Buffer<sint32[2]>\n 2xi32=4 9\n </denchmark-code>\n \n <denchmark-h:h4>Failing: iree_input.mlir for --functions=multiply,square modified to work with iree-run-mlir</denchmark-h>\n \n module attributes {tf.versions = {bad_consumers = [], min_consumer = 12 : i32, producer = 586 : i32}}  {\n   func @multiply__2_2__i32__uniform(%arg0: tensor<2xi32> {tf._user_specified_name = \"args_0\"}, %arg1: tensor<2xi32> {tf._user_specified_name = \"args_1\"}) -> tensor<2xi32> attributes {iree.module.export, iree.reflection = {abi = \"sip\", abiv = 1 : i32, sip = \"I12!S9!k0_0k1_1R3!_0\"}, tf._input_shapes = [#tf.shape<2>, #tf.shape<2>]} {\n     %0 = mhlo.multiply %arg0, %arg1 : tensor<2xi32>\n     return %0 : tensor<2xi32>\n   }\n   func @square__2__i32__uniform(%arg0: tensor<2xi32> {tf._user_specified_name = \"args_0\"}, %unused0: tensor<2xi32>) -> tensor<2xi32> attributes {iree.module.export, iree.reflection = {abi = \"sip\", abiv = 1 : i32, sip = \"I8!S5!k0_0R3!_0\"}, tf._input_shapes = [#tf.shape<2>]} {\n     %0 = mhlo.multiply %arg0, %arg0 : tensor<2xi32>\n     return %0 : tensor<2xi32>\n   }\n }\n bazel run iree/tools:iree-run-mlir -- \\\n   -export-all \\\n   -iree-hal-target-backends=vmla \\\n   -function-input='2xi32=2 3' \\\n   -function-input='2xi32=5 7' \\\n   multiply_square_iree_input.mlir\n <denchmark-code>I iree/tools/iree-run-mlir-main.cc:205] Compiling for target backend 'vmla*'...\n I iree/tools/iree-run-mlir-main.cc:325] Evaluating all functions in module for driver 'vmla'...\n I iree/tools/utils/vm_util.cc:227] Creating driver and device for 'vmla'...\n EXEC @multiply__2_2__i32__uniform\n I iree/tools/utils/vm_util.cc:172] result[0]: Buffer<sint32[2]>\n 2xi32=10 21\n EXEC @square__2__i32__uniform\n PLEASE submit a bug report to https://bugs.llvm.org/ and include the crash backtrace.\n Stack dump without symbol names (ensure you have llvm-symbolizer in your PATH or set the environment var `LLVM_SYMBOLIZER_PATH` to point to it):\n .../iree/tools/iree-run-mlir[0x2fbf722]\n .../iree/tools/iree-run-mlir[0x2fbd765]\n .../iree/tools/iree-run-mlir[0x2fbfa9a]\n /lib/x86_64-linux-gnu/libpthread.so.0(+0x14140)[0x7f8862a36140]\n .../iree/tools/iree-run-mlir[0x2d938d9]\n .../iree/tools/iree-run-mlir[0x2da8c39]\n .../iree/tools/iree-run-mlir[0x2d94ec6]\n .../iree/tools/iree-run-mlir[0x2da8460]\n .../iree/tools/iree-run-mlir[0x2dd8f6d]\n .../iree/tools/iree-run-mlir[0x2e7fd3d]\n .../iree/tools/iree-run-mlir[0x2e7f633]\n .../iree/tools/iree-run-mlir[0x2e7e1cd]\n .../iree/tools/iree-run-mlir[0x2e7bfca]\n .../iree/tools/iree-run-mlir[0x2e82c7b]\n .../iree/tools/iree-run-mlir[0x2e8297f]\n .../iree/tools/iree-run-mlir[0x2d92652]\n .../iree/tools/iree-run-mlir[0x2debb6e]\n .../iree/tools/iree-run-mlir[0x2deb8fe]\n .../iree/tools/iree-run-mlir[0x2df1dfd]\n .../iree/tools/iree-run-mlir[0x2df190e]\n .../iree/tools/iree-run-mlir[0x2de9b21]\n .../iree/tools/iree-run-mlir[0x2deab27]\n .../iree/tools/iree-run-mlir[0x2deec9d]\n .../iree/tools/iree-run-mlir[0x2dee33d]\n .../iree/tools/iree-run-mlir[0x2dea6be]\n /lib/x86_64-linux-gnu/libstdc++.so.6(+0xcec60)[0x7f8862c5cc60]\n /lib/x86_64-linux-gnu/libpthread.so.0(+0x8ea7)[0x7f8862a2aea7]\n /lib/x86_64-linux-gnu/libc.so.6(clone+0x3f)[0x7f8862940eaf]\n [1]    169344 segmentation fault  bazel run iree/tools:iree-run-mlir -- -export-all  -function-input='2xi32=2 3\n </denchmark-code>\n \n <denchmark-h:h4>Passing: iree_input.mlir for --functions=multiply,square modified to work with iree-run-mlir and with square modified to use mhlo.add instead.</denchmark-h>\n \n module attributes {tf.versions = {bad_consumers = [], min_consumer = 12 : i32, producer = 586 : i32}}  {\n   func @multiply__2_2__i32__uniform(%arg0: tensor<2xi32> {tf._user_specified_name = \"args_0\"}, %arg1: tensor<2xi32> {tf._user_specified_name = \"args_1\"}) -> tensor<2xi32> attributes {iree.module.export, iree.reflection = {abi = \"sip\", abiv = 1 : i32, sip = \"I12!S9!k0_0k1_1R3!_0\"}, tf._input_shapes = [#tf.shape<2>, #tf.shape<2>]} {\n     %0 = mhlo.multiply %arg0, %arg1 : tensor<2xi32>\n     return %0 : tensor<2xi32>\n   }\n   func @square__2__i32__uniform(%arg0: tensor<2xi32> {tf._user_specified_name = \"args_0\"}, %unused0: tensor<2xi32>) -> tensor<2xi32> attributes {iree.module.export, iree.reflection = {abi = \"sip\", abiv = 1 : i32, sip = \"I8!S5!k0_0R3!_0\"}, tf._input_shapes = [#tf.shape<2>]} {\n     %0 = mhlo.add %arg0, %arg0 : tensor<2xi32>\n     return %0 : tensor<2xi32>\n   }\n }\n bazel run iree/tools:iree-run-mlir -- \\\n   -export-all \\\n   -iree-hal-target-backends=vmla \\\n   -function-input='2xi32=2 3' \\\n   -function-input='2xi32=5 7' \\\n   multiply_square_as_add_iree_input.mlir\n <denchmark-code>I iree/tools/iree-run-mlir-main.cc:205] Compiling for target backend 'vmla*'...\n I iree/tools/iree-run-mlir-main.cc:325] Evaluating all functions in module for driver 'vmla'...\n I iree/tools/utils/vm_util.cc:227] Creating driver and device for 'vmla'...\n EXEC @multiply__2_2__i32__uniform\n I iree/tools/utils/vm_util.cc:172] result[0]: Buffer<sint32[2]>\n 2xi32=10 21\n EXEC @square__2__i32__uniform\n I iree/tools/utils/vm_util.cc:172] result[0]: Buffer<sint32[2]>\n 2xi32=4 6\n </denchmark-code>\n \n (Mostly confirms that I added %unused0 correctly).\n \t\t"}, "comments_2": {"comment_id": 3, "comment_author": "phoenix-meadowlark", "commentT": "2020-11-22T21:29:07Z", "comment_text": "\n \t\tFantastic <denchmark-link:https://github.com/phoenix-meadowlark>@phoenix-meadowlark</denchmark-link>\n  I'll start debugging :)\n \t\t"}, "comments_3": {"comment_id": 4, "comment_author": "phoenix-meadowlark", "commentT": "2020-11-22T21:37:36Z", "comment_text": "\n \t\t(woo reproduced and in a debugger at the stack thanks to your iree-run-mlir command lines :)\n \t\t"}, "comments_4": {"comment_id": 5, "comment_author": "phoenix-meadowlark", "commentT": "2020-11-22T22:26:13Z", "comment_text": "\n \t\tok, confirmed this is an issue in the runner and not in compiler/runtime (whew).\n The issue is that you are calling two functions with the same set of 2 arguments but one function takes two inputs (multiply) and one takes one input (square). You can't do that :)\n scratch that, \u2615 kicking in and those silly tf._user_specified_name attributes are making it really hard to read. I see your unused argument.\n \t\t"}, "comments_5": {"comment_id": 6, "comment_author": "phoenix-meadowlark", "commentT": "2020-11-22T22:28:39Z", "comment_text": "\n \t\t(incidentally, this is another good reason to not have the python test runner call into IREE directly but instead shell out to a tool like iree-run-module, which does perform this validation in a consistent way)\n \t\t"}, "comments_6": {"comment_id": 7, "comment_author": "phoenix-meadowlark", "commentT": "2020-11-22T22:36:32Z", "comment_text": "\n \t\tLikely unrelated to the actual issue by sheer luck, but worth noting:\n module attributes {tf.versions = {bad_consumers = [], min_consumer = 12 : i32, producer = 586 : i32}}  {\n   func @multiply__2_2__i32__uniform(\n     %arg0: tensor<2xi32> {tf._user_specified_name = \"args_0\"},\n     %arg1: tensor<2xi32> {tf._user_specified_name = \"args_1\"}) -> tensor<2xi32>\n     attributes {\n       iree.module.export,\n       iree.reflection = {\n         abi = \"sip\",\n         abiv = 1 : i32,\n         sip = \"I12!S9!k0_0k1_1R3!_0\"\n       },\n       tf._input_shapes = [#tf.shape<2>, #tf.shape<2>]\n     } {\n     %0 = mhlo.multiply %arg0, %arg1 : tensor<2xi32>\n     return %0 : tensor<2xi32>\n   }\n   func @square__2__i32__uniform(\n     %arg0: tensor<2xi32> {tf._user_specified_name = \"args_0\"},\n     %unused0: tensor<2xi32>) -> tensor<2xi32>\n     attributes {\n       iree.module.export,\n       iree.reflection = {\n         abi = \"sip\",\n         abiv = 1 : i32,\n         sip = \"I8!S5!k0_0R3!_0\"\n       },\n       tf._input_shapes = [#tf.shape<2>]\n     } {\n     %0 = mhlo.multiply %arg0, %arg0 : tensor<2xi32>\n     return %0 : tensor<2xi32>\n   }\n }\n The multiply one has both arguments k0_0k1_1R3 in its sip signature while the square one has only one k0_0R3. iree-run-mlir does not use the sip stuff, but python does AFAIK. So we may just be lucking out and seeing the same error in both places as I expect behavior to be undefined on the python side if your sip signature does not match the actual function signature. Not the root cause here but something to watch out for in the future if trying to modify MLIR and then running it through the python runner.\n Will keep digging.\n \t\t"}, "comments_7": {"comment_id": 8, "comment_author": "phoenix-meadowlark", "commentT": "2020-11-22T22:43:53Z", "comment_text": "\n \t\tok scratch that \"scratch that\" - vm_util does use the sip stuff. that has its own whole set of issues we'll need to unwind at some point.\n \t\t"}, "comments_8": {"comment_id": 9, "comment_author": "phoenix-meadowlark", "commentT": "2020-11-22T22:58:01Z", "comment_text": "\n \t\truh roh <denchmark-link:https://github.com/ScottTodd>@ScottTodd</denchmark-link>\n  this is a bug in DeduplicateExecutablesPass :P\n // *** IR Dump After mlir::iree_compiler::IREE::Flow::OutlineDispatchRegionsPass ***\n flow.executable @multiply__2_2__i32__uniform_ex_dispatch_0 attributes {sym_visibility = \"private\"} {\n   flow.dispatch.entry @multiply__2_2__i32__uniform_ex_dispatch_0\n   module  {\n     func @multiply__2_2__i32__uniform_ex_dispatch_0(%arg0: tensor<2xi32>, %arg1: tensor<2xi32>) -> tensor<2xi32> {\n       %0 = mhlo.multiply %arg0, %arg1 : tensor<2xi32>\n       return %0 : tensor<2xi32>\n     }\n   }\n }\n func @multiply__2_2__i32__uniform(%arg0: tensor<2xi32>, %arg1: tensor<2xi32>) -> (tensor<2xi32>) {\n   %c2 = constant 2 : index\n   %0 = flow.dispatch @multiply__2_2__i32__uniform_ex_dispatch_0::@multiply__2_2__i32__uniform_ex_dispatch_0[%c2 : index](%arg0, %arg1) : (tensor<2xi32>, tensor<2xi32>) -> tensor<2xi32>\n   return %0 : tensor<2xi32>\n }\n flow.executable @square__2__i32__uniform_ex_dispatch_0 attributes {sym_visibility = \"private\"} {\n   flow.dispatch.entry @square__2__i32__uniform_ex_dispatch_0\n   module  {\n     func @square__2__i32__uniform_ex_dispatch_0(%arg0: tensor<2xi32>) -> tensor<2xi32> {\n       %0 = mhlo.multiply %arg0, %arg0 : tensor<2xi32>\n       return %0 : tensor<2xi32>\n     }\n   }\n }\n func @square__2__i32__uniform(%arg0: tensor<2xi32>, %arg1: tensor<2xi32>) -> (tensor<2xi32>) {\n   %c2 = constant 2 : index\n   %0 = flow.dispatch @square__2__i32__uniform_ex_dispatch_0::@square__2__i32__uniform_ex_dispatch_0[%c2 : index](%arg0) : (tensor<2xi32>) -> tensor<2xi32>\n   return %0 : tensor<2xi32>\n }\n // *** IR Dump After mlir::iree_compiler::IREE::Flow::DeduplicateExecutablesPass ***\n module attributes {\n   flow.executable @multiply__2_2__i32__uniform_ex_dispatch_0 attributes {sym_visibility = \"private\"} {\n     flow.dispatch.entry @multiply__2_2__i32__uniform_ex_dispatch_0\n     module  {\n       func @multiply__2_2__i32__uniform_ex_dispatch_0(%arg0: tensor<2xi32>, %arg1: tensor<2xi32>) -> tensor<2xi32> {\n         %0 = mhlo.multiply %arg0, %arg1 : tensor<2xi32>\n         return %0 : tensor<2xi32>\n       }\n     }\n   }\n   func @multiply__2_2__i32__uniform(%arg0: tensor<2xi32>, %arg1: tensor<2xi32>) -> (tensor<2xi32>) {\n     %c2 = constant 2 : index\n     %0 = flow.dispatch @multiply__2_2__i32__uniform_ex_dispatch_0::@multiply__2_2__i32__uniform_ex_dispatch_0[%c2 : index](%arg0, %arg1) : (tensor<2xi32>, tensor<2xi32>) -> tensor<2xi32>\n     return %0 : tensor<2xi32>\n   }\n   func @square__2__i32__uniform(%arg0: tensor<2xi32>) -> (tensor<2xi32>) {\n     %c2 = constant 2 : index\n     %0 = flow.dispatch @multiply__2_2__i32__uniform_ex_dispatch_0::@multiply__2_2__i32__uniform_ex_dispatch_0[%c2 : index](%arg0) : (tensor<2xi32>) -> tensor<2xi32>\n     return %0 : tensor<2xi32>\n   }\n }\n So these two different executables are getting deduped even though their contents differ: %0 = mhlo.multiply %arg0, %arg1 : tensor<2xi32> vs. %0 = mhlo.multiply %arg0, %arg0 : tensor<2xi32>. So the IR comparison is busted.\n This would cause a whole set of issues like this! Kind of shocking we weren't already seeing it (or maybe we are and just don't know it).\n Will fix and add this example as test case for the deduping pass. The reason changing the op from multiply to add fixes it is that it's likely bailing on the de-dupe earlier before it gets to the point where it's the same op with different operands.\n Confirmed by disabling the deduplication pass; things work fine.\n \t\t"}, "comments_9": {"comment_id": 10, "comment_author": "phoenix-meadowlark", "commentT": "2020-11-22T23:00:39Z", "comment_text": "\n \t\t(again, this is a really really good find <denchmark-link:https://github.com/phoenix-meadowlark>@phoenix-meadowlark</denchmark-link>\n  and thank you for narrowing down the issue!)\n \t\t"}, "comments_10": {"comment_id": 11, "comment_author": "phoenix-meadowlark", "commentT": "2020-11-23T23:12:21Z", "comment_text": "\n \t\tTackling this now; will try to get something that works to fix this and then upstream it as part of <denchmark-link:https://github.com/google/iree/issues/3996>#3996</denchmark-link>\n .\n \t\t"}}}, "commit": {"commit_id": "40c66b4e3cd8bd330673a3fc3c334a7e4319ebfc", "commit_author": "Ben Vanik", "commitT": "2020-12-23 13:14:28-08:00", "commit_complexity": {"commit_NLOC": "0.22727272727272727", "commit_CCN": "0.5454545454545454", "commit_Nprams": "0.0"}, "changed_files": {"file_0": {"file_change_type": "MODIFY", "file_Nmethod": 8, "file_old_name": "iree\\compiler\\Dialect\\Flow\\Transforms\\DeduplicateExecutables.cpp", "file_new_name": "iree\\compiler\\Dialect\\Flow\\Transforms\\DeduplicateExecutables.cpp", "file_complexity": {"file_NLOC": "224", "file_CCN": "52", "file_NToken": "1763"}, "hunks": {"hunk_0": {"Ismethod": 1, "added_lines": "231,232,233,234,235,236,237,238,239,240,241,242", "deleted_lines": null, "method_info": {"method_name": "mlir::iree_compiler::IREE::Flow::replaceEntryPointUses", "method_params": "moduleOp,replacements", "method_startline": "231", "method_endline": "242", "method_complexity": {"method_NLOC": "12", "method_CCN": "3", "method_NToken": "94", "method_nesting_level": "5"}}}, "hunk_1": {"Ismethod": 1, "added_lines": "207,208,209,210,211,212,215,216,217,218,219,220,221,222,223", "deleted_lines": null, "method_info": {"method_name": "mlir::iree_compiler::IREE::Flow::areExecutablesEquivalent", "method_params": "lhs,rhs", "method_startline": "200", "method_endline": "227", "method_complexity": {"method_NLOC": "21", "method_CCN": "5", "method_NToken": "176", "method_nesting_level": "5"}}}, "hunk_2": {"Ismethod": 1, "added_lines": "129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,196", "deleted_lines": "155,156,157", "method_info": {"method_name": "mlir::iree_compiler::IREE::Flow::isStructurallyEquivalentTo", "method_params": "lhs,rhs,parentMapping", "method_startline": "129", "method_endline": "198", "method_complexity": {"method_NLOC": "48", "method_CCN": "19", "method_NToken": "484", "method_nesting_level": "5"}}}, "hunk_3": {"Ismethod": 1, "added_lines": "33,34,35,36,37,39,40,41,42,43,44", "deleted_lines": "33,34,35,36,37,38,39,43,44,45", "method_info": {"method_name": "mlir::iree_compiler::IREE::Flow::compare_ranges", "method_params": "lhs,rhs,pred", "method_startline": "33", "method_endline": "45", "method_complexity": {"method_NLOC": "11", "method_CCN": "5", "method_NToken": "100", "method_nesting_level": "5"}}}, "hunk_4": {"Ismethod": 1, "added_lines": "43,44,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90", "deleted_lines": "43,44,45,48,51,52,53,54,55,56,57,58,60,63,64,68,69,70,71,72,73,75,76,77,78,79,80,81,82,83,84,85", "method_info": {"method_name": "mlir::iree_compiler::IREE::Flow::areRegionsEquivalent", "method_params": "lhs,rhs", "method_startline": "43", "method_endline": "90", "method_complexity": {"method_NLOC": "36", "method_CCN": "10", "method_NToken": "307", "method_nesting_level": "5"}}}, "hunk_5": {"Ismethod": 1, "added_lines": "266,267,268", "deleted_lines": null, "method_info": {"method_name": "mlir::iree_compiler::IREE::Flow::DeduplicateExecutablesPass::runOnOperation", "method_params": "", "method_startline": "252", "method_endline": "307", "method_complexity": {"method_NLOC": "38", "method_CCN": "6", "method_NToken": "307", "method_nesting_level": "5"}}}, "hunk_6": {"Ismethod": 1, "added_lines": "77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,100,101,102,103,104,105,106,107,108,109,110,111,112,113,117,120,123,124,126,127,128", "deleted_lines": "77,78,79,80,81,82,83,84,85,96,97,98,99,100,104,105,106,107,108,109,110,111,112,115,116,117,118,119,120,121,122,123,124,125,126,127", "method_info": {"method_name": "mlir::iree_compiler::IREE::Flow::isStructurallyEquivalentTo", "method_params": "lhs,rhs,mapping", "method_startline": "77", "method_endline": "128", "method_complexity": {"method_NLOC": "44", "method_CCN": "10", "method_NToken": "387", "method_nesting_level": "5"}}}, "hunk_7": {"Ismethod": 1, "added_lines": "72,73,74,75", "deleted_lines": "72,73,75", "method_info": {"method_name": "mlir::iree_compiler::IREE::Flow::isStructurallyEquivalentTo", "method_params": "lhs,rhs", "method_startline": "72", "method_endline": "75", "method_complexity": {"method_NLOC": "4", "method_CCN": "1", "method_NToken": "25", "method_nesting_level": "5"}}}}}, "file_1": {"file_change_type": "MODIFY", "file_Nmethod": 0, "file_old_name": "iree\\compiler\\Dialect\\Flow\\Transforms\\test\\deduplicate_executables.mlir", "file_new_name": "iree\\compiler\\Dialect\\Flow\\Transforms\\test\\deduplicate_executables.mlir", "file_complexity": {"file_NLOC": "None", "file_CCN": "None", "file_NToken": "None"}, "hunks": {"hunk_0": {"Ismethod": 0, "added_lines": "67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,303,304,305,306,307,308,309,310,311,312,313,314,315,316,317,318", "deleted_lines": "145"}}}}}}