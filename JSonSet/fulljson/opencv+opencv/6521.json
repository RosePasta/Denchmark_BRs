{"BR": {"BR_id": "6521", "BR_author": "tomoaki0705", "BRopenT": "2016-05-10T09:15:10Z", "BRcloseT": "2016-05-13T09:00:27Z", "BR_text": {"BRsummary": "hal_intrin.float32x4 fails on 64bit ARM", "BRdescription": "\n <denchmark-h:h3>Please state the information for your system</denchmark-h>\n \n \n OpenCV version: 3.1 / master\n Host OS: Linux (Ubuntu 16.04 64bit)\n Architecture: aarch64 ARM 64bit (ODROID-C2)\n \n <denchmark-h:h3>In which part of the OpenCV library you got the issue?</denchmark-h>\n \n \n core\n test of hal_intrin.float32x4\n \n <denchmark-h:h3>Expected behaviour</denchmark-h>\n \n \n 11.054862976074219\n \n <denchmark-h:h3>Actual behaviour</denchmark-h>\n \n \n 11.054863929748535\n \n <denchmark-h:h3>Additional description</denchmark-h>\n \n \n This doesn't happen on ARM 32 bit or other x86, x86_64 architecture\n This doesn't happen on raspberry Pi 3 + Rasbian 32bit\n \n <denchmark-h:h3>Code example to reproduce the issue / Steps to reproduce the issue</denchmark-h>\n \n The error message is as following\n <denchmark-code>/home/odroid/opencv-fork/modules/core/test/test_intrin.cpp:578: Failure\n Value of: resF[i]\n   Actual: 11.054863929748535\n Expected: std::sqrt(data1[i]*data1[i] + data2[i]*data2[i])\n Which is: 11.054862976074219\n </denchmark-code>\n \n The main part of the test is comparing the result of std::sqrt against the v_sqrt based on vrsqrteq_f32.\n It's very small difference, but fails on test.\n For this part, I propose to add one more iteration in v_sqrt\n <denchmark-code>@@ -427,6 +427,7 @@ inline v_float32x4 v_sqrt(const v_float32x4& x)\n      float32x4_t e = vrsqrteq_f32(x1);\n      e = vmulq_f32(vrsqrtsq_f32(vmulq_f32(x1, e), e), e);\n      e = vmulq_f32(vrsqrtsq_f32(vmulq_f32(x1, e), e), e);\n +    e = vmulq_f32(vrsqrtsq_f32(vmulq_f32(x1, e), e), e);\n      return v_float32x4(vmulq_f32(x.val, e));\n  }\n </denchmark-code>\n \n \t"}, "comments": {"comments_0": {"comment_id": 1, "comment_author": "tomoaki0705", "commentT": "2016-05-11T00:38:06Z", "comment_text": "\n \t\tARM doesn't tell you the precision. Intel  gets you within <denchmark-link:https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=rsqrt&expand=4463>1.5*2^-12</denchmark-link>\n  relative error. Each round of Newton-Raphson will approximately double the number of bits of precision, so one round of NR gets you just about to 24 bits, which is what 32-bit floating point values have. Having  rounds of NR is already erring on the side of more bits.\n Converting those floating point values to hex:\n \n 11.054863929748535 = 4130E0B9; squared is 42F46B87\n 11.054862976074219 = 4130E0B8; squared is 42F46B85\n The input value 122.21 = 42F46B85\n \n This is 1 <denchmark-link:https://en.wikipedia.org/wiki/Unit_in_the_last_place>ULP</denchmark-link>\n  and seems acceptable to me.\n \t\t"}, "comments_1": {"comment_id": 2, "comment_author": "tomoaki0705", "commentT": "2016-05-11T01:15:14Z", "comment_text": "\n \t\tI believe that problem is with tests: EXPECT_DOUBLE_EQ should not be used for results calculated with float precision. There is EXPECT_FLOAT_EQ for this or even EXPECT_NEAR.\n \t\t"}, "comments_2": {"comment_id": 3, "comment_author": "tomoaki0705", "commentT": "2016-05-11T03:11:02Z", "comment_text": "\n \t\t+1 for <denchmark-link:https://github.com/alalek>@alalek</denchmark-link>\n  suggestion.\n \t\t"}, "comments_3": {"comment_id": 4, "comment_author": "tomoaki0705", "commentT": "2016-05-11T16:18:19Z", "comment_text": "\n \t\tThe test is templated, but the macros are not. Maybe add an overloaded test function that compares either two floats or two doubles and they can use the correct macro.\n BTW, I think this case will still fail because the values differ at the eight digit.\n \t\t"}, "comments_4": {"comment_id": 5, "comment_author": "tomoaki0705", "commentT": "2016-05-13T00:01:13Z", "comment_text": "\n \t\tThanks for the comment kgnk.\n Indeed, I had to not only use the macro but to implement template functions.\n To answer your concern, the test passed on 64bit ARM.\n I looked in to the EXPECT_FLOAT_EQ, and in there the, it was calling AlmostEquals function and it's comparing the distance between kMaxUlps\n <denchmark-code>  bool AlmostEquals(const FloatingPoint& rhs) const {\n     // The IEEE standard says that any comparison operation involving\n     // a NAN must return false.\n     if (is_nan() || rhs.is_nan()) return false;\n \n     return DistanceBetweenSignAndMagnitudeNumbers(u_.bits_, rhs.u_.bits_)\n         <= kMaxUlps;\n   }\n </denchmark-code>\n \n The kMaxUlps is a constant, which is 4\n <denchmark-code>  static const size_t kMaxUlps = 4;\n </denchmark-code>\n \n so in this case, the difference between two values is 1 ULP, which is treated as equal based on comparison with 4 ULPS.\n \t\t"}}}, "commit": {"commit_id": "7077d1de63a325b24ac14dcb65b394869da503bb", "commit_author": "Tomoaki Teshima", "commitT": "2016-05-12 18:30:09+09:00", "commit_complexity": {"commit_NLOC": "1.0", "commit_CCN": "1.0", "commit_Nprams": "1.0"}, "changed_files": {"file_0": {"file_change_type": "MODIFY", "file_Nmethod": 7, "file_old_name": "modules\\core\\test\\test_intrin.cpp", "file_new_name": "modules\\core\\test\\test_intrin.cpp", "file_complexity": {"file_NLOC": "741", "file_CCN": "75", "file_NToken": "6707"}, "hunks": {"hunk_0": {"Ismethod": 1, "added_lines": null, "deleted_lines": "319,320,321", "method_info": {"method_name": "TheTest::test_sqrt_abs", "method_params": "", "method_startline": "310", "method_endline": "325", "method_complexity": {"method_NLOC": "14", "method_CCN": "2", "method_NToken": "149", "method_nesting_level": "1"}}}, "hunk_1": {"Ismethod": 1, "added_lines": "597,598,599", "deleted_lines": "578,579,580", "method_info": {"method_name": "cvtest::hal::TheTest::test_float_math", "method_params": "", "method_startline": "573", "method_endline": "603", "method_complexity": {"method_NLOC": "26", "method_CCN": "2", "method_NToken": "287", "method_nesting_level": "3"}}}, "hunk_2": {"Ismethod": 1, "added_lines": "24,25,26,27", "deleted_lines": null, "method_info": {"method_name": "cvtest::hal::TheTest::EXPECT_COMPARE_EQ", "method_params": "a,b", "method_startline": "24", "method_endline": "27", "method_complexity": {"method_NLOC": "4", "method_CCN": "1", "method_NToken": "28", "method_nesting_level": "3"}}}, "hunk_3": {"Ismethod": 1, "added_lines": null, "deleted_lines": "578,579,580", "method_info": {"method_name": "TheTest::test_float_math", "method_params": "", "method_startline": "554", "method_endline": "584", "method_complexity": {"method_NLOC": "26", "method_CCN": "2", "method_NToken": "287", "method_nesting_level": "1"}}}, "hunk_4": {"Ismethod": 1, "added_lines": "9,10,11,12", "deleted_lines": null, "method_info": {"method_name": "cvtest::hal::EXPECT_COMPARE_EQ_<float>", "method_params": "a,b", "method_startline": "9", "method_endline": "12", "method_complexity": {"method_NLOC": "4", "method_CCN": "1", "method_NToken": "22", "method_nesting_level": "2"}}}, "hunk_5": {"Ismethod": 1, "added_lines": "14,15,16,17", "deleted_lines": null, "method_info": {"method_name": "cvtest::hal::EXPECT_COMPARE_EQ_<double>", "method_params": "a,b", "method_startline": "14", "method_endline": "17", "method_complexity": {"method_NLOC": "4", "method_CCN": "1", "method_NToken": "22", "method_nesting_level": "2"}}}, "hunk_6": {"Ismethod": 1, "added_lines": "338,339,340", "deleted_lines": null, "method_info": {"method_name": "cvtest::hal::TheTest::test_sqrt_abs", "method_params": "", "method_startline": "329", "method_endline": "344", "method_complexity": {"method_NLOC": "14", "method_CCN": "2", "method_NToken": "149", "method_nesting_level": "3"}}}}}}}}