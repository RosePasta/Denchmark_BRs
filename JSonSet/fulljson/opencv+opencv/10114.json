{"BR": {"BR_id": "10114", "BR_author": "chacha21", "BRopenT": "2017-11-20T09:52:26Z", "BRcloseT": "2017-12-28T16:53:27Z", "BR_text": {"BRsummary": "EXR export/import does not retreive equivalent data", "BRdescription": "\n OpenCV => 3.3.1\n Operating System / Platform => Windows 64 Bit\n Compiler => Visual Studio 2017\n I tested OpenEXR integration in OpenCV.\n OpenCV is compiled with BUILD_OPENEXR and WITH_OPENEXR\n The test is to encode an image to EXR using the full range allowed by the src depth, and see what the decoded mat will be made of (depth and values range).\n Here are the results :\n \n \n CV_8U : the range [0;255] is kept, but the output depth is CV_32F, so that it is not clear that the input range was 8U\n \n \n CV_8S : same as CV_8U, and there are problems for values close to -128\n \n \n CV_16U : the range [0;65535] is kept, but the output depth is CV_32S, so that it is not clear that the input range was 16U\n \n \n CV_16S : same as CV_16U, and there are problems for values close to -32768\n \n \n CV_32S : there are problems for values close to -2147486348\n \n \n CV_32F : OK\n \n \n CV_64F : wrong values in some cases\n \n \n <denchmark-code>  int srcDepths[] = {CV_8U, CV_8S, CV_16U, CV_16S, CV_32S, CV_32F, CV_64F};\n   for(int i = 0 ; i<sizeof(srcDepths)/sizeof(int) ; ++i)\n   {\n     int srcDepth = srcDepths[i];\n     double minValue =\n       (srcDepth == CV_8S) ? 1.*std::numeric_limits<signed __int8>::min() :\n       (srcDepth == CV_8U) ? 1.*std::numeric_limits<unsigned __int8>::min() :\n       (srcDepth == CV_16S) ? 1.*std::numeric_limits<signed __int16>::min() :\n       (srcDepth == CV_16U) ? 1.*std::numeric_limits<unsigned __int16>::min() :\n       (srcDepth == CV_32S) ? 1.*std::numeric_limits<signed __int32>::min() :\n       0.;\n     double maxValue =\n       (srcDepth == CV_8S) ? 1.*std::numeric_limits<signed __int8>::max() :\n       (srcDepth == CV_8U) ? 1.*std::numeric_limits<unsigned __int8>::max() :\n       (srcDepth == CV_16S) ? 1.*std::numeric_limits<signed __int16>::max() :\n       (srcDepth == CV_16U) ? 1.*std::numeric_limits<unsigned __int16>::max() :\n       (srcDepth == CV_32S) ? 1.*std::numeric_limits<signed __int32>::max() :\n       1.;\n \n     for(int test = 1 ; test <= 4 ; ++test)\n     {\n       cv::Mat srcMat(cv::Size(640, 480), CV_MAKETYPE(srcDepth, 1));\n       cv::Mat srcMatROI1(srcMat, cv::Rect(0, 0*srcMat.size().height/2, srcMat.size().width, srcMat.size().height/2));\n       cv::Mat srcMatROI2(srcMat, cv::Rect(0, 1*srcMat.size().height/2, srcMat.size().width, srcMat.size().height/2));\n       srcMatROI1.setTo(cv::Scalar((test == 1) ? minValue : (test == 2) ? (minValue+1) : (test == 3) ? (minValue+2) : (test == 4) ? (minValue/2) : minValue));\n       srcMatROI2.setTo(cv::Scalar((test == 1) ? maxValue : (test == 2) ? (maxValue-1) : (test == 3) ? (maxValue-2) : (test == 4) ? (maxValue/2) : maxValue));\n \n       double inf = 0;\n       double sup = 0;\n       cv::minMaxLoc(srcMat, &inf, &sup);\n       printf(\"srcDepth:%d\\tinf:%f\\tsup:%f\\t(sup-inf):%f\\n\", srcDepth, inf, sup, sup-inf);\n \n       std::vector<unsigned char> data;\n       cv::imencode(\".exr\", srcMat, data);\n \n       cv::Mat dstMat = cv::imdecode(data, cv::IMREAD_UNCHANGED);\n       cv::minMaxLoc(dstMat, &inf, &sup);\n       printf(\"dstDepth:%d\\tinf:%f\\tsup:%f\\t(sup-inf):%f\\n\", dstMat.depth(), inf, sup, sup-inf);\n     }//end for(int test = 1 ; test <= 3 ; ++test)\n     printf(\"----------------------------------\\n\");\n   }\n </denchmark-code>\n \n Output is :\n <denchmark-code>srcDepth:0      inf:0.000000    sup:255.000000  (sup-inf):255.000000\n dstDepth:5      inf:0.000000    sup:255.000000  (sup-inf):255.000000\n srcDepth:0      inf:1.000000    sup:254.000000  (sup-inf):253.000000\n dstDepth:5      inf:1.000000    sup:254.000000  (sup-inf):253.000000\n srcDepth:0      inf:2.000000    sup:253.000000  (sup-inf):251.000000\n dstDepth:5      inf:2.000000    sup:253.000000  (sup-inf):251.000000\n srcDepth:0      inf:0.000000    sup:128.000000  (sup-inf):128.000000\n dstDepth:5      inf:0.000000    sup:128.000000  (sup-inf):128.000000\n ----------------------------------\n srcDepth:1      inf:-128.000000 sup:127.000000  (sup-inf):255.000000\n dstDepth:5      inf:127.000000  sup:128.000000  (sup-inf):1.000000\n srcDepth:1      inf:-127.000000 sup:126.000000  (sup-inf):253.000000\n dstDepth:5      inf:126.000000  sup:129.000000  (sup-inf):3.000000\n srcDepth:1      inf:-126.000000 sup:125.000000  (sup-inf):251.000000\n dstDepth:5      inf:125.000000  sup:130.000000  (sup-inf):5.000000\n srcDepth:1      inf:-64.000000  sup:64.000000   (sup-inf):128.000000\n dstDepth:5      inf:64.000000   sup:192.000000  (sup-inf):128.000000\n ----------------------------------\n srcDepth:2      inf:0.000000    sup:65535.000000        (sup-inf):65535.000000\n dstDepth:4      inf:0.000000    sup:65535.000000        (sup-inf):65535.000000\n srcDepth:2      inf:1.000000    sup:65534.000000        (sup-inf):65533.000000\n dstDepth:4      inf:1.000000    sup:65534.000000        (sup-inf):65533.000000\n srcDepth:2      inf:2.000000    sup:65533.000000        (sup-inf):65531.000000\n dstDepth:4      inf:2.000000    sup:65533.000000        (sup-inf):65531.000000\n srcDepth:2      inf:0.000000    sup:32768.000000        (sup-inf):32768.000000\n dstDepth:4      inf:0.000000    sup:32768.000000        (sup-inf):32768.000000\n ----------------------------------\n srcDepth:3      inf:-32768.000000       sup:32767.000000        (sup-inf):65535.\n 000000\n dstDepth:4      inf:65535.000000        sup:65536.000000        (sup-inf):1.0000\n 00\n srcDepth:3      inf:-32767.000000       sup:32766.000000        (sup-inf):65533.\n 000000\n dstDepth:4      inf:65534.000000        sup:65537.000000        (sup-inf):3.0000\n 00\n srcDepth:3      inf:-32766.000000       sup:32765.000000        (sup-inf):65531.\n 000000\n dstDepth:4      inf:65533.000000        sup:65538.000000        (sup-inf):5.0000\n 00\n srcDepth:3      inf:-16384.000000       sup:16384.000000        (sup-inf):32768.\n 000000\n dstDepth:4      inf:49152.000000        sup:81920.000000        (sup-inf):32768.\n 000000\n ----------------------------------\n srcDepth:4      inf:-2147483648.000000  sup:2147483647.000000   (sup-inf):429496\n 7295.000000\n dstDepth:4      inf:-1.000000   sup:0.000000    (sup-inf):1.000000\n srcDepth:4      inf:-2147483647.000000  sup:2147483646.000000   (sup-inf):429496\n 7293.000000\n dstDepth:4      inf:-2.000000   sup:1.000000    (sup-inf):3.000000\n srcDepth:4      inf:-2147483646.000000  sup:2147483645.000000   (sup-inf):429496\n 7291.000000\n dstDepth:4      inf:-3.000000   sup:2.000000    (sup-inf):5.000000\n srcDepth:4      inf:-1073741824.000000  sup:1073741824.000000   (sup-inf):214748\n 3648.000000\n dstDepth:4      inf:-1073741824.000000  sup:1073741824.000000   (sup-inf):214748\n 3648.000000\n ----------------------------------\n srcDepth:5      inf:0.000000    sup:1.000000    (sup-inf):1.000000\n dstDepth:5      inf:0.000000    sup:1.000000    (sup-inf):1.000000\n srcDepth:5      inf:0.000000    sup:1.000000    (sup-inf):1.000000\n dstDepth:5      inf:0.000000    sup:1.000000    (sup-inf):1.000000\n srcDepth:5      inf:-1.000000   sup:2.000000    (sup-inf):3.000000\n dstDepth:5      inf:-1.000000   sup:2.000000    (sup-inf):3.000000\n srcDepth:5      inf:0.000000    sup:0.500000    (sup-inf):0.500000\n dstDepth:5      inf:0.000000    sup:0.500000    (sup-inf):0.500000\n ----------------------------------\n srcDepth:6      inf:0.000000    sup:1.000000    (sup-inf):1.000000\n dstDepth:5      inf:0.000000    sup:1.000000    (sup-inf):1.000000\n srcDepth:6      inf:0.000000    sup:1.000000    (sup-inf):1.000000\n dstDepth:5      inf:0.000000    sup:1.000000    (sup-inf):1.000000\n srcDepth:6      inf:-1.000000   sup:2.000000    (sup-inf):3.000000\n dstDepth:5      inf:0.000000    sup:2.000000    (sup-inf):2.000000\n srcDepth:6      inf:0.000000    sup:0.500000    (sup-inf):0.500000\n dstDepth:5      inf:0.000000    sup:0.000000    (sup-inf):0.000000\n ----------------------------------\n </denchmark-code>\n \n \t"}, "comments": {"comments_0": {"comment_id": 1, "comment_author": "chacha21", "commentT": "2017-12-11T21:27:31Z", "comment_text": "\n \t\t\n so that it is not clear that the input range was 8U/16U\n \n Please add a link on OpenEXR built-in types. I believe, 1:1 map is not possible here.\n , it is <denchmark-link:https://github.com/openexr/openexr/blob/develop/OpenEXR/IlmImf/ImfPixelType.h>here</denchmark-link>\n :\n <denchmark-code>    UINT   = 0,\t\t// unsigned int (32 bit)\n     HALF   = 1,\t\t// half (16 bit floating point)\n     FLOAT  = 2,\t\t// float (32 bit floating point)\n </denchmark-code>\n \n \t\t"}, "comments_1": {"comment_id": 2, "comment_author": "chacha21", "commentT": "2017-12-11T21:36:54Z", "comment_text": "\n \t\tSo only float type can be mapped (CV_32F <-> FLOAT) without issues. Other types have no direct mappings.\n My suggestion is to drop other types from code, add appropriate CV_Assert() messages and mention this in documentation to avoid users confusing about buggy implicit conversions.\n \t\t"}, "comments_2": {"comment_id": 3, "comment_author": "chacha21", "commentT": "2017-12-11T22:13:13Z", "comment_text": "\n \t\tHALF is most useful type in exr. If don't support it. It makes the exported file double its size in most case.\n If user want to export exr, it should know half floating point advantage.\n My concern: 10bits images should be fitted in half, but my implementation fail the case\n \t\t"}, "comments_3": {"comment_id": 4, "comment_author": "chacha21", "commentT": "2017-12-11T22:27:35Z", "comment_text": "\n \t\tBTW, OpenCV has conversion function (convertFp16) from/to FP16 <=> FP32 (but there is no separate type for FP16, CV_16S is reused as storage). Perhaps we need some flag to force EXR HALF storage for CV_32F (or we can assume CV_16S as EXR HALF directly - need to check that EXR supports 16-bit HALF input).\n But implicit conversions are evil, especially in cases without 1:1 mappings.\n \t\t"}, "comments_4": {"comment_id": 5, "comment_author": "chacha21", "commentT": "2017-12-12T00:21:14Z", "comment_text": "\n \t\tAgree implicit conversions are evil.\n Follow your suggestion, change would be:\n \n Only support CV_16S and CV_32F as input.\n Add a param to specify EXR storage type, only support FLOAT and HALF, default is FLOAT.\n If input is CV_16S, storage type must be specified as HALF, if not, throw assertion. It means user know data in CV_16S is half format.\n If input is CV_32F and storage type is FLOAT, store it directly.\n If input is CV_32F and storage type is HALF, convert it and store.\n Currently EXR import code will convert HALF to CV_32F. Because EXR can hybrid store different depth data, it's better not change current EXR loading design. When OPENCV create CV_16F, or somebody really need loading HALF directly to CV_16S, we can add the direct loading late.\n Does it make sense to you?\n \n \t\t"}, "comments_5": {"comment_id": 6, "comment_author": "chacha21", "commentT": "2017-12-12T11:57:22Z", "comment_text": "\n \t\tThere are results of OpenCV's devs discussion:\n \n lets support from OpenCV side CV_32F only. CV_16S is a hack and we prefer to reduce using of it. OpenCV 4.0 will have direct support for FP16 type.\n imread() from EXR returns CV_32F only (HALF is OK, FLOAT - OK, UINT - precision lost, but lets read as 32F for now)\n imwrite() accepts CV_32F cv::Mat only and stores FLOAT images by default. Add imwrite() flag to store in HALF format. Something like this:\n \n  enum ImwriteFlags {\n     ...\n +    IMWRITE_EXR_TYPE = (3 << 4) + 0,  /* 48 */ //!< override EXR storage type (FLOAT (FP32) is default)\n  }\n \n +enum ImwriteEXRTypeFlags {\n +    /*IMWRITE_EXR_TYPE_UINT = 0, //!< not supported */\n +    IMWRITE_EXR_TYPE_HALF = 1,   //!< store as HALF (FP16)\n +    IMWRITE_EXR_TYPE_FLOAT = 2   //!< store as FP32 (default)\n +};\n \n storing of non-CV_32F cv::Mat is prohibited.\n \n \t\t"}, "comments_6": {"comment_id": 7, "comment_author": "chacha21", "commentT": "2017-12-12T12:17:06Z", "comment_text": "\n \t\tAs the user reporting the bug, I totally agree with the decisions.\n \t\t"}, "comments_7": {"comment_id": 8, "comment_author": "chacha21", "commentT": "2019-12-02T10:14:35Z", "comment_text": "\n \t\tIs it possible to Read / Load *.EXR files as Half Format (like CV_16F) ?\n i think for all *.Exr images not loading with correct bit depth\n can Possible to give a solution with next release ? :)\n There is no Change for EXR Reading on log time i think\n \t\t"}}}, "commit": {"commit_id": "6df8ac03422784a94f5ccf78e4c68788ef055e7b", "commit_author": "zhijackchen", "commitT": "2017-12-15 12:23:44+03:00", "commit_complexity": {"commit_NLOC": "1.0", "commit_CCN": "1.0", "commit_Nprams": "0.16666666666666666"}, "changed_files": {"file_0": {"file_change_type": "MODIFY", "file_Nmethod": 0, "file_old_name": "modules\\imgcodecs\\include\\opencv2\\imgcodecs.hpp", "file_new_name": "modules\\imgcodecs\\include\\opencv2\\imgcodecs.hpp", "file_complexity": {"file_NLOC": "62", "file_CCN": "0", "file_NToken": "332"}, "hunks": {"hunk_0": {"Ismethod": 0, "added_lines": "92,97,98,99,100,101,102", "deleted_lines": null}}}, "file_1": {"file_change_type": "MODIFY", "file_Nmethod": 0, "file_old_name": "modules\\imgcodecs\\include\\opencv2\\imgcodecs\\imgcodecs_c.h", "file_new_name": "modules\\imgcodecs\\include\\opencv2\\imgcodecs\\imgcodecs_c.h", "file_complexity": {"file_NLOC": "55", "file_CCN": "0", "file_NToken": "325"}, "hunks": {"hunk_0": {"Ismethod": 0, "added_lines": "97", "deleted_lines": null}}}, "file_2": {"file_change_type": "MODIFY", "file_Nmethod": 6, "file_old_name": "modules\\imgcodecs\\src\\grfmt_exr.cpp", "file_new_name": "modules\\imgcodecs\\src\\grfmt_exr.cpp", "file_complexity": {"file_NLOC": "506", "file_CCN": "115", "file_NToken": "3861"}, "hunks": {"hunk_0": {"Ismethod": 1, "added_lines": "588,589,590,591,592,593,594,595,599,600,601,606,617,618,620,621,622,623,627,628,629,644,646,648,650", "deleted_lines": "588,591,593,594,595,596,597,599,601,602,603,604,605,606,610,611,612,617,628,630,631,632,633,634,635,636,637,638,642,643,644,647,648,660,661,663,665,666,667,668,669,670,671,672,674,676,677,678,679,680,681,682,683,684,685,686,687,688,689,690,691,692,693,694,695,696,697,698,699,700,701,702,703,704,705,706,707,708,709,710,711,712,713,714,715,716,717,718,719,720,721,722,723,724,725,726,727,728,729,730", "method_info": {"method_name": "cv::ExrEncoder::write", "method_params": "img", "method_startline": "588", "method_endline": "734", "method_complexity": {"method_NLOC": "128", "method_CCN": "28", "method_NToken": "815", "method_nesting_level": "1"}}}, "hunk_1": {"Ismethod": 1, "added_lines": "167,168", "deleted_lines": "163,164,165,166,167,168,169,170,171,172,173,174,175", "method_info": {"method_name": "cv::ExrDecoder::readHeader", "method_params": "", "method_startline": "120", "method_endline": "175", "method_complexity": {"method_NLOC": "45", "method_CCN": "10", "method_NToken": "253", "method_nesting_level": "1"}}}, "hunk_2": {"Ismethod": 1, "added_lines": "467,483", "deleted_lines": "474,475,476,477,478,479,480,496,497,498,499,500", "method_info": {"method_name": "cv::ExrDecoder::ChromaToBGR", "method_params": "data,numlines,step", "method_startline": "460", "method_endline": "500", "method_complexity": {"method_NLOC": "40", "method_CCN": "5", "method_NToken": "393", "method_nesting_level": "1"}}}, "hunk_3": {"Ismethod": 1, "added_lines": "568,571,572,573,574,577,579,580,581,582,583,584,585,586,587,588,589,590,591,592,593,594,595,599,600,601,606,617,618,620,621,622,623,627,628,629,644,646,648,650", "deleted_lines": "583,587,588,591,593,594,595,596,597,599,601,602,603,604,605,606,610,611,612,617,628,630,631,632,633,634,635,636,637,638,642,643,644,647,648", "method_info": {"method_name": "cv::ExrEncoder::write", "method_params": "img,params", "method_startline": "568", "method_endline": "654", "method_complexity": {"method_NLOC": "76", "method_CCN": "10", "method_NToken": "467", "method_nesting_level": "1"}}}, "hunk_4": {"Ismethod": 1, "added_lines": "182,185,186,187,199,215,217,218,219,220,223,224,225,226,227,228,231,232,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,272,273,274,275,276,277,285,286,287,288,289,290,298,300,301,302,306,307,308,309,326,327,328,338,339,340,341,342,355,357,363", "deleted_lines": "178,179,180,181,182,196,199,200,201,213,229,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,257,258,259,260,261,262,263,264,265,267,301,303,304,335,336,337,338,339,340,341,346,347,348,349,350,351,352,359,361,367", "method_info": {"method_name": "cv::ExrDecoder::readData", "method_params": "img", "method_startline": "178", "method_endline": "388", "method_complexity": {"method_NLOC": "198", "method_CCN": "52", "method_NToken": "1550", "method_nesting_level": "1"}}}, "hunk_5": {"Ismethod": 1, "added_lines": "564", "deleted_lines": null, "method_info": {"method_name": "cv::ExrEncoder::isFormatSupported", "method_params": "depth", "method_startline": "562", "method_endline": "565", "method_complexity": {"method_NLOC": "4", "method_CCN": "1", "method_NToken": "20", "method_nesting_level": "1"}}}}}}}}