{"BR": {"BR_id": "531", "BR_author": "swarwick", "BRopenT": "2020-04-03T20:17:50Z", "BRcloseT": "2020-04-06T19:00:06Z", "BR_text": {"BRsummary": "toString broken for byte[] data types", "BRdescription": "\n Describe the bug\n If you create a StructType that contains a StructField of type smile.data.type.DataTypes.ByteArrayType and create a tuple with that struct it will crash during the toString() call because the ArrayType tries to cast it to an Object[]\n Expected behavior\n I would expect the toString to not crash and produce some meaningful result\n Actual behavior\n java.lang.ClassCastException: class [B cannot be cast to class [Ljava.lang.Object; ([B and [Ljava.lang.Object; are in module java.base of loader 'bootstrap')\n at smile.data.type.ArrayType.toString(ArrayType.java:80)\n at smile.data.type.StructField.toString(StructField.java:73)\n at smile.data.type.StructType.lambda$toString$6(StructType.java:154)\n at java.base/java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:195)\n at java.base/java.util.Spliterators$ArraySpliterator.forEachRemaining(Spliterators.java:948)\n at java.base/java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:484)\n at java.base/java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:474)\n at java.base/java.util.stream.ReduceOps$ReduceOp.evaluateSequential(ReduceOps.java:913)\n at java.base/java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234)\n at java.base/java.util.stream.ReferencePipeline.collect(ReferencePipeline.java:578)\n at smile.data.type.StructType.toString(StructType.java:157)\n at smile.data.AbstractTuple.toString(AbstractTuple.java:28)\n at com.streambase.sb.adapter.datascience.smile.TestSmileDataTypeRegistry.testSmileBinaryToString(TestSmileDataTypeRegistry.java:77)\n at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n at java.base/java.lang.reflect.Method.invoke(Method.java:566)\n at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:59)\n at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)\n at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:56)\n at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)\n at org.junit.runners.ParentRunner$3.evaluate(ParentRunner.java:306)\n at org.junit.runners.BlockJUnit4ClassRunner$1.evaluate(BlockJUnit4ClassRunner.java:100)\n at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:366)\n at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:103)\n at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:63)\n at org.junit.runners.ParentRunner$4.run(ParentRunner.java:331)\n at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:79)\n at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:329)\n at org.junit.runners.ParentRunner.access$100(ParentRunner.java:66)\n at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:293)\n at org.junit.runners.ParentRunner$3.evaluate(ParentRunner.java:306)\n at org.junit.runners.ParentRunner.run(ParentRunner.java:413)\n at org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:89)\n at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:41)\n at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:542)\n at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:770)\n at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:464)\n at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:210)\n \n <denchmark-link:https://github.com/test>@test</denchmark-link>\n \n public void testSmileBinaryToString() throws Exception {\n StructType structType = new StructType(Arrays.asList(new StructField [] { new StructField(\"binary\", smile.data.type.DataTypes.ByteArrayType) }));\n Object [] tupleData = new Object[structType.fields().length];\n tupleData[0] = new byte[] { 1,2,3,4,5,6,7,8,9 };\n smile.data.Tuple smileTuple = smile.data.Tuple.of(tupleData, structType);\n logger.info(\"Smile Tuple:\\r\\n{}\", smileTuple.toString());\n }\n Input data\n The sample data\n Additional context\n Oracle Java 11\n Smile 2.3.0\n Windows/macos/linux\n \t"}, "comments": {"comments_0": {"comment_id": 1, "comment_author": "swarwick", "commentT": "2020-04-03T20:36:45Z", "comment_text": "\n \t\tThanks. I fix it. Please try the master branch. It passes your code snippet.\n \t\t"}, "comments_1": {"comment_id": 2, "comment_author": "swarwick", "commentT": "2020-04-03T21:22:33Z", "comment_text": "\n \t\tTried it out and works for this case, thanks.\n \t\t"}, "comments_2": {"comment_id": 3, "comment_author": "swarwick", "commentT": "2020-04-06T13:47:30Z", "comment_text": "\n \t\tThere it still an issue if you have StructType fields inside an ArrayType field, I would also assume from the code it would fail with ArrayType inside ArrayType\n \t\t"}, "comments_3": {"comment_id": 4, "comment_author": "swarwick", "commentT": "2020-04-06T13:53:35Z", "comment_text": "\n \t\tCan you share the code snippet? Thanks\n BTW, what's your use case? Although we support nested data structure in DataFrame, it is quite rare in machine learning use cases.\n \t\t"}, "comments_4": {"comment_id": 5, "comment_author": "swarwick", "commentT": "2020-04-06T15:16:54Z", "comment_text": "\n \t\tI am building some generic data conversion code from an internal format for other developers so they can use whatever format they want from our internal structure into this library. I am trying to flush out any and all uses cases and so some of these are coming up.\n `    <denchmark-link:https://github.com/test>@test</denchmark-link>\n \n public void testStructInArray() throws Exception {\n StructType internalStructType = new StructType(Arrays.asList(new StructField [] {\n new StructField(\"field1\", smile.data.type.DataTypes.IntegerType),\n new StructField(\"field2\", smile.data.type.DataTypes.StringType) }));\n <denchmark-code>\tStructType structType = new StructType(new StructField(\"data\", smile.data.type.DataTypes.array(internalStructType)));\n \t\n     logger.info(\"Struct:\\r\\n{}\",structType.toString());\n     \n     Object [] internalTupleData = new Object[internalStructType.fields().length];\n     internalTupleData[0] = 1;\n     internalTupleData[1] = \"testing\";\n     smile.data.Tuple internalSmileTuple = smile.data.Tuple.of(internalTupleData, internalStructType);\n     logger.info(\"Tuple1:\\r\\n{}\",internalSmileTuple.toString());\n     \n     Object [] internalTupleData2 = new Object[internalStructType.fields().length];\n     internalTupleData2[0] = 2;\n     internalTupleData2[1] = \"testing 2\";\n     smile.data.Tuple internalSmileTuple2 = smile.data.Tuple.of(internalTupleData2, internalStructType);\n     logger.info(\"Tuple2:\\r\\n{}\",internalSmileTuple2.toString());\n     \n \tList<smile.data.Tuple> dataTuples = new ArrayList<>();\n \tdataTuples.add(internalSmileTuple);\n \tdataTuples.add(internalSmileTuple2);\n     Object [] tupleData = new Object[structType.fields().length];\n     tupleData[0] = DataFrame.of(dataTuples, internalStructType);\n     logger.info(\"DataFrame:\\r\\n{}\", ((DataFrame)tupleData[0]).toString());\n     \n     smile.data.Tuple smileTuple = smile.data.Tuple.of(tupleData, structType);\n     logger.info(\"Smile Tuple:\\r\\n{}\", smileTuple.toString());\n }`\n </denchmark-code>\n \n \t\t"}, "comments_5": {"comment_id": 6, "comment_author": "swarwick", "commentT": "2020-04-06T16:57:07Z", "comment_text": "\n \t\tYou got the data wrong. tupleData[0] is of DataFrame, not of StructType.\n \t\t"}, "comments_6": {"comment_id": 7, "comment_author": "swarwick", "commentT": "2020-04-06T17:00:09Z", "comment_text": "\n \t\tSorry yes the name of my test was wrong but still this is causing an exception.\n \t\t"}, "comments_7": {"comment_id": 8, "comment_author": "swarwick", "commentT": "2020-04-06T17:04:30Z", "comment_text": "\n \t\tI was talking about your code, not the name. The field is of StructType, but you supply a DataFrame object.\n \t\t"}, "comments_8": {"comment_id": 9, "comment_author": "swarwick", "commentT": "2020-04-06T17:29:09Z", "comment_text": "\n \t\tIsnt 'smile.data.type.DataTypes.array(internalStructType)' equal to a DataFrame? as DataFrame is an array of records right?\n \t\t"}, "comments_9": {"comment_id": 10, "comment_author": "swarwick", "commentT": "2020-04-06T17:31:36Z", "comment_text": "\n \t\tNope. Even if DataFrame is an array of StructType, they are different things in sense of type theory.\n \t\t"}, "comments_10": {"comment_id": 11, "comment_author": "swarwick", "commentT": "2020-04-06T17:39:38Z", "comment_text": "\n \t\tOk so I changed it up to use array data\n `    <denchmark-link:https://github.com/test>@test</denchmark-link>\n \n public void testDataFrameInArray() throws Exception {\n StructType internalStructType = new StructType(Arrays.asList(new StructField [] {\n new StructField(\"field1\", smile.data.type.DataTypes.IntegerType),\n new StructField(\"field2\", smile.data.type.DataTypes.StringType) }));\n <denchmark-code>\tStructType structType = new StructType(new StructField(\"data\", smile.data.type.DataTypes.array(internalStructType)));\n \t\n     logger.info(\"Struct:\\r\\n{}\",structType.toString());\n     \n     Object [] internalTupleData = new Object[internalStructType.fields().length];\n     internalTupleData[0] = 1;\n     internalTupleData[1] = \"testing\";\n     smile.data.Tuple internalSmileTuple = smile.data.Tuple.of(internalTupleData, internalStructType);\n     logger.info(\"Tuple1:\\r\\n{}\",internalSmileTuple.toString());\n     \n     Object [] internalTupleData2 = new Object[internalStructType.fields().length];\n     internalTupleData2[0] = 2;\n     internalTupleData2[1] = \"testing 2\";\n     smile.data.Tuple internalSmileTuple2 = smile.data.Tuple.of(internalTupleData2, internalStructType);\n     logger.info(\"Tuple2:\\r\\n{}\",internalSmileTuple2.toString());\n     \n     Object [] arrayData = new Object[2];\n     arrayData[0] = internalTupleData;\n     arrayData[1] = internalTupleData2;\n \n     Object [] tupleData = new Object[structType.fields().length];\n     tupleData[0] = arrayData;\n     smile.data.Tuple smileTuple = smile.data.Tuple.of(tupleData, structType);\n     logger.info(\"Smile Tuple:\\r\\n{}\", smileTuple.toString());\n }`\n </denchmark-code>\n \n Does that seem correct. If so when I output this last \"Smile Tuple\" I get:\n Data: { data: [[Ljava.lang.Object;@7dfb0c0f, [Ljava.lang.Object;@626abbd0] }\n With the internal array not actually printing.\n \t\t"}, "comments_11": {"comment_id": 12, "comment_author": "swarwick", "commentT": "2020-04-06T17:43:29Z", "comment_text": "\n \t\tIt is probably better to make internalStructType an ObjectType(DataFrame.class)\n \t\t"}, "comments_12": {"comment_id": 13, "comment_author": "swarwick", "commentT": "2020-04-06T18:05:48Z", "comment_text": "\n \t\tsmile.data.type.ObjectType is package internal so there is now was to access that constructor to create a new type.\n \t\t"}, "comments_13": {"comment_id": 14, "comment_author": "swarwick", "commentT": "2020-04-06T18:09:47Z", "comment_text": "\n \t\tDataTypes.object()\n \t\t"}, "comments_14": {"comment_id": 15, "comment_author": "swarwick", "commentT": "2020-04-06T18:19:28Z", "comment_text": "\n \t\tEven switching that out I still get an exception trying to toString the object\n `    <denchmark-link:https://github.com/test>@test</denchmark-link>\n \n public void testDataFrameInArray() throws Exception {\n StructType internalStructType = new StructType(Arrays.asList(new StructField [] {\n new StructField(\"field1\", smile.data.type.DataTypes.IntegerType),\n new StructField(\"field2\", smile.data.type.DataTypes.StringType) }));\n <denchmark-code>\tStructType structType = new StructType(new StructField(\"data\", smile.data.type.DataTypes.array(smile.data.type.DataTypes.object(smile.data.DataFrame.class))));\n     logger.info(\"Struct:\\r\\n{}\",structType.toString());\n     \n     Object [] internalTupleData = new Object[internalStructType.fields().length];\n     internalTupleData[0] = 1;\n     internalTupleData[1] = \"testing\";\n     smile.data.Tuple internalSmileTuple = smile.data.Tuple.of(internalTupleData, internalStructType);\n     logger.info(\"Tuple1:\\r\\n{}\",internalSmileTuple.toString());\n     \n     Object [] internalTupleData2 = new Object[internalStructType.fields().length];\n     internalTupleData2[0] = 2;\n     internalTupleData2[1] = \"testing 2\";\n     smile.data.Tuple internalSmileTuple2 = smile.data.Tuple.of(internalTupleData2, internalStructType);\n     logger.info(\"Tuple2:\\r\\n{}\",internalSmileTuple2.toString());\n     \n     List<smile.data.Tuple> dataTuples = new ArrayList<>();\n \tdataTuples.add(internalSmileTuple);\n \tdataTuples.add(internalSmileTuple2);\n     \n     Object [] tupleData = new Object[structType.fields().length];\n     tupleData[0] = DataFrame.of(dataTuples, internalStructType);\n     smile.data.Tuple smileTuple = smile.data.Tuple.of(tupleData, structType);\n     logger.info(\"Smile Tuple:\\r\\n{}\", smileTuple.toString());\n }`\n </denchmark-code>\n \n \t\t"}, "comments_15": {"comment_id": 16, "comment_author": "swarwick", "commentT": "2020-04-06T18:20:13Z", "comment_text": "\n \t\tOr are you saying done do an array of data frames... I guess they are already internally an array.\n \t\t"}, "comments_16": {"comment_id": 17, "comment_author": "swarwick", "commentT": "2020-04-06T18:21:55Z", "comment_text": "\n \t\tI removed the smile.data.type.DataTypes.array part around the dataframe part and that does print properly and I think works for our use case as well, so if you dont want to investigate an error with a dataframe inside an array I am ok with closing this issue.\n \t\t"}, "comments_17": {"comment_id": 18, "comment_author": "swarwick", "commentT": "2020-04-06T18:52:25Z", "comment_text": "\n \t\tYou can close it. Again it is not an error as a wrong typed object was used (more importantly, you seems still confused about the type and its semantic meaning).\n \t\t"}}}, "commit": {"commit_id": "aee9593a44acbc6499e7cb97897eb058a3dd1249", "commit_author": "Haifeng Li", "commitT": "2020-04-03 16:35:25-04:00", "commit_complexity": {"commit_NLOC": "0.0", "commit_CCN": "0.0", "commit_Nprams": "1.0"}, "changed_files": {"file_0": {"file_change_type": "MODIFY", "file_Nmethod": 1, "file_old_name": "data\\src\\main\\java\\smile\\data\\type\\ArrayType.java", "file_new_name": "data\\src\\main\\java\\smile\\data\\type\\ArrayType.java", "file_complexity": {"file_NLOC": "69", "file_CCN": "18", "file_NToken": "487"}, "hunks": {"hunk_0": {"Ismethod": 1, "added_lines": "80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99", "deleted_lines": "80", "method_info": {"method_name": "ArrayType::toString", "method_params": "o", "method_startline": "79", "method_endline": "100", "method_complexity": {"method_NLOC": "22", "method_CCN": "9", "method_NToken": "160", "method_nesting_level": "1"}}}}}}}}