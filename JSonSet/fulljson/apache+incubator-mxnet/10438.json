{"BR": {"BR_id": "10438", "BR_author": "milandesai", "BRopenT": "2018-04-06T09:26:25Z", "BRcloseT": "2018-08-24T21:26:14Z", "BR_text": {"BRsummary": "Loading an older model with a custom operator from Java/Scala more than twice causes MXNet to crash", "BRdescription": "\n <denchmark-h:h2>Version</denchmark-h>\n \n MXNet 1.1.0 with Scala\n <denchmark-h:h2>Description</denchmark-h>\n \n Our Scala application uses MxNet and includes several tests. Many of these tests load the same model files, so as a result the same process ends up loading a model multiple times. This normally works fine, but when upgrading from 0.11.0 to 1.1.0 we discovered an odd issue causing our tests to fail. We discovered that if you have a model that uses a custom operator and was built from an mxnet version older than the current one (thus prompting the \"Attempting to upgrade...\" message), and you load it more than twice in the same process, then on the third reload it crashes.\n <denchmark-h:h2>Analysis</denchmark-h>\n \n Based on my investigation, the relevant lines appear to be:\n \n legacy_json_util.cc#UpgradeJSON_FixParsing (line 30): This method is run whenever a model older than the current version is loaded. It invokes the attribute parser for each op.\n legacy_json_util.cc#UpgradeJSON_Parse (line 92): This method is always run. It also invokes the attribute parser for each op\n custom.cc#AttrParser (line 80): This line resets the shared pointer to the custom operator's callback list. Note that it also sets up a deleter function that unregisters the op by invoking the function in the next bullet.\n ml_dmlc_mxnet_native_c_api.cc#opPropDel (line 2426): This function unregisters the custom operator. However, there is logic here that tracks how many times this function has been invoked. It only deregisters the custom op on the third invocation.\n \n Suppose we are running MXNet 1.1.0 and load a model built on 0.11.0. Because of the version mismatch, both of the UpgradeJSON stages are run, each one running the attribute parser for each op. When the custom op's attribute parser is run the second time, the shared pointer to the operator's callback list is reset, triggering the unregister function to be invoked. This function, for now, simply updates a counter. The counter now has value 1.\n Now suppose during the same process, we load the same model again. The same scenario as above happens again, except this time the counter is incremented to 2.\n The third time the model is loaded, again the same scenario reoccurs, except this time the counter is already at value 2, so the unregister function actually unregisters the custom op rather than simply updating the counter. Our custom operator is no longer registered, so shortly thereafter we get an \"Operator [op-name] is not registered\" fatal error.\n \t"}, "comments": {"comments_0": {"comment_id": 1, "comment_author": "milandesai", "commentT": "2018-07-24T22:00:47Z", "comment_text": "\n \t\tI've been looking into this bug. It seems to occur whenever the upgradeJSON stage encounters the same custom operator 3 times. In your case it happens because you're reloading the same model but it can also occur if the operator is in the same model 3 times.\n Best I can tell there isn't actually anything to be done in opPropDel. Obviously deregistering the operator isn't correct and there doesn't appear to be any native memory which should be freed. I'm working on a PR which should fix this.\n \t\t"}, "comments_1": {"comment_id": 2, "comment_author": "milandesai", "commentT": "2018-08-24T21:26:14Z", "comment_text": "\n \t\tHi Milan, this issue is resolved, we are about release 1.3 and will make it available through Maven. I closing this issue as resolved, please open a new issue if you still find issues.\n \t\t"}}}, "commit": {"commit_id": "bf1edafcd65c65e57a1a40c9f978af4a452dcf00", "commit_author": "Andrew Ayres", "commitT": "2018-08-21 14:48:09-07:00", "commit_complexity": {"commit_NLOC": "1.0", "commit_CCN": "1.0", "commit_Nprams": "1.0"}, "changed_files": {"file_0": {"file_change_type": "MODIFY", "file_Nmethod": 1, "file_old_name": "scala-package\\native\\src\\main\\native\\org_apache_mxnet_native_c_api.cc", "file_new_name": "scala-package\\native\\src\\main\\native\\org_apache_mxnet_native_c_api.cc", "file_complexity": {"file_NLOC": "2162", "file_CCN": "238", "file_NToken": "18906"}, "hunks": {"hunk_0": {"Ismethod": 1, "added_lines": "1918,1937,2419,2420,2421,2422,2423,2424,2425,2426", "deleted_lines": "1918,1925,1940,2422,2423,2424,2425,2426,2427,2428,2429,2430,2431,2432,2433,2434,2435,2436,2437,2438,2439,2440,2441,2442,2443,2444,2445,2446,2447,2448,2449,2450,2451,2452,2453,2454", "method_info": {"method_name": "Java_org_apache_mxnet_LibInfo_mxCustomOpRegister", "method_params": "env,obj,jregName,jopProp", "method_startline": "1909", "method_endline": "2483", "method_complexity": {"method_NLOC": "523", "method_CCN": "47", "method_NToken": "4860", "method_nesting_level": "0"}}}}}}}}