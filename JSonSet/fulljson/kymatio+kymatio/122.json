{"BR": {"BR_id": "122", "BR_author": "janden", "BRopenT": "2018-11-05T20:53:14Z", "BRcloseT": "2018-11-30T19:51:36Z", "BR_text": {"BRsummary": "3D crashes on CPU", "BRdescription": "\n Getting the following error when calling forward:\n <denchmark-code>  File \"/home/janden/projects/kymatio/scattering/scattering3d/scattering3d.py\", line 326, in forward\n     conv_modulus, method, method_args, j_1))\n   File \"/home/janden/projects/kymatio/scattering/scattering3d/scattering3d.py\", line 175, in _compute_scattering_coefs\n     return self._compute_standard_scattering_coefs(input_array)\n   File \"/home/janden/projects/kymatio/scattering/scattering3d/scattering3d.py\", line 105, in _compute_standard_scattering_coefs\n     convolved_input = self._low_pass_filter(input_array, self.J)\n   File \"/home/janden/projects/kymatio/scattering/scattering3d/scattering3d.py\", line 85, in _low_pass_filter\n     cuda = isinstance(input_array, torch.cuda.FloatTensor)\n RuntimeError: cuda runtime error (30) : unknown error at /opt/conda/conda-bld/pytorch_1532584813488/work/aten/src/THC/THCGeneral.cpp:74\n </denchmark-code>\n \n From what I understand, the code is set up to detect whether the input is GPU and apply the appropriate operators (there's not cuda() or cpu() functions to convert the transformer like in 1D and 2D). Looks like when I run this without CUDA enabled, it crashes when trying to determine the type of the input tensor. It might be my personal config, but I should mention that torch.cuda.is_available() works without crashing.\n More bigger picture, do we want to modify this implementation to more closely align with the 1D/2D calling sequence? May make things easier for users (and also prevent the above type of errors).\n \t"}, "comments": {"comments_0": {"comment_id": 1, "comment_author": "janden", "commentT": "2018-11-06T06:25:32Z", "comment_text": "\n \t\tHmm so I think that this isinstance(input_array, torch.cuda.FloatTensor) call is not a good idea for how to find out whether a tensor is on GPU and should be fixed. Is that the call that is causing the error? (can't tell for sure)\n I think the calling sequence should be as similar as possible. That said, the code does something smart, quite implicitly, which is to copy filters back and forth from GPU. This is very useful in the 3D setting (as opposed to having all the filters in GPU memory all the time), because 3D images of any reasonable size together with the extra multiples of memory required to process them end up taking up a lot of space on the device.\n So yes, we should make the things as similar as possible, but there might be some limits. (That was also one reason for having separate code bases and merging what is mergeable later on rather than trying to unify everything from the beginning)\n \t\t"}, "comments_1": {"comment_id": 2, "comment_author": "janden", "commentT": "2018-11-06T06:32:08Z", "comment_text": "\n \t\tYes that's the call that causes the crash.\n Right. That makes sense. Maybe that's an argument for having the same behavior for 1D/2D? The reason I'm bringing this up now is that it would be better to commit to a similar API from the beginning, as opposed to having things break down the road. Of course, we should only do this if we're relatively certain this is the way we want to go.\n \t\t"}, "comments_2": {"comment_id": 3, "comment_author": "janden", "commentT": "2018-11-06T06:39:36Z", "comment_text": "\n \t\tThere is also this is_cuda method that Tensors and Variables have. I think this is a standard pytorch thing, but haven't pushed to adding it because I wasn't sure which version it was added, etc.\n There is a big chance that this would solve the issue (on top of making the code more readable). One could also just somehow log somewhere that \"hey we are currently doing CPU\".\n \n Maybe that's an argument for having the same behavior for 1D/2D?\n \n Actually I'd like to make sure I understand precisely what behavior you are referring to here\n \t\t"}, "comments_3": {"comment_id": 4, "comment_author": "janden", "commentT": "2018-11-06T06:44:28Z", "comment_text": "\n \t\tOk. What I meant is that it may make sense to have the 1D/2D implementations detect whether the input is CPU/GPU and move their filters to/from the GPU depending, just like the 3D implementation. That is, we wouldn't have any cuda() or cpu() functions for Scattering1D and Scattering2D. The calling sequence would then be the same for 1D/2D/3D.\n \t\t"}, "comments_4": {"comment_id": 5, "comment_author": "janden", "commentT": "2018-11-06T06:50:47Z", "comment_text": "\n \t\tI'd say let's not do that:\n \n The pytorch convention of saying .cuda and .cpu to networks and them transferring reliably to that device seems like a useful thing to hold on to (and aspire to), because that is the behavior people will be used to.\n After release we can think about this magic check_array function which could do the converse of what you suggest (if set to do so): Move the data to where the model is (as opposed to moving the filters to where the data is). (This does not preclude 3D from storing most of its filters on CPU for space reasons - if it is declare to be on GPU it will perform its computations on GPU and that is what matters)\n \n \t\t"}, "comments_5": {"comment_id": 6, "comment_author": "janden", "commentT": "2018-11-06T07:00:04Z", "comment_text": "\n \t\tOk. You're right, we don't want to do anything unexpected. But that's all the more reason to have the 3D behave more like 1D and 2D (with cuda() and cpu() methods, that is), no? Like you say, these methods do not have to explicitly move all the filters on/off the GPU, but may just set a flag telling the object whether it's allowed to use the GPU or not.\n \t\t"}, "comments_6": {"comment_id": 7, "comment_author": "janden", "commentT": "2018-11-06T07:10:31Z", "comment_text": "\n \t\tYeah, I 100% agree with that.\n (Question is whether this should be before release or pushed to later. Though if we can find somebody to do it before release that would be great of course)\n \t\t"}, "comments_7": {"comment_id": 8, "comment_author": "janden", "commentT": "2018-11-06T07:13:43Z", "comment_text": "\n \t\tOk good. Again, for the sake of stabilizing the API, before release is better. I would take a look but 1) I'm still behind on the 1D doc and 2) I'm not very familiar with any of the 3D stuff. I may take a stab at it, though.\n \t\t"}, "comments_8": {"comment_id": 9, "comment_author": "janden", "commentT": "2018-11-18T14:51:31Z", "comment_text": "\n \t\t<denchmark-link:https://github.com/louity>@louity</denchmark-link>\n  can you add this feature?\n \t\t"}, "comments_9": {"comment_id": 10, "comment_author": "janden", "commentT": "2018-11-20T20:45:30Z", "comment_text": "\n \t\tThis needs to be fixed before release.\n \t\t"}, "comments_10": {"comment_id": 11, "comment_author": "janden", "commentT": "2018-11-22T23:35:35Z", "comment_text": "\n \t\tYeah this is more important than having a skcuda backend for 3D\n \t\t"}, "comments_11": {"comment_id": 12, "comment_author": "janden", "commentT": "2018-11-30T04:04:21Z", "comment_text": "\n \t\tInterestingly, this doesn't crash if method='integral' is specified. All tests in the 3D suite have this set, which is why Travis doesn't complain.\n \t\t"}, "comments_12": {"comment_id": 13, "comment_author": "janden", "commentT": "2018-11-30T04:09:00Z", "comment_text": "\n \t\tLooks like the culprit is Scattering3D._low_pass_filter which checks CUDAness of the input using isinstance(x, torch.cuda.FloatTensor). If method='integral', this is never called, so no crash. The only other function checking CUDAness in this instance is Scattering3D._rotation_covariant_convolution_and_modulus, which uses x.is_cuda.\n \t\t"}}}, "commit": {"commit_id": "0797b27d9a7f2d700b48591f732783e55e2d3051", "commit_author": "Joakim And\u00e9n", "commitT": "2018-11-30 14:51:35-05:00", "commit_complexity": {"commit_NLOC": "0.0", "commit_CCN": "1.0", "commit_Nprams": "1.0"}, "changed_files": {"file_0": {"file_change_type": "MODIFY", "file_Nmethod": 2, "file_old_name": "kymatio\\scattering3d\\scattering3d.py", "file_new_name": "kymatio\\scattering3d\\scattering3d.py", "file_complexity": {"file_NLOC": "179", "file_CCN": "28", "file_NToken": "1107"}, "hunks": {"hunk_0": {"Ismethod": 1, "added_lines": "89", "deleted_lines": "89", "method_info": {"method_name": "_low_pass_filter", "method_params": "self,input_array,j", "method_startline": "73", "method_endline": "93", "method_complexity": {"method_NLOC": "6", "method_CCN": "2", "method_NToken": "42", "method_nesting_level": "1"}}}, "hunk_1": {"Ismethod": 1, "added_lines": "243", "deleted_lines": "243", "method_info": {"method_name": "_convolution_and_modulus", "method_params": "self,input_array,l,j,m", "method_startline": "218", "method_endline": "247", "method_complexity": {"method_NLOC": "6", "method_CCN": "2", "method_NToken": "57", "method_nesting_level": "1"}}}}}, "file_1": {"file_change_type": "MODIFY", "file_Nmethod": 1, "file_old_name": "kymatio\\scattering3d\\tests\\test_scattering3d.py", "file_new_name": "kymatio\\scattering3d\\tests\\test_scattering3d.py", "file_complexity": {"file_NLOC": "136", "file_CCN": "21", "file_NToken": "1228"}, "hunks": {"hunk_0": {"Ismethod": 1, "added_lines": "156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177", "deleted_lines": null, "method_info": {"method_name": "test_scattering_methods", "method_params": "", "method_startline": "156", "method_endline": "177", "method_complexity": {"method_NLOC": "18", "method_CCN": "2", "method_NToken": "163", "method_nesting_level": "0"}}}}}}}}