{"BR": {"BR_id": "389", "BR_author": "ghost(ghost)", "BRopenT": "2019-01-18T18:54:55Z", "BRcloseT": "2019-01-25T04:25:49Z", "BR_text": {"BRsummary": "compilation error when MKLDNN_VERBOSE is disabled", "BRdescription": "\n compilation error when MKLDNN_VERBOSE is disabled.\n In shuffle_pd.hpp\n LINE 47: virtual void init_info() override { init_info_shuffle(this, this->info_); }\n \"init_info_shuffle\" not found when MKLDNN_VERBOSE is disabled\n <denchmark-h:hr></denchmark-h>\n \n Windows 10 x64 Pro\n VS2017 15.9.5\n \t"}, "comments": {"comments_0": {"comment_id": 1, "comment_author": "ghost(ghost)", "commentT": "2019-01-18T21:03:34Z", "comment_text": "\n \t\tThanks for the report! Reproduced. A fix is under review.\n \t\t"}, "comments_1": {"comment_id": 2, "comment_author": "ghost(ghost)", "commentT": "2019-01-22T07:12:34Z", "comment_text": "\n \t\tHi @zeno40,\n Just curious why do you prefer building Intel MKL-DNN w/o verbose support?\n \t\t"}, "comments_2": {"comment_id": 3, "comment_author": "ghost(ghost)", "commentT": "2019-01-22T11:00:43Z", "comment_text": "\n \t\tI'm just curious if there some (small) speed advantage w/o verbose support enabled. It's not\n something I really need in an application if there's no speed advantage.\n \t\t"}, "comments_3": {"comment_id": 4, "comment_author": "ghost(ghost)", "commentT": "2019-01-22T11:38:22Z", "comment_text": "\n \t\tThe performance difference should be negligible, as long as you don't export MKLDNN_VERBOSE=1. The only difference between the library that is built w/o verbose and w/ verbose (but w/o using it) is that in the latter case every time you create a primitive descriptor it forms a string with the information (that would be used if a user set MKLDNN_VERBOSE environment variable). But that shouldn't affect performance, especially if you create a primitive descriptor and primitive once, and then just reuse the latter.\n \t\t"}, "comments_4": {"comment_id": 5, "comment_author": "ghost(ghost)", "commentT": "2019-01-22T11:57:07Z", "comment_text": "\n \t\tThanks,\n I now better understand there's no real performance cost involved  as long as I don't export MKLDNN_VERBOSE=1\n \t\t"}}}, "commit": {"commit_id": "a4627e666a53e0812d700ea59b33af6a3876fc7f", "commit_author": "Roman Dubtsov", "commitT": "2019-01-18 13:08:35-08:00", "commit_complexity": {"commit_NLOC": "None", "commit_CCN": "None", "commit_Nprams": "None"}, "changed_files": {"file_0": {"file_change_type": "MODIFY", "file_Nmethod": 0, "file_old_name": "src\\common\\verbose.hpp", "file_new_name": "src\\common\\verbose.hpp", "file_complexity": {"file_NLOC": "265", "file_CCN": "45", "file_NToken": "2998"}, "hunks": {"hunk_0": {"Ismethod": 0, "added_lines": "361", "deleted_lines": null}}}}}}