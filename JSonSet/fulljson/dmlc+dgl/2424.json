{"BR": {"BR_id": "2424", "BR_author": "yingzhu146", "BRopenT": "2020-12-16T04:30:00Z", "BRcloseT": "2020-12-17T09:29:17Z", "BR_text": {"BRsummary": "Compilation on osx-arm64 apple silicon m1", "BRdescription": "\n <denchmark-h:h2>\ud83d\udc1b Bug</denchmark-h>\n \n Trying to compile from source on the new macbook air with arm64e.\n <denchmark-h:h2>To Reproduce</denchmark-h>\n \n mkdir build\n cd build\n cmake ..\n make -j 8\n <denchmark-code>/Users/yingzhu/dgl/include/intel/cpu_support.h:70:16: error: no type named 'Reg64' in namespace 'Xbyak'\n   const Xbyak::Reg64 &r_out_;\n         ~~~~~~~^\n /Users/yingzhu/dgl/include/intel/cpu_support.h:71:16: error: no type named 'Reg64' in namespace 'Xbyak'\n   const Xbyak::Reg64 &r_left_;\n         ~~~~~~~^\n /Users/yingzhu/dgl/include/intel/cpu_support.h:72:16: error: no type named 'Reg64' in namespace 'Xbyak'\n   const Xbyak::Reg64 &r_right;\n         ~~~~~~~^\n /Users/yingzhu/dgl/include/intel/cpu_support.h:73:16: error: no type named 'Reg64' in namespace 'Xbyak'\n   const Xbyak::Reg64 &r_size_;\n         ~~~~~~~^\n /Users/yingzhu/dgl/include/intel/cpu_support.h:156:42: error: use of undeclared identifier 'r9'\n     alias_load<IType>(zmm0, ptr[r_out_ + r9 * sizeof(IType)]);\n                                         ^\n </denchmark-code>\n \n <denchmark-h:h2>Expected behavior</denchmark-h>\n \n Build without error\n <denchmark-h:h2>Environment</denchmark-h>\n \n \n DGL Version from master\n Backend Library & Version pytorch 1.7 installed\n OS (e.g., Linux): osx-arm64\n How you installed DGL (conda, pip, source): source\n Build command you used (if compiling from source): see above\n Python version: 3.8.5\n CUDA/cuDNN version (if applicable): na\n GPU models and configuration (e.g. V100): na\n Any other relevant information:\n \n <denchmark-h:h2>Additional context</denchmark-h>\n \n It clearly tries to use intel-specifc code - is there support for arm? i would expect 80% of all mac users to switch to arm in the next 5 years\n \t"}, "comments": {"comments_0": {"comment_id": 1, "comment_author": "yingzhu146", "commentT": "2020-12-16T17:58:35Z", "comment_text": "\n \t\tYes that's related to intel-specific optimizations (use AVX instructions, see <denchmark-link:https://github.com/dmlc/dgl/pull/2309>#2309</denchmark-link>\n  ). Actually we should only include this header when a intel CPU with avx support is detected, I'll fix it soon.\n \t\t"}, "comments_1": {"comment_id": 2, "comment_author": "yingzhu146", "commentT": "2020-12-16T21:30:18Z", "comment_text": "\n \t\t<denchmark-link:https://github.com/yzh119>@yzh119</denchmark-link>\n  thanks keep me posted. sorry for being dense but setting  doesn't work for me - any other way to disable this so I can build in mean time?\n \t\t"}, "comments_2": {"comment_id": 3, "comment_author": "yingzhu146", "commentT": "2020-12-17T02:12:54Z", "comment_text": "\n \t\tDGL_CPU_INTEL_KERNEL_ENABLED=0 only controls whether to use AVX optimized operator at runtime instead of compile time, I'll set a cmake flag to indicate whether to include the header at compile time.\n \t\t"}, "comments_3": {"comment_id": 4, "comment_author": "yingzhu146", "commentT": "2020-12-17T05:38:54Z", "comment_text": "\n \t\t<denchmark-link:https://github.com/yingzhu146>@yingzhu146</denchmark-link>\n  does <denchmark-link:https://github.com/dmlc/dgl/pull/2428>#2428</denchmark-link>\n  work in your case? (checkout the  branch in my fork).\n \t\t"}, "comments_4": {"comment_id": 5, "comment_author": "yingzhu146", "commentT": "2020-12-17T13:34:38Z", "comment_text": "\n \t\t<denchmark-link:https://github.com/yzh119>@yzh119</denchmark-link>\n  yes that worked perfectly thanks a lot for the help!\n \t\t"}}}, "commit": {"commit_id": "e379e52585e2d9a8b416dd5b3f909af7824dc562", "commit_author": "Zihao Ye", "commitT": "2020-12-17 17:29:15+08:00", "commit_complexity": {"commit_NLOC": "None", "commit_CCN": "None", "commit_Nprams": "None"}, "changed_files": {"file_0": {"file_change_type": "MODIFY", "file_Nmethod": 0, "file_old_name": "CMakeLists.txt", "file_new_name": "CMakeLists.txt", "file_complexity": {"file_NLOC": "None", "file_CCN": "None", "file_NToken": "None"}, "hunks": {"hunk_0": {"Ismethod": 0, "added_lines": "27,112,113,114,115", "deleted_lines": null}}}, "file_1": {"file_change_type": "MODIFY", "file_Nmethod": 0, "file_old_name": "cmake\\config.cmake", "file_new_name": "cmake\\config.cmake", "file_complexity": {"file_NLOC": "None", "file_CCN": "None", "file_NToken": "None"}, "hunks": {"hunk_0": {"Ismethod": 0, "added_lines": "42,43,44", "deleted_lines": null}}}, "file_2": {"file_change_type": "MODIFY", "file_Nmethod": 1, "file_old_name": "src\\array\\cpu\\spmm.h", "file_new_name": "src\\array\\cpu\\spmm.h", "file_complexity": {"file_NLOC": "177", "file_CCN": "68", "file_NToken": "1978"}, "hunks": {"hunk_0": {"Ismethod": 1, "added_lines": "46,68,69,91,93,94", "deleted_lines": "65,88", "method_info": {"method_name": "dgl::aten::cpu::SpMMSumCsr", "method_params": "bcast,csr,ufeat,efeat,out", "method_startline": "35", "method_endline": "95", "method_complexity": {"method_NLOC": "48", "method_CCN": "22", "method_NToken": "538", "method_nesting_level": "3"}}}}}, "file_3": {"file_change_type": "MODIFY", "file_Nmethod": 0, "file_old_name": "tests\\cpp\\test_spmm.cc", "file_new_name": "tests\\cpp\\test_spmm.cc", "file_complexity": {"file_NLOC": "252", "file_CCN": "53", "file_NToken": "2132"}, "hunks": {"hunk_0": {"Ismethod": 0, "added_lines": "2,317,318", "deleted_lines": "316"}}}}}}