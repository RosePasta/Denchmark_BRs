{"BR": {"BR_id": "2166", "BR_author": "violet-sto", "BRopenT": "2020-09-09T16:08:49Z", "BRcloseT": "2020-09-10T09:41:53Z", "BR_text": {"BRsummary": "Error when call apply_edges for dec_graph", "BRdescription": "\n <denchmark-h:h2>\ud83d\udc1b Bug</denchmark-h>\n \n When I'm reading the code in user guide's Chapter 5.2, I got error that ''the method shouldn't be called for UnitGraph graph. The relation graph is simply this graph itself.'' when I called apply_edges for dec_graph.\n <denchmark-h:h2>To Reproduce</denchmark-h>\n \n \n creat a decoder graph\n \n <denchmark-code>dec_graph = hetero_graph['user', :, 'item']\n </denchmark-code>\n \n \n define a model\n \n <denchmark-code>class Model(nn.Module):  \n     def __init__(self, in_features, hidden_features, out_features, rel_names):\n         super().__init__()\n         self.sage = RGCN(in_features, hidden_features, out_features, rel_names)\n         self.pred = HeteroMLPPredictor(out_features, len(rel_names))\n     def forward(self, g, x, dec_graph):\n         h = self.sage(g, x)\n         return self.pred(dec_graph, h)\n </denchmark-code>\n \n \n forward pass\n \n <denchmark-code>model=Model(10,20,5,hetero_graph.etpyes)\n logits = model(hetero_graph, node_features, dec_graph)\n </denchmark-code>\n \n here is the Error Traceback\n <denchmark-code>DGLError                                  Traceback (most recent call last)\n <ipython-input-22-58fb5a6d1b35> in <module>\n       1 opt = torch.optim.Adam(model.parameters())\n       2 for epoch in range(10):\n ----> 3     logits = model(hetero_graph, node_features, dec_graph)\n       4     loss = F.cross_entropy(logits, edge_label)\n       5     opt.zero_grad()\n \n D:\\anaconda\\lib\\site-packages\\torch\\nn\\modules\\module.py in _call_impl(self, *input, **kwargs)\n     720             result = self._slow_forward(*input, **kwargs)\n     721         else:\n --> 722             result = self.forward(*input, **kwargs)\n     723         for hook in itertools.chain(\n     724                 _global_forward_hooks.values(),\n \n <ipython-input-20-11c8c20b9ec1> in forward(self, g, x, dec_graph)\n       6     def forward(self, g, x, dec_graph):\n       7         h = self.sage(g, x)\n ----> 8         return self.pred(dec_graph, h)\n \n D:\\anaconda\\lib\\site-packages\\torch\\nn\\modules\\module.py in _call_impl(self, *input, **kwargs)\n     720             result = self._slow_forward(*input, **kwargs)\n     721         else:\n --> 722             result = self.forward(*input, **kwargs)\n     723         for hook in itertools.chain(\n     724                 _global_forward_hooks.values(),\n \n <ipython-input-19-25eb5ab390c5> in forward(self, graph, h)\n      15         # Avoids changing the graph features when exiting the function. However, In-place operations will still reflect to the original graph.\n      16             graph.ndata['h'] = h   # assigns 'h' of all node types in one shot\n ---> 17             graph.apply_edges(self.apply_edges)\n      18             return graph.edata['score']\n \n D:\\anaconda\\lib\\site-packages\\dgl\\heterograph.py in apply_edges(self, func, edges, etype, inplace)\n    4054         etid = self.get_etype_id(etype)\n    4055         etype = self.canonical_etypes[etid]\n -> 4056         g = self if etype is None else self[etype]\n    4057         if is_all(edges):\n    4058             eid = ALL\n \n D:\\anaconda\\lib\\site-packages\\dgl\\heterograph.py in __getitem__(self, key)\n    1919             etid = self.get_etype_id((srctype, etype, dsttype))\n    1920             dtid = self.get_ntype_id_from_dst(dsttype)\n -> 1921             new_g = self._graph.get_relation_graph(etid)\n    1922 \n    1923             if stid == dtid:\n \n D:\\anaconda\\lib\\site-packages\\dgl\\heterograph_index.py in get_relation_graph(self, etype)\n      91             The unitgraph graph.\n      92         \"\"\"\n ---> 93         return _CAPI_DGLHeteroGetRelationGraph(self, int(etype))\n      94 \n      95     def flatten_relations(self, etypes):\n \n D:\\anaconda\\lib\\site-packages\\dgl\\_ffi\\_ctypes\\function.py in __call__(self, *args)\n     188         check_call(_LIB.DGLFuncCall(\n     189             self.handle, values, tcodes, ctypes.c_int(num_args),\n --> 190             ctypes.byref(ret_val), ctypes.byref(ret_tcode)))\n     191         _ = temp_args\n     192         _ = args\n \n D:\\anaconda\\lib\\site-packages\\dgl\\_ffi\\base.py in check_call(ret)\n      60     \"\"\"\n      61     if ret != 0:\n ---> 62         raise DGLError(py_str(_LIB.DGLGetLastError()))\n      63 \n      64 \n \n DGLError: [19:15:55] c:\\users\\administrator\\dgl-0.5\\src\\graph\\./unit_graph.h:61: The method shouldn't be called for UnitGraph graph. The relation graph is simply this graph itself.\n </denchmark-code>\n \n \t"}, "comments": {"comments_0": {"comment_id": 1, "comment_author": "violet-sto", "commentT": "2020-09-10T06:41:54Z", "comment_text": "\n \t\t<denchmark-link:https://github.com/BarclayII>@BarclayII</denchmark-link>\n  Is it still encouraged to use slicing for heterographs? At least for the graph chapter we recommended  followed by .\n \t\t"}, "comments_1": {"comment_id": 2, "comment_author": "violet-sto", "commentT": "2020-09-10T06:45:32Z", "comment_text": "\n \t\t\n @BarclayII Is it still encouraged to use slicing for heterographs? At least for the graph chapter we recommended edge_type_subgraph followed by to_homogeneous.\n \n This is kinda different.  We are not expecting a homogeneous graph, but a bipartite graph with all edge types \"combined\" to one edge type.\n \t\t"}, "comments_2": {"comment_id": 3, "comment_author": "violet-sto", "commentT": "2020-09-10T06:54:31Z", "comment_text": "\n \t\t\n \n @BarclayII Is it still encouraged to use slicing for heterographs? At least for the graph chapter we recommended edge_type_subgraph followed by to_homogeneous.\n \n This is kinda different. We are not expecting a homogeneous graph, but a bipartite graph with all edge types \"combined\" to one edge type.\n \n Got it. Thanks.\n \t\t"}, "comments_3": {"comment_id": 4, "comment_author": "violet-sto", "commentT": "2020-09-10T07:50:27Z", "comment_text": "\n \t\t<denchmark-link:https://github.com/BarclayII>@BarclayII</denchmark-link>\n  Excuse me, I'm willing to know what's wrong with the code in the question. If I construct a new graph with the attributes of dec_graph, it works, What's the difference?\n <denchmark-code>graph=dgl.heterograph({('user','click+dislike','item'):dec_graph.edges()})`\n graph.edata['_TYPE']=dec_graph.edata['_TYPE']\n logits = model(hetero_graph, node_features, graph)\n </denchmark-code>\n \n \t\t"}, "comments_4": {"comment_id": 5, "comment_author": "violet-sto", "commentT": "2020-09-10T09:08:18Z", "comment_text": "\n \t\tThat's because of a bug in our implementation of g[...] in the C++ backend.  Basically the graph construction of g[...] is implemented in C, which returns a pointer of the wrong type that does not allow further slicing with g[...].  Your code is correct.\n \t\t"}, "comments_5": {"comment_id": 6, "comment_author": "violet-sto", "commentT": "2020-09-10T09:42:44Z", "comment_text": "\n \t\tThe fix will go into 0.5.2.\n \t\t"}}}, "commit": {"commit_id": "ac570c1dae4ad5180d99063b4a474e54d708627f", "commit_author": "Quan (Andy) Gan", "commitT": "2020-09-10 17:41:52+08:00", "commit_complexity": {"commit_NLOC": "0.0", "commit_CCN": "1.0", "commit_Nprams": "1.0"}, "changed_files": {"file_0": {"file_change_type": "MODIFY", "file_Nmethod": 1, "file_old_name": "python\\dgl\\heterograph.py", "file_new_name": "python\\dgl\\heterograph.py", "file_complexity": {"file_NLOC": "1920", "file_CCN": "415", "file_NToken": "11054"}, "hunks": {"hunk_0": {"Ismethod": 1, "added_lines": "1878,1896,1898,1899,1900,1901,1902,1903,1904,1905,1906,1907,1908,1909,1910,1911,1912,1913,1914,1915,1916,1917,1918,1919,1920,1921,1922,1923,1924,1925,1926,1927,1928,1929,1930,1931,1932,1933,1934,1935,1936,1937,1938,1939,1940,1941,1942,1943,1944,1945,1946,1947,1948,1949,1950,1951,1952", "deleted_lines": "1878,1896", "method_info": {"method_name": "__getitem__", "method_params": "self,key", "method_startline": "1875", "method_endline": "2021", "method_complexity": {"method_NLOC": "54", "method_CCN": "8", "method_NToken": "516", "method_nesting_level": "1"}}}}}, "file_1": {"file_change_type": "MODIFY", "file_Nmethod": 1, "file_old_name": "src\\graph\\heterograph.cc", "file_new_name": "src\\graph\\heterograph.cc", "file_complexity": {"file_NLOC": "437", "file_CCN": "67", "file_NToken": "4020"}, "hunks": {"hunk_0": {"Ismethod": 1, "added_lines": "487", "deleted_lines": "487", "method_info": {"method_name": "dgl::HeteroGraph::FlattenImpl", "method_params": "etypes", "method_startline": "398", "method_endline": "498", "method_complexity": {"method_NLOC": "84", "method_CCN": "11", "method_NToken": "818", "method_nesting_level": "1"}}}}}, "file_2": {"file_change_type": "MODIFY", "file_Nmethod": 1, "file_old_name": "tests\\compute\\test_heterograph.py", "file_new_name": "tests\\compute\\test_heterograph.py", "file_complexity": {"file_NLOC": "2020", "file_CCN": "152", "file_NToken": "28766"}, "hunks": {"hunk_0": {"Ismethod": 1, "added_lines": "797,798", "deleted_lines": null, "method_info": {"method_name": "test_flatten", "method_params": "idtype", "method_startline": "760", "method_endline": "862", "method_complexity": {"method_NLOC": "68", "method_CCN": "1", "method_NToken": "861", "method_nesting_level": "0"}}}}}}}}