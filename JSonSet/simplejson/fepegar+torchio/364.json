{"BR": {"BR_id": "364", "BR_author": "9B8DY6", "BRopenT": "2020-12-01T02:44:04Z", "BRcloseT": "2020-12-01T09:38:24Z", "BR_text": {"BRsummary": "PatchSampler object is not callable", "BRdescription": "\n \ud83d\udc1bBug\n TypeError: 'PatchSampler' object is not callable\n To reproduce\n ### dataloader with queue ###\n patch_size = 12\n samples_per_volume = 3\n max_queue_length = 300\n training_batch_size = 32\n validation_batch_size = 32\n \n \n patches_training_set = torchio.Queue(\n     subjects_dataset=training_set,\n     max_length=max_queue_length,\n     samples_per_volume=samples_per_volume,\n     sampler=torchio.data.PatchSampler(patch_size),\n     num_workers=0,\n     shuffle_subjects=True,\n     shuffle_patches=True,\n )\n \n patches_validation_set = torchio.Queue(\n     subjects_dataset=validation_set,\n     max_length=max_queue_length,\n     samples_per_volume=samples_per_volume,\n     sampler=torchio.data.PatchSampler(patch_size),\n     num_workers=0,\n     shuffle_subjects=False,\n     shuffle_patches=False,\n )\n \n training_loader = torch.utils.data.DataLoader(\n     patches_training_set, batch_size=training_batch_size)\n \n validation_loader = torch.utils.data.DataLoader(\n     patches_validation_set, batch_size=validation_batch_size)\n \n #training\n \n count = 0\n loss_valid = np.array([])\n iteration_list = []\n loss_train = np.array([])\n \n for epoch in range(num_epochs):\n     count += 1\n     i=0\n     l_epoch=0\n     \n     for batch in training_loader:\n         model.to(device).train()\n         inputs_train = batch['mri'][DATA].to(device)\n         target_train = (batch['age']/100.).float().to(device)\n         i=i+1\n         optimizer.zero_grad()\n         outputs = model(inputs_train)\n         target_train= target_train.reshape(-1,1)\n         loss = error(outputs, target_train).to(device)\n         l_epoch+=loss\n         loss.backward()\n         optimizer.step()\n         \n     loss_train = np.append(loss_train,l_epoch.cpu().detach().numpy()/i)\n     print('epoch_train : ',count)\n     print('train loss: ',loss_train[-1])\n     print('outputs : ',outputs[:5])\n     print('label : ',target_train[:5])\n     torch.save(model.state_dict(), f'v0_patch_T1_reg_PD_new_1.pth')\n         \n     i=0\n     l_epoch=0\n     for batch in validation_loader:\n       model.to(device).eval()\n       inputs_test = batch['mri'][DATA].to(device)\n       target_test = (batch['age']/100.).float().to(device)\n       i=i+1\n       outputs = model(inputs_test)\n       target_test= target_test.reshape(-1,1)\n       loss = error(outputs, target_test).to(device)\n       l_epoch+=loss\n     loss_valid = np.append(loss_valid,l_epoch.cpu().detach().numpy()/i)\n     scheduler.step(loss_valid[-1])\n     \n     print('valid_epoch: {}  valid_loss: {} '.format(count, loss_valid[-1]))\n     plt.plot(loss_train,label='train loss')\n     plt.plot(loss_valid,label='valid loss')\n \n     plt.legend(loc='upper right')\n     plt.title('epoch: %d '%(epoch))\n     plt.pause(.0001)\n \n     print('train loss: ',loss_train[-1])\n     print('valid loss: ',loss_valid[-1])\n TypeError                                 Traceback (most recent call last)\n <ipython-input-37-1b712dc4dcbb> in <module>()\n      13     l_epoch=0\n      14 \n ---> 15     for batch in training_loader:\n      16         model.to(device).train()\n      17         inputs_train = batch['mri'][DATA].to(device)\n \n ~\\Anaconda3\\envs\\dyb\\lib\\site-packages\\torch\\utils\\data\\dataloader.py in __next__(self)\n     343 \n     344     def __next__(self):\n --> 345         data = self._next_data()\n     346         self._num_yielded += 1\n     347         if self._dataset_kind == _DatasetKind.Iterable and \\\n \n ~\\Anaconda3\\envs\\dyb\\lib\\site-packages\\torch\\utils\\data\\dataloader.py in _next_data(self)\n     383     def _next_data(self):\n     384         index = self._next_index()  # may raise StopIteration\n --> 385         data = self._dataset_fetcher.fetch(index)  # may raise StopIteration\n     386         if self._pin_memory:\n     387             data = _utils.pin_memory.pin_memory(data)\n \n ~\\Anaconda3\\envs\\dyb\\lib\\site-packages\\torch\\utils\\data\\_utils\\fetch.py in fetch(self, possibly_batched_index)\n      42     def fetch(self, possibly_batched_index):\n      43         if self.auto_collation:\n ---> 44             data = [self.dataset[idx] for idx in possibly_batched_index]\n      45         else:\n      46             data = self.dataset[possibly_batched_index]\n \n ~\\Anaconda3\\envs\\dyb\\lib\\site-packages\\torch\\utils\\data\\_utils\\fetch.py in <listcomp>(.0)\n      42     def fetch(self, possibly_batched_index):\n      43         if self.auto_collation:\n ---> 44             data = [self.dataset[idx] for idx in possibly_batched_index]\n      45         else:\n      46             data = self.dataset[possibly_batched_index]\n \n ~\\Anaconda3\\envs\\dyb\\lib\\site-packages\\torchio\\data\\queue.py in __getitem__(self, _)\n     104         if not self.patches_list:\n     105             self.print('Patches list is empty.')\n --> 106             self.fill()\n     107         sample_patch = self.patches_list.pop()\n     108         self.num_sampled_patches += 1\n \n ~\\Anaconda3\\envs\\dyb\\lib\\site-packages\\torchio\\data\\queue.py in fill(self)\n     160         for _ in iterable:\n     161             subject_sample = self.get_next_subject_sample()\n --> 162             iterable = self.sampler(subject_sample)\n     163             patches = list(islice(iterable, self.samples_per_volume))\n     164             self.patches_list.extend(patches)\n \n TypeError: 'PatchSampler' object is not callable\n Expected behavior\n Actual behavior\n TorchIO version\n \n \n 0.17.0\n \n       \n \t"}, "comments": {"comments_0": {"comment_id": 1, "comment_author": "9B8DY6", "commentT": "2020-12-01T09:28:22Z", "comment_text": "\n \t\tHi, <denchmark-link:https://github.com/9B8DY6>@9B8DY6</denchmark-link>\n .\n \n Please use a more recent version of TorchIO: pip install --upgrade torchio\n PatchSampler is indeed not callable. You should use a child class as in the examples. I will reorganize the docs and add a note about this\n \n \t\t"}}}, "commit": {"commit_id": "fb2adc76b7b4a39b4fedb0574f4db106e6dfdf42", "commit_author": "Fernando", "commitT": "2020-12-01 09:36:17+00:00", "changed_files": {"file_0": {"file_change_type": "MODIFY", "file_Nmethod": 0, "file_old_name": "docs\\source\\data\\patch_training.rst", "file_new_name": "docs\\source\\data\\patch_training.rst", "hunks": {"hunk_0": {"Ismethod": 0, "added_lines": "4,5,10,11,19,20,22,33,34,36,40,43", "deleted_lines": "8,9,16,19,20,21,22,33,34,36,40,43"}}}, "file_1": {"file_change_type": "MODIFY", "file_Nmethod": 0, "file_old_name": "torchio\\data\\sampler\\sampler.py", "file_new_name": "torchio\\data\\sampler\\sampler.py", "hunks": {"hunk_0": {"Ismethod": 0, "added_lines": "15,17,18,19,20,74", "deleted_lines": "15,70"}}}}}}