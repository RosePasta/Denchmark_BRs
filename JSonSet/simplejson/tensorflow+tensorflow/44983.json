{"BR": {"BR_id": "44983", "BR_author": "Engineero", "BRopenT": "2020-11-18T15:52:14Z", "BRcloseT": "2020-12-25T03:56:48Z", "BR_text": {"BRsummary": "tf.image.per_image_standardization unexpected behavior with unsigned integer input", "BRdescription": "\n System information\n \n Have I written custom code (as opposed to using a stock example script provided in TensorFlow): yes\n OS Platform and Distribution (e.g., Linux Ubuntu 16.04): Linux Ubuntu 18.04.4\n TensorFlow installed from (source or binary): pip\n TensorFlow version (use command below): v2.2.0-57-g25fba035f3 2.2.1\n Python version: 3.7.7\n CUDA/cuDNN version: 10.1.243\n GPU model and memory: Nvidia Tesla V100-DGXS-32GB,\n \n Describe the current behavior\n tf.image.per_image_standardization has no special handling for unsigned integers but still converts back to unsigned before returning. Thus uint inputs get saturated at zero (fully half of the data!) and at their maximum value. Currently no explanation of uint behavior is given in the docstring, and no warning or other indication that behavior might be unexpected is shown.\n Describe the expected behavior\n In previous versions of TensorFlow (I believe changed after 1.14), per_image_standardization just returned a float rather than converting back to the original datatype, so it didn't have this problem. I would expect something safe like that, leaving it up to the developer to decide how they want this conversion handled, or at least a warning printed in the event a uint input is given. Some documentation specifying that uints are not handled differently and will be saturated might be nice too.\n \n <denchmark-link:https://colab.research.google.com/drive/1PqjTWtgLPE7hb5Dza2fZdFNbhlyW3mKl?usp=sharing>Colab notebook link</denchmark-link>\n .\n Other info / logs\n No tracebacks or logs because it doesn't throw an error. I would call this a failure mode, but it fails silently. I suspect it's an edge case that isn't tested.\n \t"}, "comments": {"comments_0": {"comment_id": 1, "comment_author": "Engineero", "commentT": "2020-11-19T02:47:39Z", "comment_text": "\n \t\t<denchmark-link:https://github.com/Engineero>@Engineero</denchmark-link>\n \n Please, grant me access to colab link. Thanks!\n \t\t"}, "comments_1": {"comment_id": 2, "comment_author": "Engineero", "commentT": "2020-11-19T02:49:34Z", "comment_text": "\n \t\t<denchmark-link:https://github.com/ravikyram>@ravikyram</denchmark-link>\n \n Sorry, haven't used colab much. It should be fixed now.\n \t\t"}, "comments_2": {"comment_id": 3, "comment_author": "Engineero", "commentT": "2020-11-19T03:26:06Z", "comment_text": "\n \t\tI have tried in colab with TF version 2.3 and nightly version() and was able to reproduce the issue. Please, find the gist <denchmark-link:https://colab.research.google.com/gist/ravikyram/88120ddb0fd04644a3d2d4075ca97f7f/untitled524.ipynb>here</denchmark-link>\n . Thanks!\n \t\t"}, "comments_3": {"comment_id": 4, "comment_author": "Engineero", "commentT": "2020-11-19T03:28:19Z", "comment_text": "\n \t\tFor the record, I think the behavior changed between 1.14 and 1.15, which is why I suspect an untested edge case. I had a use case where this affected training, and while it's certainly not backwards-incompatible (doesn't error out anyway), it is a surprise.\n \t\t"}, "comments_4": {"comment_id": 5, "comment_author": "Engineero", "commentT": "2020-11-19T06:17:58Z", "comment_text": "\n \t\t<denchmark-link:https://github.com/Engineero>@Engineero</denchmark-link>\n , related issue:\n <denchmark-link:https://github.com/tensorflow/tensorflow/issues/33892>#33892</denchmark-link>\n \n \t\t"}, "comments_5": {"comment_id": 6, "comment_author": "Engineero", "commentT": "2020-11-19T06:21:55Z", "comment_text": "\n \t\tHere is the offending commit:\n <denchmark-link:https://github.com/tensorflow/tensorflow/commit/906e0e3bc0dfe12db19afa261e4d793b73cb64ec>906e0e3</denchmark-link>\n \n \t\t"}, "comments_6": {"comment_id": 7, "comment_author": "Engineero", "commentT": "2020-11-19T06:24:46Z", "comment_text": "\n \t\tOh, hey <denchmark-link:https://github.com/mixxen>@mixxen</denchmark-link>\n ! Good find, thanks!\n \t\t"}, "comments_7": {"comment_id": 8, "comment_author": "Engineero", "commentT": "2020-12-04T15:33:21Z", "comment_text": "\n \t\tIt looks like simply casting (not with convert_image_dtype, just tf.cast) to float prior to per_image_normalization prevents information loss. I'd create a pull request, but I think the bigger question is what is the intended behavior when given unsigned integer input and how should that be communicated? Also covering this edge case with tests.\n \t\t"}, "comments_8": {"comment_id": 9, "comment_author": "Engineero", "commentT": "2020-12-20T21:05:50Z", "comment_text": "\n \t\tThank you for reporting the issue <denchmark-link:https://github.com/Engineero>@Engineero</denchmark-link>\n  and identifying the offending commit <denchmark-link:https://github.com/mixxen>@mixxen</denchmark-link>\n .\n The changes in <denchmark-link:https://github.com/tensorflow/tensorflow/commit/906e0e3bc0dfe12db19afa261e4d793b73cb64ec>906e0e3</denchmark-link>\n  appears to have changed the behavior of  unintentionally and should be reverted back in my opinion. It especially does not make sense for unsigned integer data types because images that have zero-mean will consist of negative and positive values (unless all values are 0). The API function has been working with  dtypes (until the breaking change) and should continue to do so. I'll get a fix in shortly.\n \t\t"}, "comments_9": {"comment_id": 10, "comment_author": "Engineero", "commentT": "2020-12-25T03:56:48Z", "comment_text": "\n \t\tHere is a <denchmark-link:https://colab.research.google.com/drive/1nqzU22tZ0RVAaDm6drWPkfGV8cc7A_3x?usp=sharing>colab</denchmark-link>\n  verifying the fix with . Closing the issue; please feel free to reopen if you encounter additional issues.\n \t\t"}, "comments_10": {"comment_id": 11, "comment_author": "Engineero", "commentT": "2020-12-25T03:56:50Z", "comment_text": "\n \t\tAre you satisfied with the resolution of your issue?\n <denchmark-link:https://docs.google.com/forms/d/e/1FAIpQLSfaP12TRhd9xSxjXZjcZFNXPGk4kc1-qMdv3gc6bEP90vY1ew/viewform?entry.85265664=Yes&entry.2137816233=https://github.com/tensorflow/tensorflow/issues/44983>Yes</denchmark-link>\n \n <denchmark-link:https://docs.google.com/forms/d/e/1FAIpQLSfaP12TRhd9xSxjXZjcZFNXPGk4kc1-qMdv3gc6bEP90vY1ew/viewform?entry.85265664=No&entry.2137816233=https://github.com/tensorflow/tensorflow/issues/44983>No</denchmark-link>\n \n \t\t"}}}, "commit": {"commit_id": "b6be9714e878a7dd0d1405bd7a83e021ba4b561a", "commit_author": "Hye Soo Yang", "commitT": "2020-12-20 13:15:39-08:00", "changed_files": {"file_0": {"file_change_type": "MODIFY", "file_Nmethod": 1, "file_old_name": "tensorflow\\python\\ops\\image_ops_impl.py", "file_new_name": "tensorflow\\python\\ops\\image_ops_impl.py", "hunks": {"hunk_0": {"Ismethod": 1, "added_lines": "1840,1849,1855,1860", "deleted_lines": "1840,1849,1850,1851,1852,1853,1859", "method_info": {"method_name": "per_image_standardization", "method_params": "image", "method_startline": "1823", "method_endline": "1860"}}}}, "file_1": {"file_change_type": "MODIFY", "file_Nmethod": 3, "file_old_name": "tensorflow\\python\\ops\\image_ops_test.py", "file_new_name": "tensorflow\\python\\ops\\image_ops_test.py", "hunks": {"hunk_0": {"Ismethod": 1, "added_lines": "1660,1661,1662,1663,1664,1665,1666,1668", "deleted_lines": "1659,1661,1665", "method_info": {"method_name": "testBasic", "method_params": "self", "method_startline": "1659", "method_endline": "1668"}}, "hunk_1": {"Ismethod": 1, "added_lines": "1666,1668,1672", "deleted_lines": null, "method_info": {"method_name": "testBasic", "method_params": "self,data_type", "method_startline": "1666", "method_endline": "1675"}}, "hunk_2": {"Ismethod": 1, "added_lines": null, "deleted_lines": "1688,1689,1690,1691,1692,1693,1694,1695,1696,1697", "method_info": {"method_name": "testPreservesDtype", "method_params": "self", "method_startline": "1688", "method_endline": "1697"}}}}}}}