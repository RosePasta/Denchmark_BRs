{"BR": {"BR_id": "19499", "BR_author": "LionelCons", "BRopenT": "2018-05-23T13:47:21Z", "BRcloseT": "2018-05-30T21:59:33Z", "BR_text": {"BRsummary": "tf.data.Dataset iterators are not cleaned when the loop ends with a break", "BRdescription": "\n <denchmark-h:h3>System information</denchmark-h>\n \n \n Have I written custom code (as opposed to using a stock example script provided in TensorFlow):yes\n OS Platform and Distribution (e.g., Linux Ubuntu 16.04):CentOS7\n TensorFlow installed from (source or binary):binary\n TensorFlow version (use command below):1.8.0\n Python version: 2.7.5\n Bazel version (if compiling from source):\n GCC/Compiler version (if compiling from source):\n CUDA/cuDNN version:\n GPU model and memory:\n Exact command to reproduce:\n \n <denchmark-h:h3>Describe the problem</denchmark-h>\n \n tf.data.Dataset iterators are not cleaned when the loop ends with a break.\n The code below opens one file per epoch. This eventually hits a system limit (maximum number of open files).\n Replacing the break by a continue works better since the files are closed. However, this is inefficient if we only need to iterate over a small fraction of the data\n <denchmark-h:h3>Source code / logs</denchmark-h>\n \n <denchmark-code>dataset = tf.data.TextLineDataset(fp)\n ...\n for epoch in xrange(epochs):\n     ...\n     batches = 0\n     for (x, y) in dataset:\n         batches += 1\n         if batches > MAX_BATCHES:\n             break\n         ...\n </denchmark-code>\n \n \t"}, "comments": {"comments_0": {"comment_id": 1, "comment_author": "LionelCons", "commentT": "2018-05-23T19:57:22Z", "comment_text": "\n \t\t<denchmark-link:https://github.com/allenlavoie>@allenlavoie</denchmark-link>\n  It looks like you've done something related to Eager resource garbage collection in <denchmark-link:https://github.com/tensorflow/tensorflow/commit/309e340619ab922f1ecb51b8f142283e09bda07d>309e340</denchmark-link>\n , and this is still used in the current :\n \n \n \n tensorflow/tensorflow/python/data/ops/iterator_ops.py\n \n \n         Lines 480 to 482\n       in\n       2c9d129\n \n \n \n \n \n \n  # Delete the resource when this object is deleted \n \n \n \n  self._resource_deleter = resource_variable_ops.EagerResourceDeleter( \n \n \n \n  handle=self._resource, handle_device=\"/device:CPU:0\") \n \n \n \n \n \n Can you please take a look and see if there's a reference leak here?\n \t\t"}, "comments_1": {"comment_id": 2, "comment_author": "LionelCons", "commentT": "2018-05-24T00:13:30Z", "comment_text": "\n \t\tThere is a reference leak, but I don't think it's in Python. DestroyResourceOp gets run and Unrefs the resource, but it looks like IteratorHandleOp is <denchmark-link:https://github.com/tensorflow/tensorflow/blob/f8b74d642420dcf2f5cab763b41884a05777ea45/tensorflow/core/kernels/data/iterator_ops.cc#L510>keeping a reference to the resource in its OpKernel</denchmark-link>\n . AFAIK kernels are never deleted when executing eagerly, they just sit around in the kernel cache.\n I've verified that removing the reference from IteratorHandleOp fixes the \"files not closed\" issue (they get closed when DestroyResourceOp runs). I can think of horrible hacks to get this to happen only when executing eagerly, but maybe we should discuss tomorrow.\n \t\t"}, "comments_2": {"comment_id": 3, "comment_author": "LionelCons", "commentT": "2018-05-24T14:53:51Z", "comment_text": "\n \t\tUgh, yes, whatever we do to that kernel implementation, the current version will still leak the  object and related guff for each iterator. As a strawman, we could solve it with (i) a new version of  that creates the handle doesn't retain a resource, and (ii) some API for creating-and-running-but-not-caching a kernel in eager mode. (CCing <denchmark-link:https://github.com/asimshankar>@asimshankar</denchmark-link>\n  since kernel lifetimes in eager is something we've talked about in the past.)\n <denchmark-link:https://github.com/LionelCons>@LionelCons</denchmark-link>\n  In the meantime, here's a workaround that should alleviate the file handle leak:\n dataset = tf.data.TextLineDataset(fp)\n # ...\n for epoch in xrange(epochs):\n   # ...\n   for (x, y) in dataset.take(MAX_BATCHES):\n     # ...\n \t\t"}}}, "commit": {"commit_id": "70674b950ab48f913ed1c99e48c4162287595d46", "commit_author": "Allen Lavoie", "commitT": "2018-05-29 10:36:51-07:00", "changed_files": {"file_0": {"file_change_type": "ADD", "file_Nmethod": 0, "file_old_name": "None", "file_new_name": "tensorflow\\core\\api_def\\base_api\\api_def_AnonymousIterator.pbtxt"}, "file_1": {"file_change_type": "ADD", "file_Nmethod": 0, "file_old_name": "None", "file_new_name": "tensorflow\\core\\api_def\\python_api\\api_def_AnonymousIterator.pbtxt"}, "file_2": {"file_change_type": "MODIFY", "file_Nmethod": 2, "file_old_name": "tensorflow\\core\\kernels\\data\\iterator_ops.cc", "file_new_name": "tensorflow\\core\\kernels\\data\\iterator_ops.cc", "hunks": {"hunk_0": {"Ismethod": 1, "added_lines": "592,593,594,595,596,597,598,599,600,601,602,603,604,605,606,607,608,609,610,611,612,613,614,615,616,617,618,619,620,621,622,623,624,625,626,627,628,629", "deleted_lines": null, "method_info": {"method_name": "tensorflow::AnonymousIteratorHandleOp::Compute", "method_params": "context", "method_startline": "592", "method_endline": "629"}}, "hunk_1": {"Ismethod": 1, "added_lines": "586,587,588,589,590", "deleted_lines": null, "method_info": {"method_name": "tensorflow::AnonymousIteratorHandleOp::AnonymousIteratorHandleOp", "method_params": "context", "method_startline": "586", "method_endline": "590"}}}}, "file_3": {"file_change_type": "MODIFY", "file_Nmethod": 0, "file_old_name": "tensorflow\\core\\ops\\dataset_ops.cc", "file_new_name": "tensorflow\\core\\ops\\dataset_ops.cc", "hunks": {"hunk_0": {"Ismethod": 0, "added_lines": "567,568,569,570,571,572", "deleted_lines": null}}}, "file_4": {"file_change_type": "MODIFY", "file_Nmethod": 1, "file_old_name": "tensorflow\\python\\data\\kernel_tests\\reader_dataset_ops_test.py", "file_new_name": "tensorflow\\python\\data\\kernel_tests\\reader_dataset_ops_test.py", "hunks": {"hunk_0": {"Ismethod": 1, "added_lines": "173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199", "deleted_lines": null, "method_info": {"method_name": "testIteratorResourceCleanup", "method_params": "self", "method_startline": "173", "method_endline": "199"}}}}, "file_5": {"file_change_type": "MODIFY", "file_Nmethod": 1, "file_old_name": "tensorflow\\python\\data\\ops\\iterator_ops.py", "file_new_name": "tensorflow\\python\\data\\ops\\iterator_ops.py", "hunks": {"hunk_0": {"Ismethod": 1, "added_lines": "474", "deleted_lines": "474,475,476", "method_info": {"method_name": "__init__", "method_params": "self,dataset", "method_startline": "439", "method_endline": "481"}}}}}}}