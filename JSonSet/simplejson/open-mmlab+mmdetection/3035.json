{"BR": {"BR_id": "3035", "BR_author": "dsuess", "BRopenT": "2020-06-16T06:24:52Z", "BRcloseT": "2020-08-22T09:51:39Z", "BR_text": {"BRsummary": "scale_factor array breaks FCNMaskHead", "BRdescription": "\n Thanks for your error report and we appreciate it a lot.\n \n FCNMaskHead raises an error if the model is run with  and  being an array (instead of just a scalar). The error is raised in <denchmark-link:https://github.com/open-mmlab/mmdetection/blob/master/mmdet/models/roi_heads/mask_heads/fcn_mask_head.py#L200>this line</denchmark-link>\n  and reads:\n <denchmark-code>TypeError: only size-1 arrays can be converted to Python scalars\n </denchmark-code>\n \n Reproduction\n Jupyter notebook running inference on custom dataset.\n Error traceback\n <denchmark-code>../../.cache/pypoetry/virtualenvs/mmpond-6xAyU5_O-py3.7/lib/python3.7/site-packages/torch/nn/modules/module.py:550: in __call__\n     result = self.forward(*input, **kwargs)\n ../../.cache/pypoetry/virtualenvs/mmpond-6xAyU5_O-py3.7/lib/python3.7/site-packages/torch/nn/parallel/data_parallel.py:153: in forward\n     return self.module(*inputs[0], **kwargs[0])\n ../../.cache/pypoetry/virtualenvs/mmpond-6xAyU5_O-py3.7/lib/python3.7/site-packages/torch/nn/modules/module.py:550: in __call__\n     result = self.forward(*input, **kwargs)\n ../../.cache/pypoetry/virtualenvs/mmpond-6xAyU5_O-py3.7/lib/python3.7/site-packages/mmdet/core/fp16/decorators.py:51: in new_func\n     return old_func(*args, **kwargs)\n ../../.cache/pypoetry/virtualenvs/mmpond-6xAyU5_O-py3.7/lib/python3.7/site-packages/mmdet/models/detectors/base.py:150: in forward\n     return self.forward_test(img, img_metas, **kwargs)\n ../../.cache/pypoetry/virtualenvs/mmpond-6xAyU5_O-py3.7/lib/python3.7/site-packages/mmdet/models/detectors/base.py:131: in forward_test\n     return self.simple_test(imgs[0], img_metas[0], **kwargs)\n ../../.cache/pypoetry/virtualenvs/mmpond-6xAyU5_O-py3.7/lib/python3.7/site-packages/mmdet/models/detectors/two_stage.py:192: in simple_test\n     x, proposal_list, img_metas, rescale=rescale)\n ../../.cache/pypoetry/virtualenvs/mmpond-6xAyU5_O-py3.7/lib/python3.7/site-packages/mmdet/models/roi_heads/standard_roi_head.py:253: in simple_test\n     x, img_metas, det_bboxes, det_labels, rescale=rescale)\n ../../.cache/pypoetry/virtualenvs/mmpond-6xAyU5_O-py3.7/lib/python3.7/site-packages/mmdet/models/roi_heads/test_mixins.py:172: in simple_test_mask\n     ori_shape, scale_factor, rescale)\n _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n \n self = FCNMaskHead(\n   (loss_mask): CrossEntropyLoss()\n   (convs): ModuleList(\n     (0): ConvModule(\n       (conv): Conv2d(256, 2...2, 2), stride=(2, 2))\n   (conv_logits): Conv2d(256, 1, kernel_size=(1, 1), stride=(1, 1))\n   (relu): ReLU(inplace=True)\n )\n mask_pred = tensor([[[[0.3319, 0.4184, 0.3217,  ..., 0.4381, 0.4519, 0.6086],\n           [0.8833, 0.7837, 0.9758,  ..., 0.8660, 0.9..., 0.8995, 0.6574, 0.7129],\n           [0.5393, 0.4447, 0.4772,  ..., 0.8042, 0.5884, 0.8338]]]],\n        device='cuda:0')\n det_bboxes = tensor([[6.6717e+01, 0.0000e+00, 4.9932e+02, 5.0000e+02, 1.3252e-01],\n         [2.8945e+02, 0.0000e+00, 4.9981e+02, 2.5...5.0000e+02, 5.8171e-02],\n         [7.6896e+01, 3.5935e+02, 4.3908e+02, 5.0000e+02, 5.5708e-02]],\n        device='cuda:0')\n det_labels = tensor([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n         0, 0], device='cuda:0')\n rcnn_test_cfg = {'score_thr': 0.05, 'nms': {'type': 'nms', 'iou_thr': 0.5}, 'max_per_img': 100, 'mask_thr_binary': 0.5}\n ori_shape = (416, 416, 3), scale_factor = 1.0, rescale = False\n \n     def get_seg_masks(self, mask_pred, det_bboxes, det_labels, rcnn_test_cfg,\n                       ori_shape, scale_factor, rescale):\n         \"\"\"Get segmentation masks from mask_pred and bboxes.\n \n         Args:\n             mask_pred (Tensor or ndarray): shape (n, #class, h, w).\n                 For single-scale testing, mask_pred is the direct output of\n                 model, whose type is Tensor, while for multi-scale testing,\n                 it will be converted to numpy array outside of this method.\n             det_bboxes (Tensor): shape (n, 4/5)\n             det_labels (Tensor): shape (n, )\n             img_shape (Tensor): shape (3, )\n             rcnn_test_cfg (dict): rcnn testing config\n             ori_shape: original image size\n \n         Returns:\n             list[list]: encoded masks\n         \"\"\"\n         if isinstance(mask_pred, torch.Tensor):\n             mask_pred = mask_pred.sigmoid()\n         else:\n             mask_pred = det_bboxes.new_tensor(mask_pred)\n \n         device = mask_pred.device\n         cls_segms = [[] for _ in range(self.num_classes)\n                      ]  # BG is not included in num_classes\n         bboxes = det_bboxes[:, :4]\n         labels = det_labels\n \n         if rescale:\n             img_h, img_w = ori_shape[:2]\n         else:\n             img_h = np.round(ori_shape[0] * scale_factor).astype(np.int32)\n             img_w = np.round(ori_shape[1] * scale_factor).astype(np.int32)\n             scale_factor = 1.0\n \n         if not isinstance(scale_factor, (float, torch.Tensor)):\n             scale_factor = bboxes.new_tensor(scale_factor)\n         bboxes = bboxes / scale_factor\n \n         N = len(mask_pred)\n         # The actual implementation split the input into chunks,\n         # and paste them chunk by chunk.\n         if device.type == 'cpu':\n             # CPU is most efficient when they are pasted one by one with\n             # skip_empty=True, so that it performs minimal number of\n             # operations.\n             num_chunks = N\n         else:\n             # GPU benefits from parallelism for larger chunks,\n             # but may have memory issue\n             num_chunks = int(\n >               np.ceil(N * img_h * img_w * BYTES_PER_FLOAT / GPU_MEM_LIMIT))\n E           TypeError: only size-1 arrays can be converted to Python scalars\n \n ../../.cache/pypoetry/virtualenvs/mmpond-6xAyU5_O-py3.7/lib/python3.7/site-packages/mmdet/models/roi_heads/mask_heads/fcn_mask_head.py:201: TypeError\n </denchmark-code>\n \n Bug fix\n The calculation of  and  for  (see <denchmark-link:https://github.com/open-mmlab/mmdetection/blob/master/mmdet/models/roi_heads/mask_heads/fcn_mask_head.py#L181>this</denchmark-link>\n ) hasn't been ported to work with scale_factor being a  dim array. I'll try to submit a PR ASAP\n \t"}, "comments": {"comments_0": {"comment_id": 1, "comment_author": "dsuess", "commentT": "2020-06-18T12:39:49Z", "comment_text": "\n \t\tHi <denchmark-link:https://github.com/dsuess>@dsuess</denchmark-link>\n  ,\n Thanks for your bug report, this bug is caused by this <denchmark-link:https://github.com/open-mmlab/mmdetection/blob/master/mmdet/datasets/pipelines/transforms.py#L138>line</denchmark-link>\n . Your contributions are welcomed.\n \t\t"}}}, "commit": {"commit_id": "94008233957a49c4a1f708da2122d5059957f6cb", "commit_author": "Wenwei Zhang", "commitT": "2020-08-22 17:51:39+08:00", "changed_files": {"file_0": {"file_change_type": "MODIFY", "file_Nmethod": 0, "file_old_name": "mmdet\\models\\roi_heads\\mask_heads\\fcn_mask_head.py", "file_new_name": "mmdet\\models\\roi_heads\\mask_heads\\fcn_mask_head.py", "hunks": {"hunk_0": {"Ismethod": 0, "added_lines": "183,184,185,186,187,188,189,190,191", "deleted_lines": "183,184"}}}}}}