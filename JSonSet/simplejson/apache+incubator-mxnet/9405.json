{"BR": {"BR_id": "9405", "BR_author": "opringle", "BRopenT": "2018-01-12T20:22:57Z", "BRcloseT": "2018-03-20T20:02:35Z", "BR_text": {"BRsummary": "BucketingModule causes uncaught exception if symbol name not specified", "BRdescription": "\n <denchmark-h:h2>Description</denchmark-h>\n \n When using the BucketingModule together with mx.rnn.BuckSentenceIter, I hit an uncaught exception if I do not specify the symbol name in either mx.sym.Embedding or mx.sym.FullyConnected symbols, despite each symbol in the network having a unique name.\n <denchmark-h:h2>Environment info (Required)</denchmark-h>\n \n <denchmark-code>----------Python Info----------\n Version      : 3.6.3\n Compiler     : GCC 4.2.1 Compatible Apple LLVM 9.0.0 (clang-900.0.37)\n Build        : ('default', 'Oct  4 2017 06:09:15')\n Arch         : ('64bit', '')\n ------------Pip Info-----------\n Version      : 9.0.1\n Directory    : /Users/opringle/Envs/finn-dl/lib/python3.6/site-packages/pip\n ----------MXNet Info-----------\n Version      : 1.0.0\n Directory    : /Users/opringle/Envs/finn-dl/lib/python3.6/site-packages/mxnet\n Commit Hash   : 2b67436802b750e15b9fbfdf275958c1000be6a8\n ----------System Info----------\n Platform     : Darwin-17.3.0-x86_64-i386-64bit\n system       : Darwin\n node         : MacBook-Pro-2.local\n release      : 17.3.0\n version      : Darwin Kernel Version 17.3.0: Thu Nov  9 18:09:22 PST 2017; root:xnu-4570.31.3~1/RELEASE_X86_64\n ----------Hardware Info----------\n machine      : x86_64\n processor    : i386\n b'machdep.cpu.brand_string: Intel(R) Core(TM) i5-7360U CPU @ 2.30GHz'\n b'machdep.cpu.features: FPU VME DE PSE TSC MSR PAE MCE CX8 APIC SEP MTRR PGE MCA CMOV PAT PSE36 CLFSH DS ACPI MMX FXSR SSE SSE2 SS HTT TM PBE SSE3 PCLMULQDQ DTES64 MON DSCPL VMX SMX EST TM2 SSSE3 FMA CX16 TPR PDCM SSE4.1 SSE4.2 x2APIC MOVBE POPCNT AES PCID XSAVE OSXSAVE SEGLIM64 TSCTMR AVX1.0 RDRAND F16C'\n b'machdep.cpu.leaf7_features: SMEP ERMS RDWRFSGS TSC_THREAD_OFFSET BMI1 HLE AVX2 BMI2 INVPCID RTM SMAP RDSEED ADX IPT SGX FPU_CSDS MPX CLFSOPT'\n b'machdep.cpu.extfeatures: SYSCALL XD 1GBPAGE EM64T LAHF LZCNT PREFETCHW RDTSCP TSCI'\n ----------Network Test----------\n Setting timeout: 10\n Timing for MXNet: https://github.com/apache/incubator-mxnet, DNS: 0.0077 sec, LOAD: 0.4726 sec.\n Timing for Gluon Tutorial(en): http://gluon.mxnet.io, DNS: 0.0263 sec, LOAD: 0.0633 sec.\n Timing for Gluon Tutorial(cn): https://zh.gluon.ai, DNS: 0.0897 sec, LOAD: 0.0599 sec.\n Timing for FashionMNIST: https://apache-mxnet.s3-accelerate.dualstack.amazonaws.com/gluon/dataset/fashion-mnist/train-labels-idx1-ubyte.gz, DNS: 0.0259 sec, LOAD: 0.1184 sec.\n Timing for PYPI: https://pypi.python.org/pypi/pip, DNS: 0.0139 sec, LOAD: 0.2371 sec.\n Timing for Conda: https://repo.continuum.io/pkgs/free/, DNS: 0.0305 sec, LOAD: 0.2018 sec.\n </denchmark-code>\n \n I'm using python\n <denchmark-h:h2>Error Message:</denchmark-h>\n \n <denchmark-code>libc++abi.dylib: terminating with uncaught exception of type std::out_of_range: unordered_map::at: key not found\n Abort trap: 6\n </denchmark-code>\n \n <denchmark-h:h2>Minimum reproducible example</denchmark-h>\n \n import mxnet as mx\n import random\n \n #synthetically create 1000 encoded sentences\n encoded_sentences = []\n for i in list(range(1000)):\n     sentence_length = random.randint(1,20)\n     sentence = random.sample(range(20), sentence_length)\n     encoded_sentences.append(sentence)\n \n #define hyperparameters/info\n vocab = list(set(index for list in encoded_sentences for index in list))\n batch_size = 18\n num_embed = 10\n num_hidden = 3\n buckets = [5,10,15,20]\n epochs = 15\n \n #use mxnet bucketing iterator, label is next value in sentence\n train_iter = mx.rnn.BucketSentenceIter(sentences = encoded_sentences,\n                                        batch_size = batch_size,\n                                        buckets = buckets,\n                                        data_name = 'data',\n                                        label_name = 'softmax_label')\n \n #define recurrent cell outside of network TODO: why outside?\n r_cell = mx.rnn.LSTMCell(num_hidden=num_hidden)\n \n #define a network symbol based on sentence length\n def sym_gen1(seq_len):\n \n     print(\"-\" * 50)\n \n     #define input shape so we can infer layer shapes as we go\n     data_shape = (batch_size, seq_len)\n     label_shape = (batch_size, seq_len)\n \n     data = mx.sym.Variable('data')\n     print(\"\\ndata shape: \", data.infer_shape(data=data_shape)[1][0], \"\\n\")\n \n     label = mx.sym.Variable('softmax_label')\n     print(\"\\nlabel shape: \", label.infer_shape(softmax_label=label_shape)[1][0], \"\\n\")\n \n     embed = mx.sym.Embedding(data=data, input_dim=len(vocab), output_dim=num_embed,name='embed')\n     print(\"\\nembed layer shape: \", embed.infer_shape(data=data_shape)[1][0], \"\\n\")\n \n     output, shapes = r_cell.unroll(seq_len, inputs=embed, merge_outputs=True)\n     print(\"\\nconcatenated recurrent layer shape: \", output.infer_shape(data=data_shape)[1][0], \"after \", seq_len, \" unrolls\\n\")\n \n     reshape = mx.sym.Reshape(output, shape=(-1, num_hidden))\n     print(\"\\nafter reshaping: \", reshape.infer_shape(data=data_shape)[1][0], \"\\n\")\n \n     fc = mx.sym.FullyConnected(data=reshape, num_hidden=len(vocab), name='pred')\n     print(\"\\nfully connected layer shape: \", fc.infer_shape(data=data_shape)[1][0], \"\\n\")\n \n     label = mx.sym.Reshape(label, shape=(-1,))\n     print(\"\\nlabel shape after reshaping: \", label.infer_shape(softmax_label=label_shape)[1][0], \"\\n\")\n \n     pred = mx.sym.SoftmaxOutput(data=fc, label=label, name='softmax')\n     print(\"\\nsoftmax shape: \", pred.infer_shape(data=data_shape, softmax_label = label_shape)[1][0], \"\\n\")\n \n     return pred, ('data',), ('softmax_label',)\n \n #define identical symbol but remove name arguement from fully connected layer\n def sym_gen2(seq_len):\n \n     print(\"-\" * 50)\n \n     #define input shape so we can infer layer shapes as we go\n     data_shape = (batch_size, seq_len)\n     label_shape = (batch_size, seq_len)\n \n     data = mx.sym.Variable('data')\n     print(\"\\ndata shape: \", data.infer_shape(data=data_shape)[1][0], \"\\n\")\n \n     label = mx.sym.Variable('softmax_label')\n     print(\"\\nlabel shape: \", label.infer_shape(softmax_label=label_shape)[1][0], \"\\n\")\n \n     embed = mx.sym.Embedding(data=data, input_dim=len(vocab), output_dim=num_embed,name='embed')\n     print(\"\\nembed layer shape: \", embed.infer_shape(data=data_shape)[1][0], \"\\n\")\n \n     output, shapes = r_cell.unroll(seq_len, inputs=embed, merge_outputs=True)\n     print(\"\\nconcatenated recurrent layer shape: \", output.infer_shape(data=data_shape)[1][0], \"after \", seq_len, \" unrolls\\n\")\n \n     reshape = mx.sym.Reshape(output, shape=(-1, num_hidden))\n     print(\"\\nafter reshaping: \", reshape.infer_shape(data=data_shape)[1][0], \"\\n\")\n \n     fc = mx.sym.FullyConnected(data=reshape, num_hidden=len(vocab))\n     print(\"\\nfully connected layer shape: \", fc.infer_shape(data=data_shape)[1][0], \"\\n\")\n \n     label = mx.sym.Reshape(label, shape=(-1,))\n     print(\"\\nlabel shape after reshaping: \", label.infer_shape(softmax_label=label_shape)[1][0], \"\\n\")\n \n     pred = mx.sym.SoftmaxOutput(data=fc, label=label, name='softmax')\n     print(\"\\nsoftmax shape: \", pred.infer_shape(data=data_shape, softmax_label = label_shape)[1][0], \"\\n\")\n \n     return pred, ('data',), ('softmax_label',)\n \n \n #create a trainable bucketing module on cpu\n model = mx.mod.BucketingModule(sym_gen=sym_gen1, default_bucket_key=train_iter.default_bucket_key, context=mx.cpu())\n model_not_working = mx.mod.BucketingModule(sym_gen=sym_gen2, default_bucket_key=train_iter.default_bucket_key, context=mx.cpu())\n \n #fit the first module\n print(\"\\n\\n\\nFITTING FIRST MODULE...\\n\\n\\n\")\n metric = mx.metric.create('loss')\n model.bind(data_shapes=train_iter.provide_data,\n            label_shapes=train_iter.provide_label)\n model.init_params()\n model.init_optimizer(optimizer='Adam')\n for epoch in range(epochs):\n     train_iter.reset()\n     metric.reset()\n     for batch in train_iter:\n         model.forward(batch, is_train=True)             # compute predictions\n         model.backward()                                # compute gradients\n         model.update()                                  # update parameters\n         model.update_metric(metric, batch.label)        # update metric\n     print('\\n', 'Epoch %d, Training %s' % (epoch, metric.get()))\n \n #fit the second module\n print(\"\\n\\n\\nFITTING SECOND MODULE...\\n\\n\\n\")\n metric = mx.metric.create('loss')\n model_not_working.bind(data_shapes=train_iter.provide_data,\n            label_shapes=train_iter.provide_label)\n model_not_working.init_params()\n model_not_working.init_optimizer(optimizer='Adam')\n for epoch in range(epochs):\n     train_iter.reset()\n     metric.reset()\n     for batch in train_iter:\n         model_not_working.forward(batch, is_train=True)             # compute predictions\n         model_not_working.backward()                                # compute gradients\n         model_not_working.update()                                  # update parameters\n         model_not_working.update_metric(metric, batch.label)        # update metric\n     print('\\n', 'Epoch %d, Training %s' % (epoch, metric.get()))\n <denchmark-h:h2>Steps to reproduce</denchmark-h>\n \n \n Run the script\n You will see the module fit correctly with gen_sym1() but fail with gen_sym2().  The only difference between the two is the name arguement has been removed from fc = mx.sym.FullyConnected(data=reshape, num_hidden=len(vocab), name='pred').\n \n <denchmark-h:h2>What have you tried to solve it?</denchmark-h>\n \n \n I have solved the problem by including an input to the name parameter when creating the symbol.\n \n \t"}, "comments": {"comments_0": {"comment_id": 1, "comment_author": "opringle", "commentT": "2018-02-14T10:40:19Z", "comment_text": "\n \t\t+1 for this. This is actually a very annoying bug.\n \t\t"}, "comments_1": {"comment_id": 2, "comment_author": "opringle", "commentT": "2018-02-27T20:28:38Z", "comment_text": "\n \t\t<denchmark-link:https://github.com/sandeep-krishnamurthy>@sandeep-krishnamurthy</denchmark-link>\n   : Please tag: Bug\n \t\t"}, "comments_2": {"comment_id": 3, "comment_author": "opringle", "commentT": "2018-03-03T21:33:53Z", "comment_text": "\n \t\tFacing the same problem. However, in Gluon, it cannot define a name\n \t\t"}}}, "commit": {"commit_id": "dd85860be914a1e7aa10a9ebebc18546fd262425", "commit_author": "Anirudh Subramanian", "commitT": "2018-03-20 13:02:34-07:00", "changed_files": {"file_0": {"file_change_type": "MODIFY", "file_Nmethod": 4, "file_old_name": "python\\mxnet\\module\\bucketing_module.py", "file_new_name": "python\\mxnet\\module\\bucketing_module.py", "hunks": {"hunk_0": {"Ismethod": 1, "added_lines": "106,107,108", "deleted_lines": null, "method_info": {"method_name": "_call_sym_gen", "method_params": "self,args,kwargs", "method_startline": "106", "method_endline": "108"}}, "hunk_1": {"Ismethod": 1, "added_lines": "125", "deleted_lines": "120", "method_info": {"method_name": "output_names", "method_params": "self", "method_startline": "120", "method_endline": "126"}}, "hunk_2": {"Ismethod": 1, "added_lines": "366", "deleted_lines": "361", "method_info": {"method_name": "switch_bucket", "method_params": "self,bucket_key,data_shapes,label_shapes", "method_startline": "352", "method_endline": "382"}}, "hunk_3": {"Ismethod": 1, "added_lines": "116", "deleted_lines": "111", "method_info": {"method_name": "data_names", "method_params": "self", "method_startline": "111", "method_endline": "117"}}}}, "file_1": {"file_change_type": "MODIFY", "file_Nmethod": 2, "file_old_name": "tests\\python\\unittest\\test_module.py", "file_new_name": "tests\\python\\unittest\\test_module.py", "hunks": {"hunk_0": {"Ismethod": 1, "added_lines": "277", "deleted_lines": "277", "method_info": {"method_name": "test_module_switch_bucket.sym_gen", "method_params": "seq_len", "method_startline": "273", "method_endline": "289"}}, "hunk_1": {"Ismethod": 1, "added_lines": "277,302,303,304,305", "deleted_lines": "277", "method_info": {"method_name": "test_module_switch_bucket", "method_params": "", "method_startline": "261", "method_endline": "317"}}}}}}}