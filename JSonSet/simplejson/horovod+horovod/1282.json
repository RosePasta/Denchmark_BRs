{"BR": {"BR_id": "1282", "BR_author": "romerojosh", "BRopenT": "2019-08-07T19:23:15Z", "BRcloseT": "2019-08-10T18:09:38Z", "BR_text": {"BRsummary": "Autotuner causes unstable training behavior at startup due to possible race condition", "BRdescription": "\n Environment:\n \n Framework: Tensorflow\n Framework version: 1.14.0\n Horovod version: 0.16.4\n MPI version: OpenMPI 3.1.4\n CUDA version: 10.1\n NCCL version: 2.4.8\n Python version: 3.6.8\n OS and version: Ubuntu 18.04.2\n GCC version: 7.4.0\n \n Bug report:\n Recently, one of our developers has been running cases with TensorFlow + AMP and noticed some very unstable training behavior at startup while the autotuner is active, indicating some type of data corruption occurring with the gradients. The instability does not occur with the autotuner disabled.\n We ran a lot of experiments and found that the issue appears to be related to modifications to HOROVOD_FUSION_THRESHOLD, as the training with autotuning stabilizes if we set that parameter to a fixed value.\n I dug around in the code and I think it is possible that there may be a race condition which occurs when the fusion buffer size is updated by the autotuner. Since NCCL/CUDA operations are completed asynchronously w.r.t to the main Horovod thread, there seems to be a possibility that a subsequent op can trigger a reallocation of the fusion buffer before the previous NCCL/CUDA operation completes.\n To test this hypothesis, I changed the  of the finalizer thread to  to force the main thread to wait until NCCL/CUDA operations complete before continuing (see  <denchmark-link:https://github.com/romerojosh/horovod/commit/5983aa6115bdc2cc039c249546270d8ee7fd0160>romerojosh/horovod@5983aa6</denchmark-link>\n ) With this change, the training runs stably with the autotuner enabled and a variable fusion threshold. I don't think this is a proper fix as it introduces unnecessary serialization, however it does suggest that some type of sync is necessary when modifying the fusion threshold during training.\n cc <denchmark-link:https://github.com/DEKHTIARJonathan>@DEKHTIARJonathan</denchmark-link>\n \n \t"}, "comments": {"comments_0": {"comment_id": 1, "comment_author": "romerojosh", "commentT": "2019-08-08T03:24:55Z", "comment_text": "\n \t\tGreat catch!  <denchmark-link:https://github.com/tgaddair>@tgaddair</denchmark-link>\n , could you take a look?\n \t\t"}, "comments_1": {"comment_id": 2, "comment_author": "romerojosh", "commentT": "2019-08-08T10:04:07Z", "comment_text": "\n \t\t<denchmark-link:https://github.com/tgaddair>@tgaddair</denchmark-link>\n  : In order to help you. I can run a stability test in 3-4hours. The only thing I need is a git repo and git commit hash and I'll be able to tell you if any change solved the issue ;)\n \t\t"}, "comments_2": {"comment_id": 3, "comment_author": "romerojosh", "commentT": "2019-08-08T15:14:59Z", "comment_text": "\n \t\tThanks, <denchmark-link:https://github.com/DEKHTIARJonathan>@DEKHTIARJonathan</denchmark-link>\n , I'll take a look at this hopefully some time today or tomorrow at the latest.\n \t\t"}, "comments_3": {"comment_id": 4, "comment_author": "romerojosh", "commentT": "2019-08-10T03:12:56Z", "comment_text": "\n \t\tHey <denchmark-link:https://github.com/DEKHTIARJonathan>@DEKHTIARJonathan</denchmark-link>\n , could you take a look at <denchmark-link:https://github.com/horovod/horovod/pull/1288>#1288</denchmark-link>\n ?  My current hypothesis is that because the finalizer thread didn't have a handle to the fusion buffer pointer, that resetting the shared pointer in the fusion buffer manager led to the memory being reclaimed and used by something else.  With this change, we keep an extra reference count to that pointer for the duration of the finalization.\n \t\t"}, "comments_4": {"comment_id": 5, "comment_author": "romerojosh", "commentT": "2019-08-10T10:15:51Z", "comment_text": "\n \t\tTesting your fix. I'm updating the PR\n \t\t"}}}, "commit": {"commit_id": "00d839fedae17ce099670fe040e57b10065721fc", "commit_author": "Travis Addair", "commitT": "2019-08-10 11:09:38-07:00", "changed_files": {"file_0": {"file_change_type": "MODIFY", "file_Nmethod": 1, "file_old_name": "horovod\\common\\fusion_buffer_manager.cc", "file_new_name": "horovod\\common\\fusion_buffer_manager.cc", "hunks": {"hunk_0": {"Ismethod": 1, "added_lines": "48", "deleted_lines": "48", "method_info": {"method_name": "horovod::common::FusionBufferManager::GetBuffer", "method_params": "device,framework,stream_id", "method_startline": "48", "method_endline": "50"}}}}, "file_1": {"file_change_type": "MODIFY", "file_Nmethod": 0, "file_old_name": "horovod\\common\\fusion_buffer_manager.h", "file_new_name": "horovod\\common\\fusion_buffer_manager.h", "hunks": {"hunk_0": {"Ismethod": 0, "added_lines": "47", "deleted_lines": "47"}}}, "file_2": {"file_change_type": "MODIFY", "file_Nmethod": 2, "file_old_name": "horovod\\common\\ops\\collective_operations.cc", "file_new_name": "horovod\\common\\ops\\collective_operations.cc", "hunks": {"hunk_0": {"Ismethod": 1, "added_lines": "42", "deleted_lines": "42", "method_info": {"method_name": "horovod::common::AllreduceOp::MemcpyInFusionBuffer", "method_params": "entries,fused_input_data,buffer_data,buffer_len", "method_startline": "37", "method_endline": "57"}}, "hunk_1": {"Ismethod": 1, "added_lines": "164", "deleted_lines": "164", "method_info": {"method_name": "horovod::common::AllgatherOp::MemcpyInFusionBuffer", "method_params": "entries,displcmnts,element_size,buffer_data", "method_startline": "159", "method_endline": "175"}}}}, "file_3": {"file_change_type": "MODIFY", "file_Nmethod": 1, "file_old_name": "horovod\\common\\ops\\cuda_operations.cc", "file_new_name": "horovod\\common\\ops\\cuda_operations.cc", "hunks": {"hunk_0": {"Ismethod": 1, "added_lines": "159,160,161,162,163,165", "deleted_lines": "160", "method_info": {"method_name": "horovod::common::CUDAAllreduce::FinalizeCUDAQueue", "method_params": "entries", "method_startline": "148", "method_endline": "188"}}}}}}}