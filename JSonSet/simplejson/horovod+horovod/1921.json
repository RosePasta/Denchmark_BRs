{"BR": {"BR_id": "1921", "BR_author": "sparticlesteve", "BRopenT": "2020-04-29T05:22:41Z", "BRcloseT": "2020-05-04T14:53:05Z", "BR_text": {"BRsummary": "Keras LR callbacks have unintended behavior when resuming from checkpoint", "BRdescription": "\n Environment:\n \n Framework: tf.keras\n Framework version: TF 1.15.0\n Horovod version: 0.19.0\n MPI version: cray-mpich/7.7.10\n CUDA version: n/a\n NCCL version: n/a\n Python version: 3.7.4\n OS and version: Cray linux based on SLES 15\n GCC version: 7.3.0\n \n Checklist:\n \n Did you search issues to find if somebody asked this question before? yes\n If your question is about hang, did you read this doc? n/a\n If your question is about docker, did you read this doc? n/a\n Did you check if you question is answered in the troubleshooting guide? yes\n \n Bug report:\n Please describe erroneous behavior you're observing and steps to reproduce it.\n There is a problem with the Keras learning rate callbacks (inheriting from ) as implemented when using checkpoints and resuming training. This class pulls the  from the model optimizer in :\n \n \n All LR (and momentum) modifications are done with respect to that initial learning rate and the current epoch (or batch). However, if one is writing a checkpoint, the current modified learning rate and momentum are written to the checkpoint file. Then, upon loading that checkpoint and resuming training with the LR callback, it pulls the  LR as its new . Unless the user takes care to reset the optimizer's LR (and momentum) after loading from checkpoint and before training, the original schedule applied will not produce the intended schedule. The Keras Imagenet resnet50 example is affected by this, for instance:\n <denchmark-link:https://github.com/horovod/horovod/blob/master/examples/keras_imagenet_resnet50.py>https://github.com/horovod/horovod/blob/master/examples/keras_imagenet_resnet50.py</denchmark-link>\n \n In contrast, the LR scheduler in Keras (and tf.keras) is implemented such that modifications depend on the  learning rate. This slightly different approach is therefore not affected by the checkpoint resume issue. It doesn't have any momentum correction, though.\n <denchmark-link:https://github.com/tensorflow/tensorflow/blob/bab74a15d9ad6bb9066b3e31d601d6a45b1cb221/tensorflow/python/keras/callbacks.py#L1349>https://github.com/tensorflow/tensorflow/blob/bab74a15d9ad6bb9066b3e31d601d6a45b1cb221/tensorflow/python/keras/callbacks.py#L1349</denchmark-link>\n \n I think there are a couple of possible reasonable solutions. One is to change the multiplier logic to match that of the Keras LR scheduler so that the new LR is a result of the multiplier times the current LR. This logic change would likely break folks' code, though. Another possible solution is to allow (or require!) the user to set the initial LR in the callback constructor. This way I can ensure that it is always set to the correct, intended value. Finally, as I alluded to above, the user can reset their optimizer LR (and appropriately scale the momentum) after loading from checkpoint and before training. However, I consider this a workaround rather than a solution.\n I'm hoping I explained it clearly enough that I don't need a MWE, but I can provide one if required.\n \t"}, "comments": {"comments_0": {"comment_id": 1, "comment_author": "sparticlesteve", "commentT": "2020-05-01T22:27:19Z", "comment_text": "\n \t\tHey <denchmark-link:https://github.com/sparticlesteve>@sparticlesteve</denchmark-link>\n , thanks for the detailed report.  I am inclined towards letting the user optionally provide the  in the callback constructor, and only pulling it in  if it hasn't been set.  That way, we don't break the existing behavior, but provide a solution for for this scenario.\n Curious if other contributors have any thoughts on this.\n <denchmark-link:https://github.com/alsrgv>@alsrgv</denchmark-link>\n  <denchmark-link:https://github.com/nvcastet>@nvcastet</denchmark-link>\n  <denchmark-link:https://github.com/romerojosh>@romerojosh</denchmark-link>\n \n \t\t"}, "comments_1": {"comment_id": 2, "comment_author": "sparticlesteve", "commentT": "2020-05-02T00:31:59Z", "comment_text": "\n \t\t+1 for optional initial_lr, wouldn't want to introduce a breaking change.\n \t\t"}, "comments_2": {"comment_id": 3, "comment_author": "sparticlesteve", "commentT": "2020-05-02T01:57:10Z", "comment_text": "\n \t\tShould it really be optional though? It sounds like what <denchmark-link:https://github.com/sparticlesteve>@sparticlesteve</denchmark-link>\n  is describing here is erroneous behavior on restart, which really ought to be fixed. I can't imagine any user would want their LR schedule somehow dependent on if/when they restart.\n \t\t"}, "comments_3": {"comment_id": 4, "comment_author": "sparticlesteve", "commentT": "2020-05-02T02:22:13Z", "comment_text": "\n \t\tBreaking existing scripts it not nice without major version bump, some people may not even be using restarts from checkpoints :-)\n \t\t"}, "comments_4": {"comment_id": 5, "comment_author": "sparticlesteve", "commentT": "2020-05-02T14:49:40Z", "comment_text": "\n \t\tOne option would be to add the initial_lr parameter as optional for now, but with a DeprecationWarning that we will remove the option to set initial_lr implicitly in a future version (e.g., 0.21.0).  Thoughts?\n \t\t"}, "comments_5": {"comment_id": 6, "comment_author": "sparticlesteve", "commentT": "2020-05-04T14:11:06Z", "comment_text": "\n \t\t<denchmark-link:https://github.com/tgaddair>@tgaddair</denchmark-link>\n  yes, seems to be the best solution.\n  in the next TF version seems to go from LR scheduler not taking any learning rate as input (only current epoch) to taking the current epoch and current LR: <denchmark-link:https://www.tensorflow.org/api_docs/python/tf/keras/callbacks/LearningRateScheduler?version=nightly>https://www.tensorflow.org/api_docs/python/tf/keras/callbacks/LearningRateScheduler?version=nightly</denchmark-link>\n \n I am assuming customers can use  in a Horovod script with no problem if they want a scheduler based on current learning rate, correct?\n \t\t"}, "comments_6": {"comment_id": 7, "comment_author": "sparticlesteve", "commentT": "2020-05-04T14:54:02Z", "comment_text": "\n \t\tGood point, <denchmark-link:https://github.com/nvcastet>@nvcastet</denchmark-link>\n .  Yes, users can use the Keras LR scheduler as an alternative.\n \t\t"}, "comments_7": {"comment_id": 8, "comment_author": "sparticlesteve", "commentT": "2020-05-04T15:41:15Z", "comment_text": "\n \t\tYeah, I mentioned the Keras implementations above, and this is my current workaround, but as I noted, one (perhaps minor) difference is that the Keras ones do not do any momentum correction.\n \t\t"}, "comments_8": {"comment_id": 9, "comment_author": "sparticlesteve", "commentT": "2020-05-04T15:44:16Z", "comment_text": "\n \t\tHey <denchmark-link:https://github.com/sparticlesteve>@sparticlesteve</denchmark-link>\n , can you take a look at <denchmark-link:https://github.com/horovod/horovod/pull/1933>#1933</denchmark-link>\n  and verify that it solves the issue for you?\n \t\t"}, "comments_9": {"comment_id": 10, "comment_author": "sparticlesteve", "commentT": "2020-05-04T15:46:41Z", "comment_text": "\n \t\tThanks. I'll give it a shot when I have time and report back.\n \t\t"}}}, "commit": {"commit_id": "ba1316de903ba4cd4f12c26a7e035c3f43d6f82d", "commit_author": "Travis Addair", "commitT": "2020-05-04 07:53:03-07:00", "changed_files": {"file_0": {"file_change_type": "MODIFY", "file_Nmethod": 0, "file_old_name": "docs\\mocks.py", "file_new_name": "docs\\mocks.py", "hunks": {"hunk_0": {"Ismethod": 0, "added_lines": "106,107,108,109,110,111,112", "deleted_lines": null}}}, "file_1": {"file_change_type": "MODIFY", "file_Nmethod": 0, "file_old_name": "examples\\keras_imagenet_resnet50.py", "file_new_name": "examples\\keras_imagenet_resnet50.py", "hunks": {"hunk_0": {"Ismethod": 0, "added_lines": "99,100,101,123,147,148,151,152,153,154,155", "deleted_lines": "120,121,122,123,147,150,151,152,153"}}}, "file_2": {"file_change_type": "MODIFY", "file_Nmethod": 0, "file_old_name": "examples\\keras_mnist_advanced.py", "file_new_name": "examples\\keras_mnist_advanced.py", "hunks": {"hunk_0": {"Ismethod": 0, "added_lines": "86,87,111", "deleted_lines": "86,110"}}}, "file_3": {"file_change_type": "MODIFY", "file_Nmethod": 1, "file_old_name": "examples\\keras_spark3_rossmann.py", "file_new_name": "examples\\keras_spark3_rossmann.py", "hunks": {"hunk_0": {"Ismethod": 1, "added_lines": "427,428,448", "deleted_lines": "427,447", "method_info": {"method_name": "train_fn", "method_params": "model_bytes", "method_startline": "396", "method_endline": "501"}}}}, "file_4": {"file_change_type": "MODIFY", "file_Nmethod": 0, "file_old_name": "examples\\keras_spark3_rossmann.py.patch", "file_new_name": "examples\\keras_spark3_rossmann.py.patch", "hunks": {"hunk_0": {"Ismethod": 0, "added_lines": "26,52,54,67", "deleted_lines": "26,52,54,67"}}}, "file_5": {"file_change_type": "MODIFY", "file_Nmethod": 1, "file_old_name": "examples\\keras_spark_rossmann_run.py", "file_new_name": "examples\\keras_spark_rossmann_run.py", "hunks": {"hunk_0": {"Ismethod": 1, "added_lines": "417,418,438", "deleted_lines": "417,437", "method_info": {"method_name": "train_fn", "method_params": "model_bytes", "method_startline": "387", "method_endline": "491"}}}}, "file_6": {"file_change_type": "MODIFY", "file_Nmethod": 0, "file_old_name": "examples\\tensorflow2_keras_mnist.py", "file_new_name": "examples\\tensorflow2_keras_mnist.py", "hunks": {"hunk_0": {"Ismethod": 0, "added_lines": "50,51,78", "deleted_lines": "50,77"}}}, "file_7": {"file_change_type": "MODIFY", "file_Nmethod": 5, "file_old_name": "horovod\\_keras\\callbacks.py", "file_new_name": "horovod\\_keras\\callbacks.py", "hunks": {"hunk_0": {"Ismethod": 1, "added_lines": null, "deleted_lines": "89", "method_info": {"method_name": "__init__", "method_params": "self,backend,multiplier,start_epoch,end_epoch,staircase,momentum_correction,steps_per_epoch,args", "method_startline": "88", "method_endline": "89"}}, "hunk_1": {"Ismethod": 1, "added_lines": "142,143", "deleted_lines": null, "method_info": {"method_name": "on_train_begin", "method_params": "self,logs", "method_startline": "141", "method_endline": "145"}}, "hunk_2": {"Ismethod": 1, "added_lines": null, "deleted_lines": "168", "method_info": {"method_name": "__init__", "method_params": "self,backend,warmup_epochs,momentum_correction,steps_per_epoch,verbose,args", "method_startline": "167", "method_endline": "168"}}, "hunk_3": {"Ismethod": 1, "added_lines": "174", "deleted_lines": null, "method_info": {"method_name": "__init__", "method_params": "self,backend,warmup_epochs,momentum_correction,steps_per_epoch,verbose,initial_lr,args", "method_startline": "173", "method_endline": "174"}}, "hunk_4": {"Ismethod": 1, "added_lines": "91", "deleted_lines": null, "method_info": {"method_name": "__init__", "method_params": "self,backend,multiplier,start_epoch,end_epoch,staircase,momentum_correction,steps_per_epoch,initial_lr,args", "method_startline": "90", "method_endline": "91"}}}}, "file_8": {"file_change_type": "MODIFY", "file_Nmethod": 2, "file_old_name": "horovod\\common\\util.py", "file_new_name": "horovod\\common\\util.py", "hunks": {"hunk_0": {"Ismethod": 1, "added_lines": "224,225", "deleted_lines": null, "method_info": {"method_name": "get_average_backwards_compatibility_fun", "method_params": "reduce_ops", "method_startline": "211", "method_endline": "229"}}, "hunk_1": {"Ismethod": 1, "added_lines": "224,225", "deleted_lines": null, "method_info": {"method_name": "get_average_backwards_compatibility_fun.impl", "method_params": "op,average", "method_startline": "218", "method_endline": "228"}}}}, "file_9": {"file_change_type": "MODIFY", "file_Nmethod": 4, "file_old_name": "horovod\\keras\\callbacks.py", "file_new_name": "horovod\\keras\\callbacks.py", "hunks": {"hunk_0": {"Ismethod": 1, "added_lines": "137", "deleted_lines": null, "method_info": {"method_name": "__init__", "method_params": "self,warmup_epochs,momentum_correction,steps_per_epoch,verbose,initial_lr", "method_startline": "136", "method_endline": "137"}}, "hunk_1": {"Ismethod": 1, "added_lines": null, "deleted_lines": "132", "method_info": {"method_name": "__init__", "method_params": "self,warmup_epochs,momentum_correction,steps_per_epoch,verbose", "method_startline": "131", "method_endline": "132"}}, "hunk_2": {"Ismethod": 1, "added_lines": "86", "deleted_lines": "86", "method_info": {"method_name": "__init__", "method_params": "self,multiplier,start_epoch,end_epoch,staircase,momentum_correction,steps_per_epoch,initial_lr", "method_startline": "85", "method_endline": "86"}}, "hunk_3": {"Ismethod": 1, "added_lines": "86", "deleted_lines": "86", "method_info": {"method_name": "__init__", "method_params": "self,multiplier,start_epoch,end_epoch,staircase,momentum_correction,steps_per_epoch", "method_startline": "85", "method_endline": "86"}}}}, "file_10": {"file_change_type": "MODIFY", "file_Nmethod": 0, "file_old_name": "horovod\\tensorflow\\__init__.py", "file_new_name": "horovod\\tensorflow\\__init__.py", "hunks": {"hunk_0": {"Ismethod": 0, "added_lines": "55,56,57,58,59", "deleted_lines": "55"}}}, "file_11": {"file_change_type": "MODIFY", "file_Nmethod": 4, "file_old_name": "horovod\\tensorflow\\keras\\callbacks.py", "file_new_name": "horovod\\tensorflow\\keras\\callbacks.py", "hunks": {"hunk_0": {"Ismethod": 1, "added_lines": "144", "deleted_lines": null, "method_info": {"method_name": "__init__", "method_params": "self,warmup_epochs,momentum_correction,steps_per_epoch,verbose,initial_lr", "method_startline": "143", "method_endline": "144"}}, "hunk_1": {"Ismethod": 1, "added_lines": null, "deleted_lines": "139", "method_info": {"method_name": "__init__", "method_params": "self,warmup_epochs,momentum_correction,steps_per_epoch,verbose", "method_startline": "138", "method_endline": "139"}}, "hunk_2": {"Ismethod": 1, "added_lines": "93", "deleted_lines": "93", "method_info": {"method_name": "__init__", "method_params": "self,multiplier,start_epoch,end_epoch,staircase,momentum_correction,steps_per_epoch,initial_lr", "method_startline": "92", "method_endline": "93"}}, "hunk_3": {"Ismethod": 1, "added_lines": "93", "deleted_lines": "93", "method_info": {"method_name": "__init__", "method_params": "self,multiplier,start_epoch,end_epoch,staircase,momentum_correction,steps_per_epoch", "method_startline": "92", "method_endline": "93"}}}}, "file_12": {"file_change_type": "MODIFY", "file_Nmethod": 4, "file_old_name": "horovod\\torch\\mpi_ops.py", "file_new_name": "horovod\\torch\\mpi_ops.py", "hunks": {"hunk_0": {"Ismethod": 1, "added_lines": "255,256,257,258,259", "deleted_lines": "243", "method_info": {"method_name": "allreduce_", "method_params": "tensor,average,name,op", "method_startline": "243", "method_endline": "269"}}, "hunk_1": {"Ismethod": 1, "added_lines": "226,227,228,229,230", "deleted_lines": "218", "method_info": {"method_name": "allreduce_async_", "method_params": "tensor,average,name,op", "method_startline": "214", "method_endline": "240"}}, "hunk_2": {"Ismethod": 1, "added_lines": "144,145,146,147,148", "deleted_lines": "144", "method_info": {"method_name": "allreduce_async", "method_params": "tensor,average,name,op", "method_startline": "132", "method_endline": "159"}}, "hunk_3": {"Ismethod": 1, "added_lines": "193,194,195,196,197", "deleted_lines": "189", "method_info": {"method_name": "allreduce", "method_params": "tensor,average,name,compression,op", "method_startline": "177", "method_endline": "211"}}}}, "file_13": {"file_change_type": "MODIFY", "file_Nmethod": 0, "file_old_name": "horovod\\torch\\sync_batch_norm.py", "file_new_name": "horovod\\torch\\sync_batch_norm.py", "hunks": {"hunk_0": {"Ismethod": 0, "added_lines": "36,37,38,39,56", "deleted_lines": "36,37,38,39,56"}}}, "file_14": {"file_change_type": "MODIFY", "file_Nmethod": 1, "file_old_name": "setup.py", "file_new_name": "setup.py", "hunks": {"hunk_0": {"Ismethod": 1, "added_lines": "676,677,678,679,745", "deleted_lines": "676,677,743", "method_info": {"method_name": "get_common_options", "method_params": "build_ext", "method_startline": "580", "method_endline": "835"}}}}}}}