{"BR": {"BR_id": "265", "BR_author": "decodyng", "BRopenT": "2020-12-19T00:17:08Z", "BRcloseT": "2021-01-11T16:03:32Z", "BR_text": {"BRsummary": "[Bug] Silent NaNs in PPO Loss Calculation if n_steps=1 and n_envs=1", "BRdescription": "\n <denchmark-h:h3>\ud83d\udc1b Bug</denchmark-h>\n \n This is somewhere between a bug and a request for more informative errors:\n When n_steps and n_envs are both set to 1, the batch returned by a rollout buffer <denchmark-link:https://github.com/DLR-RM/stable-baselines3/blob/master/stable_baselines3/ppo/ppo.py#L160>here</denchmark-link>\n  will be of length 1. This will make the  calculation return  values, since the normalization step involves calculating the standard deviation of advantages, which is undefined for a single element.\n I recognize that this small of a setting is definitely an edge case (I ran into it during testing, when we were setting all values quite low for speed reasons), so I'm not sure it makes sense to have logic for this case, but at minimum, I think it would be beneficial to have some kind of explicit warning that checks if actions or advantages have a single element, so that there's a clear indication of the source of the issue, rather than having to follow a breadcrumb trail of nans from some higher abstraction level of code\n <denchmark-h:h3>To Reproduce</denchmark-h>\n \n <denchmark-code>from stable_baselines3 import PPO\n \n env = gym.make('CartPole-v1')\n model = PPO('MlpPolicy', env, verbose=1, n_steps=1)\n model.learn(total_timesteps=10)\n </denchmark-code>\n \n This will fail with an unclear error :\n <denchmark-code>RuntimeError: invalid multinomial distribution (encountering probability entry < 0)\n </denchmark-code>\n \n If you put a debugger or insert logging statements at ppo.py:170, you'll be able to see that (1) len(advantages) = 1 and consequently (2) advantages.std() = nan, which first arises as a visible bug when you try to collect an on-policy rollout after your first training step, since the nan values in loss propagate into nan parameter values.\n <denchmark-h:h3>Expected behavior</denchmark-h>\n \n Either (1) explicit support for training on effective batches of size 1, or (2) a clearer and earlier error when you attempt to construct an algorithm object with n_steps=1 and n_envs=1, informing the user that the case isn't supported.\n ###\u00a0System Info\n Describe the characteristic of your environment:\n \n Describe how the library was installed (pip, docker, source, ...): Cloned from fork of current master, installed via pip\n GPU models and configuration: N/A\n Python version: 3.7.0\n PyTorch version: 1.7.1\n Gym version: 0.17.3\n Versions of any other relevant libraries: N/A\n \n <denchmark-h:h3>Additional context</denchmark-h>\n \n Add any other context about the problem here.\n <denchmark-h:h3>Checklist</denchmark-h>\n \n \n  I have checked that there is no similar issue in the repo (required)\n  I have read the documentation (required)\n  I have provided a minimal working example to reproduce the bug (required)\n \n \t"}, "comments": {"comments_0": {"comment_id": 1, "comment_author": "decodyng", "commentT": "2020-12-19T17:03:37Z", "comment_text": "\n \t\tHello,\n nice catch =)\n Even though this case is unlikely to happen (using PPO with n_steps=1 and n_envs=1), I agree we should have a better error message, an assert should do the trick ;)\n We would happy if you could submit a PR that solves this issue ;)\n \t\t"}, "comments_1": {"comment_id": 2, "comment_author": "decodyng", "commentT": "2020-12-21T18:45:36Z", "comment_text": "\n \t\tSound good; I already have a fork with that basic assert, and would be happy to merge that in.\n One subtler thing that I'd be curious for the maintainers' perspective on: my impression from the testing I did in uncovering this bug is that the effective batch size used in an update is min(batch_size, n_envs*n_steps).\n First off, I'm curious if that is also your understanding of how you expect things to work. Secondly, if that impression is correct, would you be open to also adding a Warning if n_envs*n_steps is less than a specified batch size, since that might mean the intended batch size isn't actually being used for updates?\n \t\t"}, "comments_2": {"comment_id": 3, "comment_author": "decodyng", "commentT": "2020-12-21T19:01:16Z", "comment_text": "\n \t\t\n One subtler thing that I'd be curious for the maintainers' perspective on: my impression from the testing I did in uncovering this bug is that the effective batch size used in an update is min(batch_size, n_envs*n_steps).\n \n What makes you think that?\n The only thing that can happen when using the rollout buffer with PPO, is that the last minibatch will be truncated (so the last minibatch size will be:\n total_transitions = n_envs * n_steps\n n_minibatches = total_transitions // batch_size # number of minibatches with correct batch size\n \n # the last minibatch size will be smaller in that case\n if total_transitions - n_minibatches * batch_size > 0:\n     last_minibatch_size = total_transitions - n_minibatches * batch_size\n but it would probably be good to add a warning too.\n \t\t"}, "comments_3": {"comment_id": 4, "comment_author": "decodyng", "commentT": "2020-12-21T19:20:25Z", "comment_text": "\n \t\tHere's an example demonstrating the thing I think I'm seeing here:\n <denchmark-code>import gym\n from stable_baselines3 import PPO\n \n env = gym.make('CartPole-v1')\n model = PPO('MlpPolicy', env, verbose=1, n_steps=14, batch_size=16)\n model.learn(total_timesteps=100)\n </denchmark-code>\n \n If I put a debug statement at ppo.py:183 to print len(advantages) (which I think is the effective batch size, since the loss is calculated and gradient update is done within that loop), I'm seeing that debug line always return a value of 14 (=14 steps*1 env) rather than 16 (the specified batch size), for all batches, rather than just the final batch.\n \t\t"}, "comments_4": {"comment_id": 5, "comment_author": "decodyng", "commentT": "2020-12-21T19:24:36Z", "comment_text": "\n \t\tAh, reading over your comment again, I now think we're saying the same thing here, except you're framing it as the last minibatch getting truncated, and in the situation I'm describing, you can't pull even a single minibatch from the amount of data present in n_steps*n_envs, so all batches are truncated\n \t\t"}, "comments_5": {"comment_id": 6, "comment_author": "decodyng", "commentT": "2020-12-21T19:25:55Z", "comment_text": "\n \t\tIf I set the batch_size to instead be 8, I see what you're referring to (where the effective batch size alternates between 8 and 6, to add up to 14)\n \t\t"}, "comments_6": {"comment_id": 7, "comment_author": "decodyng", "commentT": "2020-12-21T19:31:34Z", "comment_text": "\n \t\tGiven this, I could see two opportunities to warn:\n \n The thing I was thinking of, where you've set your steps and envs poorly such that every batch will end up truncated\n Warning when n_steps*n_envs % batch_size !=0 in general, and just noting that the final batch in each buffer will end up truncated. This seems less important than (1) especially when the number of batches per buffer is large, but still potentially worth noting. (Obviously (1) is a subset situation of (2), but I think it'd be worth explicitly calling out since I think it's a larger problem when all batches will be truncated)\n \n We could also try to merge these into some kind of aggregated error, where we pre-calculate how often a truncated batch will happen, and explicitly say \"k of every K batches will be truncated to a value of x\", which might nicely cover both cases, and hopefully give people pause when they see \"10 of every 10 batches will be truncated,\" or something like that\n This is a situation that, I think if you understand all the relevant parameters well, you hopefully wouldn't run into, but I think the nuance of how envs, steps, timesteps, and batch_size work together here is subtle enough that it's worth covering cases like these.\n \t\t"}, "comments_7": {"comment_id": 8, "comment_author": "decodyng", "commentT": "2020-12-22T10:21:32Z", "comment_text": "\n \t\tJust warn at model creation that the last minibatch size will have a size smaller than batch_size (and we can print those two) because n_envs * n_steps is not a multiple of batch_size\n \t\t"}}}, "commit": {"commit_id": "b1aee717729e84d0e5a05e37324a6b1521db6e1b", "commit_author": "Cody Wild", "commitT": "2021-01-11 17:03:32+01:00", "changed_files": {"file_0": {"file_change_type": "MODIFY", "file_Nmethod": 0, "file_old_name": "docs\\misc\\changelog.rst", "file_new_name": "docs\\misc\\changelog.rst", "hunks": {"hunk_0": {"Ismethod": 0, "added_lines": "38,39,40,54,542", "deleted_lines": "538"}}}, "file_1": {"file_change_type": "MODIFY", "file_Nmethod": 0, "file_old_name": "stable_baselines3\\ppo\\ppo.py", "file_new_name": "stable_baselines3\\ppo\\ppo.py", "hunks": {"hunk_0": {"Ismethod": 0, "added_lines": "1,32,33,34,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138", "deleted_lines": "31,118"}}}, "file_2": {"file_change_type": "MODIFY", "file_Nmethod": 2, "file_old_name": "tests\\test_utils.py", "file_new_name": "tests\\test_utils.py", "hunks": {"hunk_0": {"Ismethod": 1, "added_lines": "343,344,345,346,347,348,349,350,351,352,353", "deleted_lines": null, "method_info": {"method_name": "test_ppo_warnings", "method_params": "", "method_startline": "343", "method_endline": "353"}}, "hunk_1": {"Ismethod": 1, "added_lines": "83,84,85,86,87,88", "deleted_lines": "83", "method_info": {"method_name": "test_vec_env_monitor_kwargs", "method_params": "", "method_startline": "73", "method_endline": "89"}}}}}}}