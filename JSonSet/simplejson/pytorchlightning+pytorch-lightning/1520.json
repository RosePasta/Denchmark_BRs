{"BR": {"BR_id": "1520", "BR_author": "guydav", "BRopenT": "2020-04-17T18:47:13Z", "BRcloseT": "2020-07-18T14:28:00Z", "BR_text": {"BRsummary": "Bug and question about logging -- missing epoch, validation before train?", "BRdescription": "\n <denchmark-h:h2>\ud83d\udc1b Bug</denchmark-h>\n \n First, the clear bug: in TrainerLoggingMixin.log_metrics() the epoch is added to the metrics variable (line 70) which is never accessed again. That should be to scalar_metrics, shouldn't it?\n Second, a question: I implemented a very primitive logger (to stdout) and logging to it. I don't get training results when the first epoch ends until after the first epoch validation step, and consequently don't get training metrics from the last epochs. See code and sample output below. Does this make sense?\n <denchmark-h:h3>To Reproduce</denchmark-h>\n \n Add the following code to a Lightning Module and run a trainer with the following logger:\n use_gpu = int(torch.cuda.is_available())\n print_logger = PrintLogger()\n trainer = Trainer(gpus=use_gpu, max_epochs=5, logger=print_logger)\n trainer.fit(model)\n <denchmark-h:h4>Code sample</denchmark-h>\n \n Minimal logging in the LightningModule:\n     def training_epoch_end(self, outputs):\n         avg_loss = torch.stack([x['loss'] for x in outputs]).mean()\n         avg_acc = torch.stack([x['acc'] for x in outputs]).mean()\n         logs = dict(train_loss=avg_loss, train_acc=avg_acc)\n         return dict(log=logs)\n \n     def validation_epoch_end(self, outputs):\n         avg_loss = torch.stack([x['loss'] for x in outputs]).mean()\n         avg_acc = torch.stack([x['acc'] for x in outputs]).mean()\n         logs = dict(val_loss=avg_loss, val_acc=avg_acc)\n         return dict(log=logs)\n A minimal logger:\n from pytorch_lightning.loggers import LightningLoggerBase, rank_zero_only\n \n class PrintLogger(LightningLoggerBase):\n     \n     def __init__(self):\n         super(PrintLogger, self).__init__()\n     \n     @property\n     def name(self):\n         return 'Test'\n     \n     @property\n     def experiment(self):\n         return self.name()\n     \n     @property\n     def version(self):\n         return '0.0.1'\n     \n     @rank_zero_only\n     def log_hyperparams(self, params):\n         print(f'Hyperparameters:\\n{params}')\n \n     @rank_zero_only\n     def log_metrics(self, metrics, step):\n         if metrics is not None and len(metrics.keys()) > 0:\n             print(f'{step}: {metrics}')\n \n     def save(self):\n         # Optional. Any code necessary to save logger data goes here\n         pass\n \n     @rank_zero_only\n     def finalize(self, status):\n         # Optional. Any code that needs to be run after training\n         # finishes goes here\n         pass\n <denchmark-h:h3>Expected behavior</denchmark-h>\n \n I would expect to see the training output for each epoch followed by the validation output for each epoch, for each of the five epochs. Instead, I see the following -- four train outputs and five validation ones, and seeing the validation first:\n <denchmark-h:h4>Observed behavior:</denchmark-h>\n \n <denchmark-code>63: {'val_loss': 0.6922042369842529, 'val_acc': 0.51458740234375}\n 64: {'train_acc': 0.503265380859375, 'train_loss': 1.0884952545166016}\n 127: {'val_loss': 0.6919643878936768, 'val_acc': 0.51861572265625}\n 128: {'train_acc': 0.51318359375, 'train_loss': 0.6927268505096436}\n 191: {'val_loss': 0.6915570497512817, 'val_acc': 0.526611328125}\n 192: {'train_acc': 0.5161285400390625, 'train_loss': 0.6924755573272705}\n 255: {'val_loss': 0.6915992498397827, 'val_acc': 0.52325439453125}\n 256: {'train_acc': 0.5159149169921875, 'train_loss': 0.6921626329421997}\n 319: {'val_loss': 0.6915264129638672, 'val_acc': 0.521240234375}\n </denchmark-code>\n \n <denchmark-h:h4>Expected behavior:</denchmark-h>\n \n Where n is the number of steps/batches per epoch:\n <denchmark-code>n-1: {'train_acc': ..., 'train_loss': ...}\n n-1: {'val_loss': ..., 'val_acc': ...}\n 2n-1 {'train_acc': ..., 'train_loss': ...}\n 2n-1: {'val_loss': ..., 'val_acc': ...}\n 3n-1 {'train_acc': ..., 'train_loss': ...}\n 3n-1: {'val_loss': ..., 'val_acc': ...}\n ...\n </denchmark-code>\n \n <denchmark-h:h3>Environment</denchmark-h>\n \n <denchmark-code>cuda:\n \tGPU:\n \tavailable:           False\n \tversion:             10.0.130\n packages:\n \tnumpy:               1.18.2\n \tpyTorch_debug:       False\n \tpyTorch_version:     1.3.1\n \tpytorch-lightning:   0.7.3\n \ttensorboard:         2.2.0\n \ttqdm:                4.45.0\n system:\n \tOS:                  Linux\n \tarchitecture: 64bit\n \tprocessor:           x86_64\n \tpython:              3.7.4\n \tversion:             #1 SMP Tue Feb 4 23:02:59 UTC 2020\n </denchmark-code>\n \n <denchmark-h:h3>Additional context</denchmark-h>\n \n \t"}, "comments": {"comments_0": {"comment_id": 1, "comment_author": "guydav", "commentT": "2020-04-17T18:47:54Z", "comment_text": "\n \t\tHi! thanks for your contribution!, great first issue!\n \t\t"}, "comments_1": {"comment_id": 2, "comment_author": "guydav", "commentT": "2020-04-17T20:38:00Z", "comment_text": "\n \t\tJust to clarify your bug, you are missing some metrics? If I get it correctly, this shall be your fix <denchmark-link:https://github.com/PyTorchLightning/pytorch-lightning/pull/1459>#1459</denchmark-link>\n \n \t\t"}, "comments_2": {"comment_id": 3, "comment_author": "guydav", "commentT": "2020-04-17T20:48:45Z", "comment_text": "\n \t\tHi <denchmark-link:https://github.com/Borda>@Borda</denchmark-link>\n  , I don't think that captures it. I'm reporting one clear bug (the epoch field doesn't get to the logger, since it's added to the  dict, rather than the  dict, in  .\n The second bug I'm reporting may not be a bug, but at the very least is confusing behavior. As a user, I would expect my logger to first get training results for an epoch, and then validation results. The PR you're referencing might solve the problem of the last training results not being returned at all, but won't fix the fact that something in the way steps are used in the logger causes validation results to come before test results.\n \t\t"}, "comments_3": {"comment_id": 4, "comment_author": "guydav", "commentT": "2020-04-17T20:51:30Z", "comment_text": "\n \t\tI updated under  'Expected Behavior' to clarify the discrepancy I found.\n \t\t"}, "comments_4": {"comment_id": 5, "comment_author": "guydav", "commentT": "2020-04-17T21:04:48Z", "comment_text": "\n \t\t<denchmark-link:https://github.com/guydav>@guydav</denchmark-link>\n  mind send a PR? :]\n \t\t"}, "comments_5": {"comment_id": 6, "comment_author": "guydav", "commentT": "2020-04-17T21:09:13Z", "comment_text": "\n \t\t<denchmark-link:https://github.com/Borda>@Borda</denchmark-link>\n  for the first issue, sure, it's a one-line fix, but I'd need to set up to be able to run the tests.\n For the second issue, I don't quite know where it originates from. I was hoping someone with a better understanding of how logging is structured chimes in before I start to try and learn my way around that entire codebase.\n \t\t"}, "comments_6": {"comment_id": 7, "comment_author": "guydav", "commentT": "2020-06-16T21:53:49Z", "comment_text": "\n \t\tThis issue has been automatically marked as stale because it has not had recent activity. It will be closed if no further activity occurs. Thank you for your contributions.\n \t\t"}, "comments_7": {"comment_id": 8, "comment_author": "guydav", "commentT": "2020-06-17T08:51:55Z", "comment_text": "\n \t\tHi <denchmark-link:https://github.com/Borda>@Borda</denchmark-link>\n  -- I think there's still another underlying issue with how metrics are reported unless someone interacted with this code over the last while.\n If you look at the observed behavior and expected behavior steps above, do you agree there's an issue? That it makes no sense for the validation metrics for a particular epoch to report before the training metrics for that epoch, and with a different step at that?\n \t\t"}, "comments_8": {"comment_id": 9, "comment_author": "guydav", "commentT": "2020-07-14T15:42:34Z", "comment_text": "\n \t\tThis behaviour seems to have changed.\n I copied your logger to the pl_examples/gpu_template.py and launched it with\n     trainer = Trainer(\n         max_epochs=2, \n         gpus=1,\n         logger=PrintLogger(),\n         limit_train_batches=10,\n         limit_val_batches=10,\n         row_log_interval=1,\n         progress_bar_refresh_rate=0\n     )\n output is\n 0: {'train_loss': 2.503892660140991, 'epoch': 0}\n 1: {'train_loss': 2.096820831298828, 'epoch': 0}\n 2: {'train_loss': 8.215052604675293, 'epoch': 0}\n 3: {'train_loss': 5.370606422424316, 'epoch': 0}\n 4: {'train_loss': 5.988080978393555, 'epoch': 0}\n 5: {'train_loss': 2.3805108070373535, 'epoch': 0}\n 6: {'train_loss': 4.3501176834106445, 'epoch': 0}\n 7: {'train_loss': 9.668755531311035, 'epoch': 0}\n 8: {'train_loss': 6.58243465423584, 'epoch': 0}\n \n # this is the last step of the epoch, metrics get combined and logged together\n 9: {'epoch': 0.0, 'val_loss': 4.287566661834717, 'train_loss': 12.217967987060547, 'val_acc': 0.515625}\n \n 10: {'train_loss': 1.7836229801177979, 'epoch': 1}\n 11: {'train_loss': 1.7488218545913696, 'epoch': 1}\n 12: {'train_loss': 2.221280097961426, 'epoch': 1}\n 13: {'train_loss': 3.4499270915985107, 'epoch': 1}\n 14: {'train_loss': 3.5983619689941406, 'epoch': 1}\n 15: {'train_loss': 2.813007116317749, 'epoch': 1}\n 16: {'train_loss': 3.2659897804260254, 'epoch': 1}\n 17: {'train_loss': 4.156956672668457, 'epoch': 1}\n 18: {'train_loss': 2.931321859359741, 'epoch': 1}\n # no val logs here :( we expect a dict as in step 9\n The original problem you describe seems to be gone, but I notice two other issues:\n \n at step 9, the epoch is a float 0.0\n the validation metrics of epoch 2 (last one) do not get logged\n \n \t\t"}, "comments_9": {"comment_id": 10, "comment_author": "guydav", "commentT": "2020-07-15T10:24:13Z", "comment_text": "\n \t\t<denchmark-link:https://github.com/awaelchli>@awaelchli</denchmark-link>\n , thank you for looking into it again! I agree this does look better. It's been a while since I dug through this code, but I think I have a hunch for at least one of these issues. Note that in the second issue you point out, we're missing the last set of train metrics, that should arrive with the validation metrics.\n Reading through <denchmark-link:https://github.com/PyTorchLightning/pytorch-lightning/blob/master/pytorch_lightning/loggers/base.py>LightningLoggerBase</denchmark-link>\n , its API seems to be through the function , which is called from the <denchmark-link:https://github.com/PyTorchLightning/pytorch-lightning/blob/7b4db3045dcc9e6bb0b66e409b25bb2c7fa378f0/pytorch_lightning/trainer/logging.py#L73>TrainerLoggingMixin</denchmark-link>\n .  calls , which only omits metrics to log if the current step is different from the previous step. Since there's never a call to this function after the last validation epoch, it doesn't see a new step, and therefore never omits the last output. It looks like a call to any of , , or  should result in a call to <denchmark-link:https://github.com/PyTorchLightning/pytorch-lightning/blob/7b4db3045dcc9e6bb0b66e409b25bb2c7fa378f0/pytorch_lightning/loggers/base.py#L108>finalize_agg_metrics</denchmark-link>\n , which should do the trick. So either it's not getting called, or for some reason, it doesn't do what it should.\n The float epoch thing is probably a smaller bit. I'll try to debug both of these later today if I have time.\n \t\t"}, "comments_10": {"comment_id": 11, "comment_author": "guydav", "commentT": "2020-07-15T11:01:38Z", "comment_text": "\n \t\t<denchmark-link:https://github.com/guydav>@guydav</denchmark-link>\n  I checked again, the step 8 was missing from my post by accident because I had to copy paste around some warnings that were printed to the console and it seems I missed one line, but the step 8 is there and I edited my post.\n \t\t"}, "comments_11": {"comment_id": 12, "comment_author": "guydav", "commentT": "2020-07-15T11:03:59Z", "comment_text": "\n \t\tOh, I mean that we're missing step 19, which contains both the 10th training batch from the second epoch and the validation metrics for that epoch.\n \t\t"}, "comments_12": {"comment_id": 13, "comment_author": "guydav", "commentT": "2020-07-15T11:08:10Z", "comment_text": "\n \t\tYes I agree, that's the big one :) It should definitely log a dict like step 9\n \t\t"}, "comments_13": {"comment_id": 14, "comment_author": "guydav", "commentT": "2020-07-18T14:28:00Z", "comment_text": "\n \t\tUpdate: it appears that I am the problem. I don't know why, but I overrode save and finalize above to do nothing. Omitting that (commenting them out, or a super call) makes everything work out. I honestly have no idea how that happened, but now everything looks fine. I don't see the floating point epoch either:\n Here's a printout:\n <denchmark-code>0: {'train_loss': 2.517963171005249, 'epoch': 0}\n 1: {'train_loss': 2.1298298835754395, 'epoch': 0}\n 2: {'train_loss': 8.561811447143555, 'epoch': 0}\n 3: {'train_loss': 5.23430871963501, 'epoch': 0}\n 4: {'train_loss': 6.442159175872803, 'epoch': 0}\n 5: {'train_loss': 2.1811487674713135, 'epoch': 0}\n 6: {'train_loss': 4.158588409423828, 'epoch': 0}\n 7: {'train_loss': 10.028255462646484, 'epoch': 0}\n 8: {'train_loss': 6.593491077423096, 'epoch': 0}\n 9: {'val_loss': 4.531818389892578, 'val_acc': 0.453125, 'epoch': 0}\n 9: {'train_loss': 10.541756629943848, 'epoch': 0}\n 10: {'train_loss': 1.6655378341674805, 'epoch': 1}\n 11: {'train_loss': 2.284700393676758, 'epoch': 1}\n 12: {'train_loss': 2.4957871437072754, 'epoch': 1}\n 13: {'train_loss': 4.456875324249268, 'epoch': 1}\n 14: {'train_loss': 4.337017059326172, 'epoch': 1}\n 15: {'train_loss': 3.4667391777038574, 'epoch': 1}\n 16: {'train_loss': 3.3742592334747314, 'epoch': 1}\n 17: {'train_loss': 3.353729248046875, 'epoch': 1}\n 18: {'train_loss': 2.8706002235412598, 'epoch': 1}\n 19: {'val_loss': 4.367581844329834, 'val_acc': 0.571875, 'epoch': 1}\n 19: {'train_loss': 4.163558483123779, 'epoch': 1}\n </denchmark-code>\n \n \t\t"}, "comments_14": {"comment_id": 15, "comment_author": "guydav", "commentT": "2020-07-18T16:58:06Z", "comment_text": "\n \t\tOh great you found this. Last time I tried to debug it I was stuck because we actually have tests for these things and I was very confused why it would not work :)\n Thanks <denchmark-link:https://github.com/guydav>@guydav</denchmark-link>\n \n \t\t"}}}, "commit": {"commit_id": "fe2b6666e0c3a47992860a2200ab40ae1c2ea6c7", "commit_author": "Guy Davidson", "commitT": "2020-04-23 17:52:41-04:00", "changed_files": {"file_0": {"file_change_type": "MODIFY", "file_Nmethod": 1, "file_old_name": "pytorch_lightning\\trainer\\logging.py", "file_new_name": "pytorch_lightning\\trainer\\logging.py", "hunks": {"hunk_0": {"Ismethod": 1, "added_lines": "71", "deleted_lines": "71", "method_info": {"method_name": "log_metrics", "method_params": "self,metrics,grad_norm_dic,step", "method_startline": "46", "method_endline": "76"}}}}, "file_1": {"file_change_type": "MODIFY", "file_Nmethod": 1, "file_old_name": "tests\\loggers\\test_all.py", "file_new_name": "tests\\loggers\\test_all.py", "hunks": {"hunk_0": {"Ismethod": 1, "added_lines": "65,66,67", "deleted_lines": "65,66,67", "method_info": {"method_name": "test_loggers_fit_test", "method_params": "tmpdir,monkeypatch,logger_class", "method_startline": "30", "method_endline": "67"}}}}}}}