{"BR": {"BR_id": "598", "BR_author": "pinzhenx", "BRopenT": "2019-11-20T08:06:57Z", "BRcloseT": "2019-12-04T15:54:15Z", "BR_text": {"BRsummary": "Int8 Pooling not preserving NHWC format", "BRdescription": "\n In MKLDNN 0.x, given that the src format is NHWC, the queried dst format would be NHWC as well. However, in DNNL 1.x, the queried dst format becomes NCHW.\n <denchmark-code>dnnl_verbose,exec,cpu,pooling,ref:any,forward_inference,src_u8::blocked:acbd:f0 dst_u8::blocked:abcd:f0 ws_undef::undef::f0,,alg:pooling_max,mb1ic1_ih7oh5kh3sh1ph0_iw7ow5kw3sw1pw0,0.0290527\n </denchmark-code>\n \n Even though I have a way of fixing  format, it goes against the design philosophy of DNNL, and it could probably lead to serious performance issue (<denchmark-link:https://github.com/oneapi-src/oneDNN/issues/588>#588</denchmark-link>\n ).\n Consider this scenario, if this pool is followed by a conv, this requires an extra reorder before the next quantized conv that requires an NHWC input, but in the old MKLDNN, this reorder is not necessary.\n So I'm wondering whether it is an intentional change in this behavior.\n \t"}, "comments": {"comments_0": {"comment_id": 1, "comment_author": "pinzhenx", "commentT": "2019-11-20T16:11:14Z", "comment_text": "\n \t\tHi <denchmark-link:https://github.com/pinzhenx>@pinzhenx</denchmark-link>\n ,\n No, this is not the intentional behavior... Looks like a bug.\n I would expect the library to behave similarly to MKL-DNN 0.x version.\n Do you happen to have a standalone reproducer?\n \t\t"}, "comments_1": {"comment_id": 2, "comment_author": "pinzhenx", "commentT": "2019-11-20T18:27:34Z", "comment_text": "\n \t\tbench_string=\"benchdnn --pool --tag=acdb --dir=FWD_I --cfg=u8 --alg=MAX \";\n ${bench_string} mb1ic1_ih7oh5kh3sh1ph0_iw7ow5kw3sw1pw0  -- this one is wrong.\n dnnl_verbose,exec,cpu,pooling,ref:any,forward_inference,src_u8::blocked:acbd:f0 dst_u8::blocked\ud83d\udd21f0 ws_undef::undef::f0,,alg:pooling_max,mb1ic1_ih7oh5kh3sh1ph0_iw7ow5kw3sw1pw0\n ${bench_string} mb1ic2_ih7oh5kh3sh1ph0_iw7ow5kw3sw1pw0  -- this one is correct.\n dnnl_verbose,exec,cpu,pooling,jit_int:avx2,forward_inference,src_u8::blocked:acdb:f0 dst_u8::blocked:acdb:f0 ws_undef::undef::f0,,alg:pooling_max,mb1ic2_ih7oh5kh3sh1ph0_iw7ow5kw3sw1pw0\n The problem is memory_desc_init_by_blocking_desc() doesn't distinguish well acdb format from acbd in case when channels = 1, thus, strides for b and d are same.\n It's also observed by verbose itself: src_u8::blocked:acbd:f0. So, indeed, there's a problem.\n \t\t"}}}, "commit": {"commit_id": "56b377e4d619e5ab64ec4b47ea0b59454290f3dc", "commit_author": "Dmitrii Zarukin", "commitT": "2019-12-02 16:39:28-08:00", "changed_files": {"file_0": {"file_change_type": "MODIFY", "file_Nmethod": 1, "file_old_name": "src\\common\\dnnl_debug.cpp", "file_new_name": "src\\common\\dnnl_debug.cpp", "hunks": {"hunk_0": {"Ismethod": 1, "added_lines": "77,78,79,84,89,90", "deleted_lines": "85", "method_info": {"method_name": "dnnl_md2fmt_str", "method_params": "str,str_len,mdesc", "method_startline": "37", "method_endline": "109"}}}}, "file_1": {"file_change_type": "MODIFY", "file_Nmethod": 1, "file_old_name": "src\\common\\type_helpers.hpp", "file_new_name": "src\\common\\type_helpers.hpp", "hunks": {"hunk_0": {"Ismethod": 1, "added_lines": "493,494,495,497,499,500,502", "deleted_lines": "494,497", "method_info": {"method_name": "dnnl::impl::memory_desc_init_by_blocking_desc", "method_params": "md,blk", "method_startline": "470", "method_endline": "515"}}}}, "file_2": {"file_change_type": "MODIFY", "file_Nmethod": 2, "file_old_name": "src\\common\\utils.hpp", "file_new_name": "src\\common\\utils.hpp", "hunks": {"hunk_0": {"Ismethod": 1, "added_lines": "248,249,256,257,258,259,260,262,263", "deleted_lines": "248,255,257", "method_info": {"method_name": "dnnl::impl::utils::simultaneous_sort", "method_params": "vals,keys,size,comparator", "method_startline": "248", "method_endline": "264"}}, "hunk_1": {"Ismethod": 1, "added_lines": "248,249,256,257,258,259,260,262,263", "deleted_lines": "248,255,257", "method_info": {"method_name": "dnnl::impl::utils::simultaneous_sort", "method_params": "vals,vals_2nd_level,keys,size,comparator", "method_startline": "248", "method_endline": "270"}}}}, "file_3": {"file_change_type": "MODIFY", "file_Nmethod": 1, "file_old_name": "src\\cpu\\simple_concat.hpp", "file_new_name": "src\\cpu\\simple_concat.hpp", "hunks": {"hunk_0": {"Ismethod": 1, "added_lines": "124,125,126,130,131,132,133,134,135,136,137,138", "deleted_lines": "126,127,129", "method_info": {"method_name": "dnnl::impl::cpu::simple_concat_t::pd_t::format_perm", "method_params": "", "method_startline": "120", "method_endline": "143"}}}}, "file_4": {"file_change_type": "MODIFY", "file_Nmethod": 1, "file_old_name": "tests\\benchdnn\\dnnl_common.cpp", "file_new_name": "tests\\benchdnn\\dnnl_common.cpp", "hunks": {"hunk_0": {"Ismethod": 1, "added_lines": "180,181,182,183,184,185,186,187", "deleted_lines": null, "method_info": {"method_name": "check_md_consistency_with_tag", "method_params": "md,tag", "method_startline": "180", "method_endline": "187"}}}}, "file_5": {"file_change_type": "MODIFY", "file_Nmethod": 0, "file_old_name": "tests\\benchdnn\\dnnl_common.hpp", "file_new_name": "tests\\benchdnn\\dnnl_common.hpp", "hunks": {"hunk_0": {"Ismethod": 0, "added_lines": "228,229,230", "deleted_lines": null}}}, "file_6": {"file_change_type": "MODIFY", "file_Nmethod": 1, "file_old_name": "tests\\benchdnn\\pool\\pool.cpp", "file_new_name": "tests\\benchdnn\\pool\\pool.cpp", "hunks": {"hunk_0": {"Ismethod": 1, "added_lines": "256,257", "deleted_lines": null, "method_info": {"method_name": "pool::doit", "method_params": "p,r", "method_startline": "227", "method_endline": "333"}}}}}}}