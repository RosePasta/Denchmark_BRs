{"BR": {"BR_id": "18218", "BR_author": "fracting", "BRopenT": "2019-03-20T11:50:36Z", "BRcloseT": "2019-05-31T01:38:51Z", "BR_text": {"BRsummary": "MKL-DNN causes wrong results on Xeon", "BRdescription": "\n Editorial note: We think this is an MKL-DNN bug. See <denchmark-link:https://github.com/oneapi-src/oneDNN/issues/431>oneapi-src/oneDNN#431</denchmark-link>\n \n <denchmark-h:hr></denchmark-h>\n \n Update: an updated test program to demo the problem is at <denchmark-link:https://github.com/pytorch/pytorch/issues/18218#issuecomment-475453948>#18218 (comment)</denchmark-link>\n \n --\n Hi, I have a simple python program as below:\n <denchmark-code>  1 import torch\n   2\n   3 #torch.set_flush_denormal(False)\n   4 torch.set_printoptions(profile=\"full\")\n   5 torch.set_printoptions(precision=65)\n   6\n   7 conv2 = torch.load(\"conv2.pth\")\n   8 print(\"haha conv2\")\n   9 for param in conv2.parameters():\n  10     print(param.size())\n  11     #print(param.data)\n  12\n  13 input = torch.load(\"input.pth\")\n  14 print(\"haha input\")\n  15 print(input[0].size())\n  16 #print(input[0])\n  17\n  18 output = conv2(input[0])\n  19 print(\"haha output\")\n  20 print(output.size())\n  21 print(output)\n </denchmark-code>\n \n I ran the same code (CPU only, no GPU) on different machines:\n machine A with Intel(R) Core(TM) i7-4870HQ CPU @ 2.50GHz\n machine B with Intel(R) Core(TM) i9-8950HK CPU @ 2.90GHz\n machine C with Intel(R) Xeon(R) Platinum 8124M CPU @ 3.00GHz\n While I was loading the same input.pth and the same conv2.pth, the output from machine C is difference with the other machines, the output from machine A are the same as the output from machine B. I tried the same docker image on different machines, so probably it's not a software problem.\n I don't have permission to call PTRACE_TRACEME on machine C, so ltrace wouldn't help in this case.\n Any one could tell me how do I know which low level C library function does pytorch call when computing conv2d?\n I tried objdump -T on libmkldnn.so.0 and set breakpoint on mkldnn_dilated_convolution_forward_desc_init  and mkldnn_convolution_forward_desc_init but it didn't stop, so probably I was guessing the wrong function.\n Any hints are greatly appreciated!\n \t"}, "comments": {"comments_0": {"comment_id": 1, "comment_author": "fracting", "commentT": "2019-03-20T11:57:09Z", "comment_text": "\n \t\t<denchmark-link:https://github.com/pytorch/pytorch/files/2987978/conv2_input.zip>conv2_input.zip</denchmark-link>\n \n Attached are the data files to reproduce this problem.\n <denchmark-code>$ md5 conv2.pth\n MD5 (conv2.pth) = 7ba2908fb86852affa164d77e97a037f\n $ md5 input.pth\n MD5 (input.pth) = 59b814700fa1dcbbca1f56bce568ba37\n </denchmark-code>\n \n Last few lines of good output are:\n <denchmark-code>1646785            -3.38981270790100097656250000000000000000000000000000000000000000000e+00,\n 1646786            -3.34102034568786621093750000000000000000000000000000000000000000000e+00,\n 1646787            -1.77292987704277038574218750000000000000000000000000000000000000000e-01]]]],\n 1646788        grad_fn=<MkldnnConvolutionBackward>)\n </denchmark-code>\n \n Last few lines of bad output are:\n <denchmark-code>1646785            -3.38981294631958007812500000000000000000000000000000000000000000000e+00,\n 1646786            -3.34102010726928710937500000000000000000000000000000000000000000000e+00,\n 1646787            -1.77292868494987487792968750000000000000000000000000000000000000000e-01]]]],\n 1646788        grad_fn=<MkldnnConvolutionBackward>)\n </denchmark-code>\n \n Note the first line in good snip ends with 56250000* while the first line in bad snip ends with 81250000*\n \t\t"}, "comments_1": {"comment_id": 2, "comment_author": "fracting", "commentT": "2019-03-20T13:56:37Z", "comment_text": "\n \t\tDifferent CPUs may use different conv algorithms. Also parallelized floating point arithmetic is not deterministic.\n \t\t"}, "comments_2": {"comment_id": 3, "comment_author": "fracting", "commentT": "2019-03-20T15:59:37Z", "comment_text": "\n \t\tas <denchmark-link:https://github.com/SsnL>@SsnL</denchmark-link>\n  said, they are the same to a particular machine precision. Beyond that, different CPU models, thread count, and other factors might give you different results (but same upto machine precision)\n \t\t"}, "comments_3": {"comment_id": 4, "comment_author": "fracting", "commentT": "2019-03-20T22:23:33Z", "comment_text": "\n \t\tThanks <denchmark-link:https://github.com/SsnL>@SsnL</denchmark-link>\n  and <denchmark-link:https://github.com/soumith>@soumith</denchmark-link>\n  , that was a very important lesson to learn!\n Could I ask a follow up question?\n We have a deep learning classification model (PyTorch) which predicts the same results for same validation set on 3 different machines, however its prediction on the Intel(R) Xeon(R) Platinum 8124M CPU @ 3.00GHz machine significantly bias to one category. For example, when all other machines outputs bedroom category, the Xeon machine outputs shop, when all other machines outputs backyard category, the Xeon machine still outputs shop.\n Do you have any suggestions how to track this kind of issue?\n Is there any well known floating number computation test suites which I can run on different machines and compare the result? Or is the PyTorch test suite useful for this kind of diagnosing?\n Thank you again!\n \t\t"}, "comments_4": {"comment_id": 5, "comment_author": "fracting", "commentT": "2019-03-21T05:13:09Z", "comment_text": "\n \t\t<denchmark-link:https://github.com/fracting>@fracting</denchmark-link>\n  It could be a problem with mkldnn. Could you try building from source w/o mkldnn and see if the xeon machine outputs a different prediction?\n \t\t"}, "comments_5": {"comment_id": 6, "comment_author": "fracting", "commentT": "2019-03-21T07:29:27Z", "comment_text": "\n \t\tHi <denchmark-link:https://github.com/SsnL>@SsnL</denchmark-link>\n \n Thanks for the hints! I compile PyTorch from scratch, either with or without mkldnn (by exporting USE_MKLDNN=\"FALSE\")\n I can confirm the model outputs bad prediction with mkldnn, but outputs good prediction without mkldnn. (Both on Xeon)\n \t\t"}, "comments_6": {"comment_id": 7, "comment_author": "fracting", "commentT": "2019-03-21T15:31:06Z", "comment_text": "\n \t\t<denchmark-link:https://github.com/soumith>@soumith</denchmark-link>\n  This is probably worth taking a look at.\n <denchmark-link:https://github.com/fracting>@fracting</denchmark-link>\n  Could you update the issue description to include your new findings? A more detailed approach to reproduce the problem using the network & weights would be great. Thanks!\n \t\t"}, "comments_7": {"comment_id": 8, "comment_author": "fracting", "commentT": "2019-03-21T16:34:30Z", "comment_text": "\n \t\tthis is high-priority, if there's any way to reproduce your issue, we will look and fix mkl-dnn.\n cc: <denchmark-link:https://github.com/mingfeima>@mingfeima</denchmark-link>\n \n \t\t"}, "comments_8": {"comment_id": 9, "comment_author": "fracting", "commentT": "2019-03-21T23:36:37Z", "comment_text": "\n \t\tcc <denchmark-link:https://github.com/jgong5>@jgong5</denchmark-link>\n \n \t\t"}, "comments_9": {"comment_id": 10, "comment_author": "fracting", "commentT": "2019-03-22T00:33:58Z", "comment_text": "\n \t\t<denchmark-link:https://github.com/soumith>@soumith</denchmark-link>\n  we will double check this immediately and reply to you soon.\n \t\t"}, "comments_10": {"comment_id": 11, "comment_author": "fracting", "commentT": "2019-03-22T00:39:58Z", "comment_text": "\n \t\t<denchmark-link:https://github.com/pytorch/pytorch/files/2994453/demo2.tar.gz>demo2.tar.gz</denchmark-link>\n \n Hi, I can reduce the problem with the attached demo code and data.\n The code loads a conv2 layer from conv2.pth, loads a demo input from input.pth, then computes the current output, comparing with output.i7.pth and output.xeon.pth\n <denchmark-code>.\n \u251c\u2500\u2500 conv2.pth\n \u251c\u2500\u2500 demo2.py\n \u251c\u2500\u2500 input.pth\n \u251c\u2500\u2500 output.i7.pth\n \u2514\u2500\u2500 output.xeon.pth\n \n $ python demo2.py\n </denchmark-code>\n \n According to my test, the cosine similarity between i7 output and xeon output is pretty low:\n <denchmark-code>tensor([[[ 2.350216172635555e-02,  1.297117769718170e-01,\n            1.381154656410217e-01,  6.210334133356810e-03,\n            3.263642266392708e-02,  1.101085636764765e-02,\n            2.132313139736652e-02,  5.432983487844467e-02,\n </denchmark-code>\n \n Env:\n Python3.6, with pytorch installed from latest conda\n Please let me know if you can reproduce. I'm glad to reduce it to C code if you can assist. Thanks!\n \t\t"}, "comments_11": {"comment_id": 12, "comment_author": "fracting", "commentT": "2019-03-22T00:56:58Z", "comment_text": "\n \t\t<denchmark-link:https://github.com/fracting>@fracting</denchmark-link>\n  i see your post on <denchmark-link:https://github.com/intel/mkl-dnn/issues/431>mkl-dnn</denchmark-link>\n  github, the info for me should be good enough to kick off debugging.\n I will let you know if i need additional info.\n \t\t"}, "comments_12": {"comment_id": 13, "comment_author": "fracting", "commentT": "2019-03-22T00:57:34Z", "comment_text": "\n \t\t<denchmark-link:https://github.com/fracting>@fracting</denchmark-link>\n   Between output.i7.pth and output.xeon.pth, both of them are processed on MKL-DNN?\n \t\t"}, "comments_13": {"comment_id": 14, "comment_author": "fracting", "commentT": "2019-03-22T01:00:04Z", "comment_text": "\n \t\t\n Hi, @Jianhui-Li , yes, both output.i7.pth and output.xeon.pth are computed with official conda pytorch package, which has MKL-DNN by default.\n Also torch._C.has_mkl are True on both environment.\n \n Update:\n Hi <denchmark-link:https://github.com/Jianhui-Li>@Jianhui-Li</denchmark-link>\n  , the output.i7.pth was from Mac OS X, which has  torch._C.has_mkl flag as True but I'm not confident if it is equivalent to the Linux version after reading\n <denchmark-link:https://github.com/oneapi-src/oneDNN/issues/10>oneapi-src/oneDNN#10</denchmark-link>\n \n I'll test on Linux and come back later.\n Update2:\n I can confirm output from my i7+OSX (host machine) is identical with output from my i7+Linux (docker container running on exactly the same host machine).\n Hi <denchmark-link:https://github.com/mingfeima>@mingfeima</denchmark-link>\n  thanks for working on it! Let me know what else info is needed.\n \t\t"}, "comments_14": {"comment_id": 15, "comment_author": "fracting", "commentT": "2019-05-31T01:38:48Z", "comment_text": "\n \t\tRetested on a Xeon machine with both pytorch-1.0.1 and pytorch-1.1.0 from official conda binary packages, confirming fixed in pytorch-1.1.0.\n <denchmark-code>$ cat /proc/cpuinfo | grep flags\n flags\t\t: fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush mmx fxsr sse sse2 ss ht syscall nx pdpe1gb rdtscp lm constant_tsc rep_good nopl xtopology nonstop_tsc aperfmperf pni pclmulqdq ssse3 fma cx16 pcid sse4_1 sse4_2 x2apic movbe popcnt tsc_deadline_timer aes xsave avx f16c rdrand hypervisor lahf_lm abm 3dnowprefetch invpcid_single kaiser fsgsbase tsc_adjust bmi1 hle avx2 smep bmi2 erms invpcid rtm mpx avx512f rdseed adx smap clflushopt clwb avx512cd xsaveopt xsavec xgetbv1 ida arat pku\n </denchmark-code>\n \n Closing the issue, thank you for all the great work!\n \t\t"}}}, "commit": {"commit_id": "d17aa723730d9d72d032983abedf54735d86e345", "commit_author": "Qian Hong", "commitT": "2019-05-30 11:36:07-07:00", "changed_files": {"file_0": {"file_change_type": "MODIFY", "file_Nmethod": 1, "file_old_name": "test\\test_nn.py", "file_new_name": "test\\test_nn.py", "hunks": {"hunk_0": {"Ismethod": 1, "added_lines": "4781,4782,4783,4784,4785,4786,4787,4788,4789,4790,4791,4792,4793,4794,4795,4796,4797,4798,4799,4800,4801,4802,4803,4804,4805,4806,4807,4808,4809,4810", "deleted_lines": null, "method_info": {"method_name": "test_Conv2d_groups_nobias_v2", "method_params": "self", "method_startline": "4781", "method_endline": "4810"}}}}}}}