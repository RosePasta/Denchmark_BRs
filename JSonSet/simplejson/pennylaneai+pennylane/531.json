{"BR": {"BR_id": "531", "BR_author": "josh146", "BRopenT": "2020-03-05T07:19:45Z", "BRcloseT": "2020-04-02T14:58:03Z", "BR_text": {"BRsummary": "`default.qubit`  returns analytic probabilities when `analytic=False`", "BRdescription": "\n Currently, when qml.probs() is returned from a QNode, the QubitDevice.probability() abstract method is returned directly to the user.\n For hardware-like devices that don't support analytic mode, this should behave as expected; the probability will be computed on the device by binning the generated computational basis samples.\n However, for analytic devices, such as default.qubit, care must be taken here. Currently, there is a bug in DefaultQubit.probability(), in that the analytic probability is always returned, regardless what the value of device.analytic is:\n def probability(self, wires=None):\n     if self._state is None:\n         return None\n \n     wires = wires or range(self.num_wires)\n     prob = self.marginal_prob(np.abs(self._state) ** 2, wires)\n     return prob\n This should be modified as follows:\n def probability(self, wires=None):\n     if self._state is None:\n         return None\n \n     wires = wires or range(self.num_wires)\n \n     if self.analytic:\n         prob = self.marginal_prob(np.abs(self._state) ** 2, wires)\n         return prob\n \n     # non-analytic mode, estimate the probability from the generated samples\n \n     # consider only the requested wires\n     wires = np.hstack(wires)\n     samples = self._samples[:, np.array(wires)]\n \n     # convert samples from a list of 0, 1 integers,\n     # to base 10 representation\n     unraveled_indices = [2] * len(wires)\n     indices = np.ravel_multi_index(samples.T, unraveled_indices)\n \n     # count the basis state occurrences, and construct\n     # the probability vector\n     basis_states, counts = np.unique(indices, return_counts=True)\n     prob = np.zeros([len(wires)**2], dtype=np.float64)\n     prob[basis_states] = counts/self.shots\n     return prob\n \t"}, "comments": {}}, "commit": {"commit_id": "c7ac33fa3996665a96cf2672d8482188211af097", "commit_author": "Theodor", "commitT": "2020-04-02 10:58:01-04:00", "changed_files": {"file_0": {"file_change_type": "MODIFY", "file_Nmethod": 0, "file_old_name": ".github\\CHANGELOG.md", "file_new_name": ".github\\CHANGELOG.md", "hunks": {"hunk_0": {"Ismethod": 0, "added_lines": "224,225,226,227,244", "deleted_lines": "240"}}}, "file_1": {"file_change_type": "MODIFY", "file_Nmethod": 1, "file_old_name": "pennylane\\_qubit_device.py", "file_new_name": "pennylane\\_qubit_device.py", "hunks": {"hunk_0": {"Ismethod": 1, "added_lines": "283,284,285,286,287,288,289,290,291", "deleted_lines": "283", "method_info": {"method_name": "generate_samples", "method_params": "self", "method_startline": "267", "method_endline": "293"}}}}, "file_2": {"file_change_type": "MODIFY", "file_Nmethod": 3, "file_old_name": "pennylane\\plugins\\default_qubit.py", "file_new_name": "pennylane\\plugins\\default_qubit.py", "hunks": {"hunk_0": {"Ismethod": 1, "added_lines": "253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269", "deleted_lines": null, "method_info": {"method_name": "estimate_probability", "method_params": "self,wires", "method_startline": "253", "method_endline": "269"}}, "hunk_1": {"Ismethod": 1, "added_lines": "243,244,249", "deleted_lines": "243", "method_info": {"method_name": "analytic_probability", "method_params": "self,wires", "method_startline": "243", "method_endline": "251"}}, "hunk_2": {"Ismethod": 1, "added_lines": "271,272,273,274,275,276,277", "deleted_lines": null, "method_info": {"method_name": "probability", "method_params": "self,wires", "method_startline": "271", "method_endline": "277"}}}}, "file_3": {"file_change_type": "MODIFY", "file_Nmethod": 1, "file_old_name": "tests\\conftest.py", "file_new_name": "tests\\conftest.py", "hunks": {"hunk_0": {"Ismethod": 1, "added_lines": "176,177,178,179,180,181,182,183,184", "deleted_lines": null, "method_info": {"method_name": "mock_qubit_device", "method_params": "monkeypatch", "method_startline": "176", "method_endline": "184"}}}}, "file_4": {"file_change_type": "MODIFY", "file_Nmethod": 5, "file_old_name": "tests\\test_default_qubit.py", "file_new_name": "tests\\test_default_qubit.py", "hunks": {"hunk_0": {"Ismethod": 1, "added_lines": "1624,1625,1626,1627,1628,1629,1630,1631,1632,1633,1634,1635,1636,1637,1638,1639,1640", "deleted_lines": null, "method_info": {"method_name": "test_probability", "method_params": "self,x,tol", "method_startline": "1624", "method_endline": "1640"}}, "hunk_1": {"Ismethod": 1, "added_lines": "1658,1659,1660,1661,1662,1663,1664,1665,1666,1667,1668,1669,1670,1671,1672", "deleted_lines": null, "method_info": {"method_name": "test_call_generate_samples_no_analytic_fn", "method_params": "self,analytic,mock_qubit_device,monkeypatch", "method_startline": "1658", "method_endline": "1672"}}, "hunk_2": {"Ismethod": 1, "added_lines": "1629,1630,1631,1632,1633", "deleted_lines": null, "method_info": {"method_name": "test_probability.circuit", "method_params": "x", "method_startline": "1629", "method_endline": "1633"}}, "hunk_3": {"Ismethod": 1, "added_lines": "1643,1644,1645,1646,1647,1648,1649,1650,1651,1652,1653,1654", "deleted_lines": null, "method_info": {"method_name": "test_call_generate_samples", "method_params": "self,analytic,monkeypatch", "method_startline": "1643", "method_endline": "1654"}}, "hunk_4": {"Ismethod": 1, "added_lines": "1619,1620,1621", "deleted_lines": null, "method_info": {"method_name": "mock_analytic_counter", "method_params": "self,wires", "method_startline": "1619", "method_endline": "1621"}}}}}}}