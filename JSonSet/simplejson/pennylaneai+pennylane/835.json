{"BR": {"BR_id": "835", "BR_author": "josh146", "BRopenT": "2020-10-01T13:53:50Z", "BRcloseT": "2020-10-09T04:01:05Z", "BR_text": {"BRsummary": "Applying operations in `default.qubit.tf` errors if the number of wires is 9 or larger", "BRdescription": "\n If the number of wires instantiated on  is larger than 9, circuit evaluation fails using the new, more efficient, apply implementation from <denchmark-link:https://github.com/PennyLaneAI/pennylane/pull/772>#772</denchmark-link>\n . For example:\n import pennylane as qml\n import tensorflow as tf\n import numpy as np\n \n n_wires = 9\n dev = qml.device(\"default.qubit.tf\", wires=n_wires)\n \n @qml.qnode(dev, interface=\"tf\")\n def circuit(weights, x=None):\n     qml.templates.embeddings.AngleEmbedding(x, wires=range(n_wires))\n     qml.templates.layers.StronglyEntanglingLayers(weights, range(n_wires))\n     return qml.expval(qml.PauliZ(0))\n \n weights = qml.init.strong_ent_layers_uniform(n_layers=2, n_wires=n_wires)\n weights = tf.Variable(weights)\n data = np.random.random(size=[n_wires])\n \n circuit(weights, x=data)\n Evaluating this circuit with n_wires=9 or larger results in the following error:\n <denchmark-code>  File \"pennylane/pennylane/devices/default_qubit.py\", line 288, in _apply_cnot\n     state_x = self._apply_x(state[sl_1], axes=target_axes)\n   File \"/usr/lib/python3.7/site-packages/tensorflow/python/util/dispatch.py\", line 201, in wrapper\n     return target(*args, **kwargs)\n   File \"/usr/lib/python3.7/site-packages/tensorflow/python/ops/array_ops.py\", line 1024, in _slice_helper\n     name=name)\n   File \"/usr/lib/python3.7/site-packages/tensorflow/python/util/dispatch.py\", line 201, in wrapper\n     return target(*args, **kwargs)\n   File \"/usr/lib/python3.7/site-packages/tensorflow/python/ops/array_ops.py\", line 1196, in strided_slice\n     shrink_axis_mask=shrink_axis_mask)\n   File \"/usr/lib/python3.7/site-packages/tensorflow/python/ops/gen_array_ops.py\", line 10320, in strided_slice\n     _ops.raise_from_not_ok_status(e, name)\n   File \"/usr/lib/python3.7/site-packages/tensorflow/python/framework/ops.py\", line 6843, in raise_from_not_ok_status\n     six.raise_from(core._status_to_exception(e.code, message), None)\n   File \"<string>\", line 3, in raise_from\n tensorflow.python.framework.errors_impl.UnimplementedError: Unhandled input dimensions 9 [Op:StridedSlice] name: strided_slice/\n </denchmark-code>\n \n This same bug is not observed with default.qubit or default.qubit.autograd.\n \t"}, "comments": {"comments_0": {"comment_id": 1, "comment_author": "josh146", "commentT": "2020-10-01T13:55:02Z", "comment_text": "\n \t\tA solution might be to simply override _apply_cnot() in default.qubit.tf to have it revert to the tensordot implementation. However, it might be worth understanding what is happening here, and if it affects any of the other new gate implementations.\n \t\t"}, "comments_1": {"comment_id": 2, "comment_author": "josh146", "commentT": "2020-10-02T14:16:57Z", "comment_text": "\n \t\tThe error seems to be related to the <denchmark-link:https://github.com/tensorflow/tensorflow/blob/8d9132b8bfacf51a28ac4e21a8c99ec0d5679929/tensorflow/core/kernels/strided_slice_op.cc#L173>code in TensorFlow for handling strides up to certain number of dimensions</denchmark-link>\n . The <denchmark-link:https://www.tensorflow.org/api_docs/python/tf/strided_slice?hl=zh-cn>tf.strided_slice</denchmark-link>\n  is being used when indexing into a Tensor with slices.\n a = np.ones([2]*8)\n \n b = tf.Variable(a, dtype=tf.complex128)\n c = tf.convert_to_tensor(b)\n slices = (slice(None, None, None), 1, slice(None, None, None), slice(None, None, None), slice(None, None, None), slice(None, None, None), slice(None, None, None), slice(None, None, None))\n print(len(slices))\n c[slices]\n Outputs similarly UnimplementedError: Unhandled input dimensions.\n a = np.ones([2]*7)\n \n b = tf.Variable(a, dtype=tf.complex128)\n c = tf.convert_to_tensor(b)\n slices = (1, slice(None, None, None), slice(None, None, None), slice(None, None, None), slice(None, None, None), slice(None, None, None), slice(None, None, None))\n print(len(slices))\n c[slices]\n Outputs the sliced tensor.\n \t\t"}, "comments_2": {"comment_id": 3, "comment_author": "josh146", "commentT": "2020-10-02T14:39:12Z", "comment_text": "\n \t\t Thanks for tracking this down <denchmark-link:https://github.com/antalszava>@antalszava</denchmark-link>\n , super cool that you found the source code!\n Since this affects _get_slice(), this likely also affects the CZ and the PhaseShift gates (although the CZ gate on default.qubit.tf is currently not using the faster implementation).\n While it would be nice to support the faster implementations of the CNOT and PhaseShift gates on default.qubit.tf, I had a look at the source code and this seems non-trivial. For now, we could just default to standard tensordot behaviour for these gates, by adding the following to the __init__.py:\n     def __init__(self, wires, *, shots=1000, analytic=True):\n         super().__init__(wires, shots=shots, analytic=analytic)\n \n         # prevent using special apply method for this gate due to slowdown in TF implementation\n         del self._apply_ops[\"CZ\"]\n \n         # prevent using special apply method for the following gates as TF strides only support a\n         # maximum of 9 dimensions\n         del self._apply_ops[\"CNOT\"]\n         del self._apply_ops[\"PhaseShift\"]\n \t\t"}}}, "commit": {"commit_id": "f82bf708dbbd98d030c8433cf82c058e84a8df4e", "commit_author": "Tom Bromley", "commitT": "2020-10-09 12:01:03+08:00", "changed_files": {"file_0": {"file_change_type": "MODIFY", "file_Nmethod": 1, "file_old_name": "pennylane\\devices\\default_qubit_tf.py", "file_new_name": "pennylane\\devices\\default_qubit_tf.py", "hunks": {"hunk_0": {"Ismethod": 1, "added_lines": "165,166,167,168,169,170", "deleted_lines": null, "method_info": {"method_name": "__init__", "method_params": "self,wires,shots,analytic", "method_startline": "159", "method_endline": "170"}}}}, "file_1": {"file_change_type": "MODIFY", "file_Nmethod": 3, "file_old_name": "tests\\devices\\test_default_qubit_tf.py", "file_new_name": "tests\\devices\\test_default_qubit_tf.py", "hunks": {"hunk_0": {"Ismethod": 1, "added_lines": "356,357,358,359,360,361,362,363", "deleted_lines": null, "method_info": {"method_name": "test_apply_ops_above_8_wires_using_special", "method_params": "self", "method_startline": "356", "method_endline": "363"}}, "hunk_1": {"Ismethod": 1, "added_lines": "338,339,340,341,342,343,344,345,346,347,348,349", "deleted_lines": null, "method_info": {"method_name": "test_apply_ops_above_8_wires", "method_params": "self,mocker", "method_startline": "338", "method_endline": "349"}}, "hunk_2": {"Ismethod": 1, "added_lines": "323,324,325,326,327,328,329,330,331,332,333,334,335,336", "deleted_lines": null, "method_info": {"method_name": "test_apply_ops_not_supported", "method_params": "self,mocker,monkeypatch", "method_startline": "323", "method_endline": "336"}}}}}}}