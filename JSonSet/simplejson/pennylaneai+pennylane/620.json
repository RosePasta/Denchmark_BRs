{"BR": {"BR_id": "620", "BR_author": "antalszava", "BRopenT": "2020-05-06T01:23:26Z", "BRcloseT": "2020-05-13T03:10:33Z", "BR_text": {"BRsummary": "PassthruQNode decomposition error with default.tensor.tf", "BRdescription": "\n <denchmark-h:h4>Issue description</denchmark-h>\n \n \n \n Expected behavior:\n Operations not supported by a device (e.g. U3 given default.tensor.tf) get decomposed well within a PassthruQNode without any problems.\n \n \n Actual behavior:\n An error is raised due to a check that gets executed:\n \n \n import pennylane as qml\n import numpy as np\n import tensorflow as tf\n \n from pennylane.qnodes import PassthruQNode\n \n theta = 0.543\n phi = -0.234\n lam = 0.654\n p = [theta, phi, lam]\n \n dev = qml.device(\"default.tensor.tf\", wires=1)\n \n def circuit(weights, w=None):\n     qml.U3(weights[0], weights[1], weights[2], wires=w)   # <--- decomposition is required\n     return qml.expval(qml.PauliX(w))\n \n node = PassthruQNode(circuit, dev, interface=\"tf\")\n \n params = tf.Variable(p, dtype=tf.float64)\n \n with tf.GradientTape() as tape:\n     tape.watch(params)\n     res = node(params, w=0)\n Produces:\n ~/pennylane/pennylane/operation.py in __init__(self, wires, do_queue, *params)\n     328         if self.do_check_domain:\n     329             for p in params:\n --> 330                 self.check_domain(p)\n     331         self.params = list(params)  #: list[Any]: parameters of the operator\n     332 \n \n ~/pennylane/pennylane/operation.py in check_domain(self, p, flattened)\n     425             if not isinstance(p, numbers.Real):\n     426                 raise TypeError(\n --> 427                     \"{}: Real scalar parameter expected, got {}.\".format(self.name, type(p))\n     428                 )\n     429 \n \n TypeError: Rot: Real scalar parameter expected, got <class 'tensorflow.python.framework.ops.EagerTensor'>.\n \n \n Reproduces how often:\n Each time a PassthruQNode is being used purely with TF using the default.tensor.tf device.\n \n \n System information: (post the output of import pennylane as qml; qml.about())\n \n \n Name: PennyLane\n Version: 0.9.0.dev0\n Summary: PennyLane is a Python quantum machine learning library by Xanadu Inc.\n Home-page: https://github.com/XanaduAI/pennylane\n Author: None\n Author-email: None\n License: Apache License 2.0\n Location: /pennylane\n Requires: numpy, scipy, networkx, autograd, toml, appdirs, semantic-version\n Required-by: \n Platform info:           Linux-4.19.11-041911-generic-x86_64-with-debian-buster-sid\n Python version:          3.7.6\n Numpy version:           1.18.1\n Scipy version:           1.4.1\n Installed devices:\n - microsoft.QuantumSimulator (PennyLane-qsharp-0.6.0)\n - cirq.simulator (PennyLane-Cirq-0.8.0)\n - forest.numpy_wavefunction (PennyLane-Forest-0.8.0)\n - forest.qpu (PennyLane-Forest-0.8.0)\n - forest.qvm (PennyLane-Forest-0.8.0)\n - forest.wavefunction (PennyLane-Forest-0.8.0)\n - qiskit.aer (PennyLane-qiskit-0.9.0.dev0)\n - qiskit.basicaer (PennyLane-qiskit-0.9.0.dev0)\n - qiskit.ibmq (PennyLane-qiskit-0.9.0.dev0)\n - projectq.classical (PennyLane-PQ-0.7.0.dev0)\n - projectq.ibm (PennyLane-PQ-0.7.0.dev0)\n - projectq.simulator (PennyLane-PQ-0.7.0.dev0)\n - default.gaussian (PennyLane-0.9.0.dev0)\n - default.qubit (PennyLane-0.9.0.dev0)\n - default.tensor (PennyLane-0.9.0.dev0)\n - default.tensor.tf (PennyLane-0.9.0.dev0)\n - strawberryfields.fock (PennyLane-SF-0.9.0.dev0)\n - strawberryfields.gaussian (PennyLane-SF-0.9.0.dev0)\n <denchmark-h:h4>Additional information</denchmark-h>\n \n Testing of the  differentiation method proposed in <denchmark-link:https://github.com/PennyLaneAI/pennylane/pull/552>#552</denchmark-link>\n  will slightly change once this issue is resolved. This PR works with gate decomposition due to the error.\n \t"}, "comments": {"comments_0": {"comment_id": 1, "comment_author": "antalszava", "commentT": "2020-05-06T03:43:09Z", "comment_text": "\n \t\tGood catch <denchmark-link:https://github.com/antalszava>@antalszava</denchmark-link>\n ! In the  class, we do some basic input validation of arguments. However, this won't work for PassthruQNodes, since they will no longer be using NumPy arrays/Python floats, but rather the default data structure for their target ML framework.\n In the PassthruQNode, operation validation is turned off explicitly within the construct method:\n def _construct(self, args, kwargs):\n     \"\"\"Construct the quantum circuit graph by calling the quantum function.\n \n     Like :class:`.BaseQNode._construct`, but does not use Variables.\n     \"\"\"\n     # temporary queues for operations and observables\n     self.queue = []  #: list[Operation]: applied operations\n     self.obs_queue = []  #: list[Observable]: applied observables\n \n     # set up the context for Operator entry\n     with self:\n         try:\n             # turn off domain checking since PassthruQNode qfuncs can take any class as input\n             pennylane.operation.Operator.do_check_domain = False\n             # generate the program queue by executing the quantum circuit function\n             res = self.func(*args, **kwargs)\n         finally:\n             pennylane.operation.Operator.do_check_domain = True\n My guess is that this seemingly doesn't propagate to decomposed operations, and it somehow gets turned on again?\n \t\t"}, "comments_1": {"comment_id": 2, "comment_author": "antalszava", "commentT": "2020-05-06T13:40:16Z", "comment_text": "\n \t\tI think I have found the cause. The operation decomposition is performed during the self._circuit_check method call. So this just needs to be moved to within the try: block:\n # set up the context for Operator entry\n with self:\n     try:\n         # turn off domain checking since PassthruQNode qfuncs can take any class as input\n         pennylane.operation.Operator.do_check_domain = False\n         # generate the program queue by executing the quantum circuit function\n         res = self.func(*args, **kwargs)\n         # check the validity of the circuit\n         self._check_circuit(res)\n     finally:\n         pennylane.operation.Operator.do_check_domain = True\n \n del self.queue\n del self.obs_queue\n \t\t"}, "comments_2": {"comment_id": 3, "comment_author": "antalszava", "commentT": "2020-05-06T14:52:06Z", "comment_text": "\n \t\tApplying this seems to result in another one for the same example:\n ~/pennylane/pennylane/_queuing_context.py in append_operator(cls, operator)\n      72         \"\"\"\n      73         for context in cls._active_contexts:\n ---> 74             context._append_operator(operator)  # pylint: disable=protected-access\n      75 \n      76     @abc.abstractmethod\n ~/pennylane/pennylane/qnodes/base.py in _append_operator(self, operator)\n     329             if self.obs_queue:\n     330                 raise QuantumFunctionError(\n --> 331                     \"State preparations and gates must precede measured observables.\"\n     332                 )\n     333             self.queue.append(operator)\n QuantumFunctionError: State preparations and gates must precede measured observables.\n This does not arise when using the decomposition explicitly.\n \t\t"}}}, "commit": {"commit_id": "178b772435e1f22e19afc8aa828d9221d20ad719", "commit_author": "antalszava", "commitT": "2020-05-12 22:14:36-04:00", "changed_files": {"file_0": {"file_change_type": "MODIFY", "file_Nmethod": 1, "file_old_name": "pennylane\\qnodes\\passthru.py", "file_new_name": "pennylane\\qnodes\\passthru.py", "hunks": {"hunk_0": {"Ismethod": 1, "added_lines": "109,110,111,112,121,122,123,124,125,126,127,128,129,130", "deleted_lines": "117,118", "method_info": {"method_name": "_construct", "method_params": "self,args,kwargs", "method_startline": "98", "method_endline": "147"}}}}, "file_1": {"file_change_type": "MODIFY", "file_Nmethod": 2, "file_old_name": "tests\\qnodes\\test_qnode_passthru.py", "file_new_name": "tests\\qnodes\\test_qnode_passthru.py", "hunks": {"hunk_0": {"Ismethod": 1, "added_lines": "169,170,171,172", "deleted_lines": null, "method_info": {"method_name": "test_circuit_with_decomposition.circuit", "method_params": "weights", "method_startline": "169", "method_endline": "172"}}, "hunk_1": {"Ismethod": 1, "added_lines": "159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183", "deleted_lines": null, "method_info": {"method_name": "test_circuit_with_decomposition", "method_params": "self,tol", "method_startline": "159", "method_endline": "183"}}}}}}}