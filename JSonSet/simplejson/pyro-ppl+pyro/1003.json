{"BR": {"BR_id": "1003", "BR_author": "fritzo", "BRopenT": "2018-04-11T01:30:52Z", "BRcloseT": "2018-04-12T23:57:52Z", "BR_text": {"BRsummary": "poutine.block is thwarted by _DIM_ALLOCATOR global state", "BRdescription": "\n <denchmark-h:h2>Desired behavior</denchmark-h>\n \n Any submodel can be run inside a Pyro model by using poutine.block. These submodels should have no side effects.\n <denchmark-h:h2>Actual behavior</denchmark-h>\n \n Submodels may modify the . This is problematic in composite ADVI where two ADVI strategies gather different traces which allocate duplicate dimensions for a shared iarange. See <denchmark-link:https://github.com/pyro-ppl/pyro/pull/1002>#1002</denchmark-link>\n  .\n \t"}, "comments": {"comments_0": {"comment_id": 1, "comment_author": "fritzo", "commentT": "2018-04-11T01:32:53Z", "comment_text": "\n \t\t<denchmark-link:https://github.com/eb8680>@eb8680</denchmark-link>\n  I've gotten myself into a mess of side effects here. Can you help me get out?\n \t\t"}, "comments_1": {"comment_id": 2, "comment_author": "fritzo", "commentT": "2018-04-11T02:01:14Z", "comment_text": "\n \t\tHmm it turns out our issue was unrelated, but we saw tests failing due to _DIM_ALLOCATOR global state that had been left dirty by previous failing tests. Not sure whether this issue is really a bug...\n \t\t"}, "comments_2": {"comment_id": 3, "comment_author": "fritzo", "commentT": "2018-04-11T04:27:59Z", "comment_text": "\n \t\t\n we saw tests failing due to _DIM_ALLOCATOR global state that had been left dirty by previous failing tests.\n \n Strange, this should be handled by iarange.__exit__.  I thought I knew what was causing this but I think I was wrong, I'll investigate further.\n \t\t"}, "comments_3": {"comment_id": 4, "comment_author": "fritzo", "commentT": "2018-04-11T04:48:11Z", "comment_text": "\n \t\tTo give more context: _DIM_ALLOCATOR was left in a dirty state after an error occurred inside the iarange.__enter__() method. Here is the stack trace that led to the dirty state:\n \n ______________________________________________ test_discrete_parallel[ADVIMultivariateNormal] ______________________________________________\n \n continuous_class = <class 'pyro.infer.advi.ADVIMultivariateNormal'>\n \n     @pytest.mark.parametrize(\"continuous_class\", [ADVIMultivariateNormal, ADVIDiagonalNormal])\n     def test_discrete_parallel(continuous_class):\n         K = 2\n         data = torch.tensor([0., 1., 10., 11., 12.])\n \n         def model(data):\n             weights = pyro.sample('weights', dist.Dirichlet(0.5 * torch.ones(K)))\n             locs = pyro.sample('locs', dist.Normal(0, 10).reshape([K]))\n             scale = pyro.sample('scale', dist.LogNormal(0, 1))\n \n             with pyro.iarange('data'):\n                 weights = weights.expand(torch.Size((len(data),)) + weights.shape)\n                 assignment = pyro.sample('assignment', dist.Categorical(weights))\n                 pyro.sample('obs', dist.Normal(locs[assignment], scale), obs=data)\n \n         advi = ADVIMaster(model)\n         advi.add(ADVIDiscreteParallel(poutine.block(model, expose=[\"assignment\"])))\n         advi.add(continuous_class(poutine.block(model, hide=[\"assignment\"])))\n         advi.setup_prototype(data)\n \n         elbo = ELBO.make(enum_discrete=True)\n >       loss = elbo.loss_and_grads(advi.model, advi.guide, data)\n \n tests/infer/test_advi.py:125:\n _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n pyro/infer/traceenum_elbo.py:113: in loss_and_grads\n     for model_trace, guide_trace in self._get_traces(model, guide, *args, **kwargs):\n pyro/infer/traceenum_elbo.py:61: in _get_traces\n     for guide_trace in iter_discrete_traces(\"flat\", guide, *args, **kwargs):\n pyro/infer/enum.py:48: in iter_discrete_traces\n     yield traced_fn.get_trace(*args, **kwargs)\n pyro/poutine/trace_poutine.py:182: in get_trace\n     self(*args, **kwargs)\n pyro/poutine/trace_poutine.py:170: in __call__\n     ret = super(TracePoutine, self).__call__(*args, **kwargs)\n pyro/poutine/poutine.py:147: in __call__\n     return self.fn(*args, **kwargs)\n pyro/poutine/__init__.py:218: in _fn\n     return ftr(*args, **kwargs)\n pyro/poutine/trace_poutine.py:170: in __call__\n     ret = super(TracePoutine, self).__call__(*args, **kwargs)\n pyro/poutine/poutine.py:147: in __call__\n     return self.fn(*args, **kwargs)\n pyro/poutine/poutine.py:147: in __call__\n     return self.fn(*args, **kwargs)\n pyro/poutine/poutine.py:147: in __call__\n     return self.fn(*args, **kwargs)\n pyro/poutine/poutine.py:147: in __call__\n     return self.fn(*args, **kwargs)\n pyro/infer/advi.py:74: in guide\n     part.guide(*args, **kwargs)\n pyro/infer/advi.py:417: in guide\n     stack.enter_context(iaranges[frame.name])\n ../../../miniconda2/envs/pytorch-dev/lib/python2.7/site-packages/contextlib2.py:380: in enter_context\n     result = _cm_type.__enter__(cm)\n _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n \n self = <pyro.iarange object at 0x107be9210>\n \n     def __enter__(self):\n         self._wrapped = am_i_wrapped()\n         self.dim = _DIM_ALLOCATOR.allocate(self.name, self.dim)\n         if self._wrapped:\n >           self._scale_poutine = poutine.ScaleMessenger(self.size / self.subsample_size)\n E           ZeroDivisionError: division by zero\n \n pyro/__init__.py:251: ZeroDivisionError\n \n \n \t\t"}, "comments_4": {"comment_id": 5, "comment_author": "fritzo", "commentT": "2018-04-11T07:36:32Z", "comment_text": "\n \t\tSeems like the solution is to wrap the rest of iarange.__enter__ in a try/except and call _DIM_ALLOCATOR.free before propagating the exception further.\n \t\t"}}}, "commit": {"commit_id": "243ee2f9f6de9f3cd11e65e3ad9736977a7d4cc8", "commit_author": "Fritz Obermeyer", "commitT": "2018-04-12 16:57:51-07:00", "changed_files": {"file_0": {"file_change_type": "MODIFY", "file_Nmethod": 1, "file_old_name": "pyro\\__init__.py", "file_new_name": "pyro\\__init__.py", "hunks": {"hunk_0": {"Ismethod": 1, "added_lines": "251,252,253,254,255,256,257,258", "deleted_lines": "251,252,253,254", "method_info": {"method_name": "__enter__", "method_params": "self", "method_startline": "247", "method_endline": "259"}}}}, "file_1": {"file_change_type": "MODIFY", "file_Nmethod": 2, "file_old_name": "tests\\poutine\\test_poutines.py", "file_new_name": "tests\\poutine\\test_poutines.py", "hunks": {"hunk_0": {"Ismethod": 1, "added_lines": "675,676,677,678,679,680,681,682,683", "deleted_lines": null, "method_info": {"method_name": "test_iarange_error_on_enter", "method_params": "", "method_startline": "675", "method_endline": "683"}}, "hunk_1": {"Ismethod": 1, "added_lines": "676,677,678", "deleted_lines": null, "method_info": {"method_name": "test_iarange_error_on_enter.model", "method_params": "", "method_startline": "676", "method_endline": "678"}}}}}}}