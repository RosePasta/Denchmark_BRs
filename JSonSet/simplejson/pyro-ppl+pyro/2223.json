{"BR": {"BR_id": "2223", "BR_author": "lsgos", "BRopenT": "2019-12-11T18:51:31Z", "BRcloseT": "2019-12-22T17:42:55Z", "BR_text": {"BRsummary": "Undocumented restrictions on discrete inference?", "BRdescription": "\n <denchmark-h:h2>Weird behaviour in discrete inference with shared mixture weights</denchmark-h>\n \n pyro version - 1.1.0 (and earlier)\n Consider the following pyro model, defining a mixture of gaussians\n K = 5\n d = 2\n N_obs = 100\n @infer.config_enumerate\n def model(N=1):\n     with pyro.plate('data_plate', N, dim=-2):\n         mixing_weights = pyro.param('pi', th.ones(K) / K, constraint=constraints.simplex)\n         means = pyro.sample('mu', D.Normal(th.zeros(K, d), th.ones(K, d)).to_event(2))\n     \n         with pyro.plate('observations', N_obs, dim=-1):\n             s = pyro.sample('s', D.Categorical(mixing_weights))\n \n             x = pyro.sample('x', D.Normal(I.Vindex(means)[..., s, :], 0.1).to_event(1))\n This can be enumerated, and works fine. In particular, gradients flow to the mixing weights variable, as can be checked with the following snippet\n pyro.clear_param_store()\n conditioned_model = pyro.condition(model, data={'x': x})\n guide = infer.autoguide.AutoDelta(poutine.block(conditioned_model, hide=['s']))\n \n elbo = infer.TraceEnum_ELBO(max_plate_nesting=2)\n opt = pyro.optim.Adam({'lr': 1e-2})\n svi = infer.SVI(conditioned_model, guide, opt, elbo)\n # probably need \n losses = []\n for i in range(1000):\n     l = svi.step(x.size(0))\n     if i % 100 == 0: \n         print(i, l)\n         elbo.loss_and_grads(conditioned_model, guide, x.size(0))\n         print(pyro.get_param_store()._params['pi'].grad)\n     losses.append(l)\n Now, if we add another random variable after x that depends on the same mixture component, everything breaks\n pyro.clear_param_store()\n \n K = 5\n d = 2\n N_obs = 100\n @infer.config_enumerate\n def model(N=1):\n     with pyro.plate('data_plate', N, dim=-2):\n         mixing_weights = pyro.param('pi', th.ones(K) / K, constraint=constraints.simplex)\n         means = pyro.sample('mu', D.Normal(th.zeros(K, d), th.ones(K, d)).to_event(2))\n     \n         with pyro.plate('observations', N_obs, dim=-1):\n             s = pyro.sample('s', D.Categorical(mixing_weights))\n \n             x = pyro.sample('x', D.Normal(I.Vindex(means)[..., s, :], 0.1).to_event(1))\n             # this line breaks stuff\n             y = pyro.sample('y', D.Normal(I.Vindex(means)[..., s, :], 0.1).to_event(1))\n Now, running the above snippet will show no gradient passing back to the mixing weights. The fitted means are also nonsense.\n In probabalistic terms I think this is certainly wrong, since I think y should simply marginalise out and have no effect on the rest of the model.\n But this doesn't seem to break any of the restrictions detailed <denchmark-link:http://pyro.ai/examples/enumeration.html#Restriction-1:-conditional-independence>here</denchmark-link>\n  - y does not introduce cross-plate coupling, and it is within the plate where s is enumerated, and it doesn't break the 'single path' restriction because it isn't discrete.\n I'm pretty sure (though not certain) that this behaviour is not correct in probabilistic terms, and results from some kind of bug or undocumented assumption in the enumeration code.\n \t"}, "comments": {"comments_0": {"comment_id": 1, "comment_author": "lsgos", "commentT": "2019-12-12T18:20:49Z", "comment_text": "\n \t\tHi <denchmark-link:https://github.com/lsgos>@lsgos</denchmark-link>\n , your model looks good. My first guess is that, while  indeed marginalizes out, it introduces high-variance zero-mean noise into the optimization process and thereby breaks learning. One way you could test this hypothesis would be to wrap the  site in a \n with poutine.scale(scale=1e-6):\n     y = pyro.sample('y', ...)\n Then train on fixed data for each of scales in [1e-6,1e-5,...,1e-1,1]. If my hypothesis is correct then the model should learn correct (or to make things easy, identical) mixing weights for all scales, but convergence time will be a quickly growing function of scale. You could plot on a single figure loss curves for each of the scales; if my hypothesis is correct you would see convergence to the same ELBO loss but taking longer and longer as scale increases.\n \t\t"}, "comments_1": {"comment_id": 2, "comment_author": "lsgos", "commentT": "2019-12-12T22:25:59Z", "comment_text": "\n \t\tSo I don't think that this is right - this doesn't explain the fact that no gradient passes back to the mixing weights, when it certainly should (print(pyro.get_param_store()._params['pi'].grad) prints None in my example snippet above). In fact at the end of training the mixing weights will be whatever they were initialised as, even if you scale y such that the effect should be imperceptible (i.e scale=1e-12). I think the lack of gradients is a sign of a deeper problem -  I can try and do a bit more digging through the mechanics of traceenum_elbo to see what is going on in more detail when I have some time if that's helpful?\n Everything seems to start behaving more as expected if you condition on y, by the way.\n \t\t"}, "comments_2": {"comment_id": 3, "comment_author": "lsgos", "commentT": "2019-12-12T22:37:13Z", "comment_text": "\n \t\t<denchmark-link:https://user-images.githubusercontent.com/20584660/70754646-9a037980-1cec-11ea-9395-7d8193af0ab6.png></denchmark-link>\n \n If it helps, here is a graph showing the scale of the elbo with and without the nuisance variable y. Kinda difficult to intepret this but it certainly seems like the models are converging to totally different objectives. But these curves are quite smooth so it doesn't seem like it's because of gradient noise\n \t\t"}, "comments_3": {"comment_id": 4, "comment_author": "lsgos", "commentT": "2019-12-12T23:31:29Z", "comment_text": "\n \t\tGood debugging, that indeed looks like a bug! Let me know what you find. Ideally we could add your .grad is not None check as a unit test in Pyro; if you submit a PR with the failing test I'd help out with debugging.\n \t\t"}, "comments_4": {"comment_id": 5, "comment_author": "lsgos", "commentT": "2019-12-14T00:25:55Z", "comment_text": "\n \t\tOK, after i'm home from neurips I'll try to write up the test and make a pull request, and then we can try to see what is going on\n \t\t"}, "comments_5": {"comment_id": 6, "comment_author": "lsgos", "commentT": "2019-12-22T17:42:54Z", "comment_text": "\n \t\tThink this issue should have been resolved by <denchmark-link:https://github.com/pyro-ppl/pyro/pull/2226>#2226</denchmark-link>\n  being merged so closing\n \t\t"}}}, "commit": {"commit_id": "2aaf8fcc38340474d21477af0afaa58db7cc07f3", "commit_author": "lsgos", "commitT": "2019-12-20 15:05:58-08:00", "changed_files": {"file_0": {"file_change_type": "MODIFY", "file_Nmethod": 1, "file_old_name": "pyro\\infer\\traceenum_elbo.py", "file_new_name": "pyro\\infer\\traceenum_elbo.py", "hunks": {"hunk_0": {"Ismethod": 1, "added_lines": "101", "deleted_lines": "101", "method_info": {"method_name": "_compute_model_factors", "method_params": "model_trace,guide_trace", "method_startline": "84", "method_endline": "142"}}}}, "file_1": {"file_change_type": "MODIFY", "file_Nmethod": 2, "file_old_name": "tests\\infer\\test_enum.py", "file_new_name": "tests\\infer\\test_enum.py", "hunks": {"hunk_0": {"Ismethod": 1, "added_lines": "3266,3267,3268,3269,3270,3271,3272,3273,3274,3275", "deleted_lines": null, "method_info": {"method_name": "test_multi_dependence_enumeration.model", "method_params": "N", "method_startline": "3266", "method_endline": "3275"}}, "hunk_1": {"Ismethod": 1, "added_lines": "3254,3255,3256,3257,3258,3259,3260,3261,3262,3263,3264,3265,3266,3267,3268,3269,3270,3271,3272,3273,3274,3275,3276,3277,3278,3279,3280,3281,3282,3283,3284,3285,3286", "deleted_lines": null, "method_info": {"method_name": "test_multi_dependence_enumeration", "method_params": "", "method_startline": "3254", "method_endline": "3286"}}}}}}}