{"BR": {"BR_id": "3071", "BR_author": "slevental", "BRopenT": "2020-02-22T00:55:15Z", "BRcloseT": "2020-02-25T18:43:11Z", "BR_text": {"BRsummary": "Using Java library with DNNL", "BRdescription": "\n Describe the bug\n I've compiled java jar with options:\n ./build.sh --use_dnnl --use_openmp  --build_java --parallel --config RelWithDebInfo\n At the end, I've used onnxruntime4j-1.1.0-with-binaries.jar in my java application; but after trying some of the benchmarks and analyzing model exec with profiler I've noticed that DNNL is not in the call stack and MLAS is used instead;\n I've found an option:\n <denchmark-code>var opts = new OrtSession.SessionOptions()\n opts.addDnnl(true);\n </denchmark-code>\n \n which gives me an error:\n <denchmark-code>ai.onnxruntime.OrtException: Error code - ORT_INVALID_ARGUMENT - message: This binary was not compiled with DNNL support.\n \tat ai.onnxruntime.OrtSession$SessionOptions.addDnnl(Native Method)\n </denchmark-code>\n \n Is this the way of turning DNNL in java env or I'm doing something wrong?\n Urgency\n Actually this blocks an integration of ONNX runtime into one of our production services;\n System information\n \n OS Platform and Distribution (e.g., Linux Ubuntu 16.04): macOS\n ONNX Runtime installed from (source or binary): source\n ONNX Runtime version: 1.1.0\n Python version: 3.7\n Visual Studio version (if applicable): n/a\n GCC/Compiler version (if compiling from source): clang Apple LLVM version 10.0.1 (clang-1001.0.46.4)\n CUDA/cuDNN version: n/a\n GPU model and memory: n/a\n \n To Reproduce\n see above\n \t"}, "comments": {"comments_0": {"comment_id": 1, "comment_author": "slevental", "commentT": "2020-02-22T01:10:16Z", "comment_text": "\n \t\tIt's a bug.\n <denchmark-code>if (onnxruntime_USE_DNNL)\n   target_compile_definitions(onnxruntime_pybind11_state PRIVATE USE_DNNL=1)\n endif()\n </denchmark-code>\n \n We need to have the similar thing on the jni project.\n \t\t"}, "comments_1": {"comment_id": 2, "comment_author": "slevental", "commentT": "2020-02-23T20:07:54Z", "comment_text": "\n \t\t<denchmark-link:https://github.com/slevental>@slevental</denchmark-link>\n  As the developer on MLAS, I'm curious about the model architecture used here where DNNL is faster than the out of box experience with MLAS. Let me know if you'd be willing to share any info about the model to help improve MLAS.\n \t\t"}, "comments_2": {"comment_id": 3, "comment_author": "slevental", "commentT": "2020-02-24T19:32:42Z", "comment_text": "\n \t\t<denchmark-link:https://github.com/tracysh>@tracysh</denchmark-link>\n  model that we are using is Seq2Seq with LSTM encoder/decoder; I'm not sure that DNNL is faster - I'm trying to conduct a comparison using java but it seems that DNNL doesn't work there; If you have any benchmarks on MLAS vs DNNL for LSTM-RNN - I would appreciate it; also interesting to hear what CPU optimizations are possible for these model architectures; I was thinking about quantization to INT8 for instance\n \t\t"}, "comments_3": {"comment_id": 4, "comment_author": "slevental", "commentT": "2020-02-24T19:59:42Z", "comment_text": "\n \t\t<denchmark-link:https://github.com/slevental>@slevental</denchmark-link>\n  if you checkout the branch referenced in my PR (<denchmark-link:https://github.com/microsoft/onnxruntime/pull/3082>#3082</denchmark-link>\n ) you can build the Java package with DNNL support.\n \t\t"}, "comments_4": {"comment_id": 5, "comment_author": "slevental", "commentT": "2020-02-25T03:28:35Z", "comment_text": "\n \t\t<denchmark-link:https://github.com/snnn>@snnn</denchmark-link>\n  now when I'm doing the same build using the most recent master (as well as using the PR you had sent) I'm constantly getting an error on a linking stage:\n <denchmark-code>Undefined symbols for architecture x86_64:\n   \"onnxruntime::CreateExecutionProviderFactory_Dnnl(int)\", referenced from:\n       onnxruntime::test::DefaultDnnlExecutionProvider(bool) in libonnxruntime_test_utils.a(default_providers.cc.o)\n ld: symbol(s) not found for architecture x86_64\n clang: error: linker command failed with exit code 1 (use -v to see invocation)\n make[2]: *** [onnxruntime_test_all] Error 1\n </denchmark-code>\n \n Not sure what's the reason. It seems that CI is working, but I'm curious if CI contains --build_java  with --use_dnnl\n \t\t"}, "comments_5": {"comment_id": 6, "comment_author": "slevental", "commentT": "2020-02-25T17:02:37Z", "comment_text": "\n \t\tI've upgraded cmake and re-cloned everything; and the problem went away - not sure what was the reason; I had to do this first, before submitting a comment, sorry for bothering;\n \t\t"}, "comments_6": {"comment_id": 7, "comment_author": "slevental", "commentT": "2020-02-25T18:43:11Z", "comment_text": "\n \t\tThank you for confirming.\n \t\t"}, "comments_7": {"comment_id": 8, "comment_author": "slevental", "commentT": "2020-10-27T21:39:25Z", "comment_text": "\n \t\tI'm also getting a link error:\n <denchmark-code>java.lang.UnsatisfiedLinkError at InferenceTest.java:1295\n </denchmark-code>\n \n when using both --build_java and --use_dnnl, building from master on Ubuntu 20.04 / gcc-9.\n <denchmark-link:https://github.com/Craigacp>@Craigacp</denchmark-link>\n  would you mind looking into it?\n \t\t"}, "comments_8": {"comment_id": 9, "comment_author": "slevental", "commentT": "2020-10-27T21:59:44Z", "comment_text": "\n \t\tWhat library is the link error coming out of? And what does ldd output for the two so files that should be packaged into the jar?\n \t\t"}, "comments_9": {"comment_id": 10, "comment_author": "slevental", "commentT": "2020-10-27T23:03:57Z", "comment_text": "\n \t\tFull error is:\n <denchmark-code>  <failure message=\"java.lang.UnsatisfiedLinkError: /tmp/onnxruntime-java4622990253883325212/libonnxruntime.so: /snap/core18/current/lib/x86_64-linux-gnu/libm.so.6: version `GLIBC_2.29' not found (required by /tmp/onnxruntime-java4622990253883325212/libonnxruntime.so)\" type=\"java.lang.UnsatisfiedLinkError\">java.lang.UnsatisfiedLinkError: /tmp/onnxruntime-java4622990253883325212/libonnxruntime.so: /snap/core18/current/lib/x86_64-linux-gnu/libm.so.6: version `GLIBC_2.29' not found (required by /tmp/onnxruntime-java4622990253883325212/libonnxruntime.so)\n </denchmark-code>\n \n My glibc version is 2.31. Should be ok, no?\n \t\t"}, "comments_10": {"comment_id": 11, "comment_author": "slevental", "commentT": "2020-10-28T00:08:48Z", "comment_text": "\n \t\tldd output:\n <denchmark-code>$ ldd libonnxruntime.so \n \tlinux-vdso.so.1 (0x00007ffc37f07000)\n \tlibdl.so.2 => /lib/x86_64-linux-gnu/libdl.so.2 (0x00007f5e75e8e000)\n \tlibpthread.so.0 => /lib/x86_64-linux-gnu/libpthread.so.0 (0x00007f5e75e6b000)\n \tlibstdc++.so.6 => /lib/x86_64-linux-gnu/libstdc++.so.6 (0x00007f5e75c8a000)\n \tlibm.so.6 => /lib/x86_64-linux-gnu/libm.so.6 (0x00007f5e75b3b000)\n \tlibgcc_s.so.1 => /lib/x86_64-linux-gnu/libgcc_s.so.1 (0x00007f5e75b20000)\n \tlibc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007f5e7592c000)\n \t/lib64/ld-linux-x86-64.so.2 (0x00007f5e7687e000)\n </denchmark-code>\n \n and\n <denchmark-code>$ ldd libonnxruntime4j_jni.so \n \tlinux-vdso.so.1 (0x00007fff3aff9000)\n \tlibonnxruntime.so.1.5.2 => /home/selvelrel/dev/onnxruntime/build/Linux/RelWithDebInfo/libonnxruntime.so.1.5.2 (0x00007f15ae204000)\n \tlibc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007f15adffb000)\n \tlibdl.so.2 => /lib/x86_64-linux-gnu/libdl.so.2 (0x00007f15adff5000)\n \tlibpthread.so.0 => /lib/x86_64-linux-gnu/libpthread.so.0 (0x00007f15adfd2000)\n \tlibstdc++.so.6 => /lib/x86_64-linux-gnu/libstdc++.so.6 (0x00007f15addf1000)\n \tlibm.so.6 => /lib/x86_64-linux-gnu/libm.so.6 (0x00007f15adca0000)\n \tlibgcc_s.so.1 => /lib/x86_64-linux-gnu/libgcc_s.so.1 (0x00007f15adc85000)\n \t/lib64/ld-linux-x86-64.so.2 (0x00007f15aebe5000)\n </denchmark-code>\n \n \t\t"}, "comments_11": {"comment_id": 12, "comment_author": "slevental", "commentT": "2020-10-28T01:45:36Z", "comment_text": "\n \t\tWhy is ldd pulling things out of /lib/ and the libm failure is happening inside a snap? Do you have a custom library path (or is the onnx runtime being packaged inside a snap)?\n I'll try to replicate this tomorrow.\n Edit: seems like it might be snap related, there are a bunch of other issues with similar glibc errors -<denchmark-link:https://bugs.launchpad.net/snapcraft/+bug/1889409>https://bugs.launchpad.net/snapcraft/+bug/1889409</denchmark-link>\n . The snap maintainers note that it's usually an issue with the snap packaging, but as onnx runtime isn't a snap I'm not sure how snap gets involved.\n \t\t"}, "comments_12": {"comment_id": 13, "comment_author": "slevental", "commentT": "2020-10-28T13:36:04Z", "comment_text": "\n \t\tahh, I see. No need to try to replicate, thanks.\n I'm not usually a gradle user, nor snap. The standard version in the Ubuntu repos didn't meet your recommended version, so I tried snapping it, thought it would be smart enough to jive with apt, guess not. Clearly there is a version conflict going on, I'll clean things up.\n \t\t"}, "comments_13": {"comment_id": 14, "comment_author": "slevental", "commentT": "2020-10-28T15:59:43Z", "comment_text": "\n \t\tOk. We can look into it if it turns out to be an issue somewhere in ORT.\n \t\t"}, "comments_14": {"comment_id": 15, "comment_author": "slevental", "commentT": "2020-10-28T16:35:29Z", "comment_text": "\n \t\tbuild & test works now. Noticed the dnnl lib is still not packed in, but with some path magic I was able to test the DNNL provider, thanks.\n \t\t"}, "comments_15": {"comment_id": 16, "comment_author": "slevental", "commentT": "2020-10-28T16:55:00Z", "comment_text": "\n \t\tYeah, nobody checked the Java packaging when they broke DNNL out into a separate shared library. I only noticed that had happened yesterday when I started to dig into this. <denchmark-link:https://github.com/faxu>@faxu</denchmark-link>\n  is there a way we can get the Java API added to the list of things that people check when they make shared library packaging changes? I noticed that Python and nuget got updated, but I didn't know about it and no-one in MS checked that the Java packaging would include the necessary extra shared library to make DNNL work.\n \t\t"}}}, "commit": {"commit_id": "b23b7f0fea6c12d149d1825f49b78ababd61eabf", "commit_author": "Adam Pocock", "commitT": "2020-02-24 15:47:26-08:00", "changed_files": {"file_0": {"file_change_type": "MODIFY", "file_Nmethod": 0, "file_old_name": "cmake\\onnxruntime_java.cmake", "file_new_name": "cmake\\onnxruntime_java.cmake", "hunks": {"hunk_0": {"Ismethod": 0, "added_lines": "53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,96", "deleted_lines": "72"}}}, "file_1": {"file_change_type": "MODIFY", "file_Nmethod": 0, "file_old_name": "java\\README.md", "file_new_name": "java\\README.md", "hunks": {"hunk_0": {"Ismethod": 0, "added_lines": "36,37,38,39,43,44,45", "deleted_lines": "36,37,38,39,43,44,45"}}}, "file_2": {"file_change_type": "MODIFY", "file_Nmethod": 0, "file_old_name": "java\\build.gradle", "file_new_name": "java\\build.gradle", "hunks": {"hunk_0": {"Ismethod": 0, "added_lines": "42,43", "deleted_lines": null}}}}}}