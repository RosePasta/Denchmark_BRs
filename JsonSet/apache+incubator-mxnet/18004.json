{"BR": {"BR_id": "18004", "BR_author": "hgt312", "BRopenT": "2020-04-09T18:44:41Z", "BRcloseT": "2020-05-15T22:37:05Z", "BR_text": {"BRsummary": "Wrong result when using new numpy ffi in deferred compute", "BRdescription": "\n Find it in CI result of <denchmark-link:https://github.com/apache/incubator-mxnet/pull/17958>#17958</denchmark-link>\n .\n <denchmark-h:h2>Reproduce:</denchmark-h>\n \n Sample code, use master branch\n import mxnet as mx\n import mxnet._deferred_compute as dc\n from mxnet import np, npx\n npx.set_np()\n with dc.context():\n     a = np.ones((2, 2))\n     b = np.tril(a, 1)\n     c = np.tril(a, -1)\n \n sym = dc.get_symbol([b, c], sym_cls=mx.sym.np._Symbol)\n res = sym.bind(mx.context.current_context(), args={}).forward()\n res\n Results:\n <denchmark-code>[\n [[1. 1.]\n  [1. 1.]]\n <NDArray 2x2 @cpu(0)>,\n [[1. 1.]\n  [1. 1.]]\n <NDArray 2x2 @cpu(0)>]\n </denchmark-code>\n \n If replace _api_internal.tril by _npi.tril, the result is right.\n <denchmark-link:https://github.com/leezu>@leezu</denchmark-link>\n  Can you take a look at this?\n \t"}, "comments": {"comments_0": {"comment_id": 1, "comment_author": "hgt312", "commentT": "2020-04-09T19:07:50Z", "comment_text": "\n \t\t<denchmark-link:https://github.com/hzfan>@hzfan</denchmark-link>\n \n \t\t"}, "comments_1": {"comment_id": 2, "comment_author": "hgt312", "commentT": "2020-04-09T21:52:15Z", "comment_text": "\n \t\tThanks for reporting the issue. I can confirm that disabling the new FFI for tril via below patch avoids the issue. I'll take a look why the two FFIs behave differently\n diff --git a/python/mxnet/ndarray/numpy/_op.py b/python/mxnet/ndarray/numpy/_op.py\n index 4820f56f3..8ff7ba073 100644\n --- a/python/mxnet/ndarray/numpy/_op.py\n +++ b/python/mxnet/ndarray/numpy/_op.py\n @@ -2051,7 +2051,7 @@ def tril(m, k=0):\n             [ 7.,  8.,  0.],\n             [10., 11., 12.]])\n      \"\"\"\n -    return _api_internal.tril(m, k)\n +    return _npi.tril(m, k)\n \n \n  def _unary_func_helper(x, fn_array, fn_scalar, out=None, **kwargs):\n \t\t"}, "comments_2": {"comment_id": 3, "comment_author": "hgt312", "commentT": "2020-04-17T03:48:46Z", "comment_text": "\n \t\t<denchmark-link:https://github.com/leezu>@leezu</denchmark-link>\n  Have you been able to find the root cause for this bug?\n \t\t"}, "comments_3": {"comment_id": 4, "comment_author": "hgt312", "commentT": "2020-04-19T03:55:07Z", "comment_text": "\n \t\t<denchmark-link:https://github.com/haojin2>@haojin2</denchmark-link>\n  sorry, I didn't get to dive deep on this issue yet. I'll work on this during our bug bash in the coming week.\n \t\t"}, "comments_4": {"comment_id": 5, "comment_author": "hgt312", "commentT": "2020-05-12T01:07:00Z", "comment_text": "\n \t\tIt's due to common expression elimination. As workaround one could set MXNET_ELIMINATE_COMMON_EXPR=0.\n \n \n \n incubator-mxnet/src/executor/eliminate_common_expr_pass.cc\n \n \n         Lines 59 to 94\n       in\n       ab4f7f6\n \n \n \n \n \n \n  /*! \n \n \n \n   * \\brief Determine if two Nodes have equal function such that one Node can be eliminated. \n \n \n \n   */ \n \n \n \n  bool NodeEqual(const Node* n, const Node* m) { \n \n \n \n  if (n->is_variable() || m->is_variable()) return false; \n \n \n \n  if (n->op() != m->op()) return false; \n \n \n \n  // Nodes with different attributes are considered not identical, \n \n \n \n  // though this may reject Node pairs that are in fact functionally the same. \n \n \n \n  if (n->attrs.dict != m->attrs.dict) return false; \n \n \n \n  \n \n \n \n  // Ops that mutate inputs cannot be optimized out \n \n \n \n  static auto& fmutate_inputs = Op::GetAttr<nnvm::FMutateInputs>(\"FMutateInputs\"); \n \n \n \n  if (fmutate_inputs.get(n->op(), nullptr) != nullptr) return false; \n \n \n \n  \n \n \n \n  // Stateful ops cannot be be equal to each other \n \n \n \n  static auto& fstateful = Op::GetAttr<FCreateOpState>(\"FCreateOpState\"); \n \n \n \n  if (fstateful.get(n->op(), nullptr) != nullptr) \n \n \n \n  return false; \n \n \n \n  \n \n \n \n  // Check to see if the user has explicitly set THasDeterministicOutput to override the \n \n \n \n  // subsequent determination of Node equality based on resource use. \n \n \n \n  static auto& deterministic_output = \n \n \n \n        Op::GetAttr<THasDeterministicOutput>(\"THasDeterministicOutput\"); \n \n \n \n  if (deterministic_output.contains(n->op())) \n \n \n \n  return deterministic_output[n->op()]; \n \n \n \n  \n \n \n \n  // Ops that require resource could ask for \n \n \n \n  // random resource, so need to be explicitly marked \n \n \n \n  // to be eligible \n \n \n \n  static auto& resource_request = Op::GetAttr<FResourceRequest>(\"FResourceRequest\"); \n \n \n \n  static auto& resource_request_ex = Op::GetAttr<FResourceRequestEx>(\"FResourceRequestEx\"); \n \n \n \n  if (resource_request.get(n->op(), nullptr) != nullptr) return false; \n \n \n \n  if (resource_request_ex.get(n->op(), nullptr) != nullptr) return false; \n \n \n \n  \n \n \n \n  return true; \n \n \n \n  } \n \n \n \n \n \n For the old FFI, n->attrs.dict != m->attrs.dict and the two nodes are preserved.\n But in the new FFI, n->attrs.dict == m->attrs.dict and the np.tril(a, -1) is replaced by np.tril(a, 1).\n For the new FFI, the reason is\n \n \n \n incubator-mxnet/src/api/operator/utils.h\n \n \n         Lines 52 to 57\n       in\n       7bef85e\n \n \n \n \n \n \n  template<typename T> \n \n \n \n  void SetAttrDict(nnvm::NodeAttrs* attrs) { \n \n \n \n  if (is_recording()) { \n \n \n \n      ::dmlc::get<T>(attrs->parsed).SetAttrDict(&(attrs->dict)); \n \n \n \n    } \n \n \n \n  } \n \n \n \n \n \n only parses attributes if autograd is enabled, whereas the old FFI always parses attributes. This was an oversight when I rebased the DC PR on top of the FFI update PR.\n \t\t"}}}, "commit": {"commit_id": "37280e4ddf00cacdac50c1e798fd2a14da38ae8d", "commit_author": "Leonard Lausen", "commitT": "2020-05-15 15:36:55-07:00", "changed_files": {"file_0": {"file_change_type": "MODIFY", "file_Nmethod": 2, "file_old_name": "src\\api\\operator\\utils.cc", "file_new_name": "src\\api\\operator\\utils.cc", "hunks": {"hunk_0": {"Ismethod": 1, "added_lines": "33,34,35", "deleted_lines": null, "method_info": {"method_name": "mxnet::is_deferred_compute", "method_params": "", "method_startline": "33", "method_endline": "35"}}, "hunk_1": {"Ismethod": 1, "added_lines": "101", "deleted_lines": "97", "method_info": {"method_name": "mxnet::Invoke", "method_params": "op,attrs,num_inputs,inputs,num_outputs,outputs", "method_startline": "80", "method_endline": "107"}}}}, "file_1": {"file_change_type": "MODIFY", "file_Nmethod": 1, "file_old_name": "src\\api\\operator\\utils.h", "file_new_name": "src\\api\\operator\\utils.h", "hunks": {"hunk_0": {"Ismethod": 1, "added_lines": "55", "deleted_lines": "54", "method_info": {"method_name": "mxnet::SetAttrDict", "method_params": "attrs", "method_startline": "54", "method_endline": "58"}}}}, "file_2": {"file_change_type": "MODIFY", "file_Nmethod": 2, "file_old_name": "tests\\python\\unittest\\test_deferred_compute.py", "file_new_name": "tests\\python\\unittest\\test_deferred_compute.py", "hunks": {"hunk_0": {"Ismethod": 1, "added_lines": "166,167,168,169,170,171", "deleted_lines": null, "method_info": {"method_name": "test_dc_numpy_tril.f", "method_params": "a,nd", "method_startline": "166", "method_endline": "171"}}, "hunk_1": {"Ismethod": 1, "added_lines": "165,166,167,168,169,170,171,172,173,174", "deleted_lines": null, "method_info": {"method_name": "test_dc_numpy_tril", "method_params": "", "method_startline": "165", "method_endline": "174"}}}}}}}