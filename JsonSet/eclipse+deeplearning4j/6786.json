{"BR": {"BR_id": "6786", "BR_author": "printomi", "BRopenT": "2018-11-28T15:58:49Z", "BRcloseT": "2018-12-14T02:52:34Z", "BR_text": {"BRsummary": "KFoldIterator calculates incorrect batch sizes", "BRdescription": "\n KfoldIterator calculates incorrect batch and lastBatch sizes. The later can be non-positive (lastBatch<=0). E.g.: Number of examples in allData N = 13, number of folds k = 6, then the current implementation calculates that batch = 3 and lastBatch = -2, which is obviously not what we wanted.\n Current constructor looks like this:\n public KFoldIterator(int k, DataSet allData) {\n \tthis.k = k;\n \tthis.allData = allData.copy();\n \tif (k <= 1)\n \t\tthrow new IllegalArgumentException();\n \tif (allData.numExamples() % k != 0) {\n \t\tthis.batch = (int)Math.ceil(allData.numExamples() / (double)k);\n \t\tthis.lastBatch = allData.numExamples() - (k-1) * this.batch;\n \t} else {\n \t\tthis.batch = allData.numExamples() / k;\n \t\tthis.lastBatch = allData.numExamples() / k;\n \t}\n }\n My suggested implementation is the following:\n public KFoldIterator(int k, DataSet allData) {\n \tthis.k = k;\n \tthis.allData = allData.copy();\n \tif (k <= 1) {\n \t\tthrow new IllegalArgumentException();\n \t}\n \tthis.batch = allData.numExamples() / k;\n \tthis.lastBatch = batch + allData.numExamples() % k;\n }\n My implementation would give batch = 2 and lastBatch = 3 in the above example.\n I have not tried your test (deeplearning4j/deeplearning4j/pull/5993), but I have made a simple test class that passes with my implementation, and fails with the current one. My test tries every possible k numbers from 2 to N, and sums number of test examples in the folds.\n import static org.junit.Assert.*;\n import org.junit.Test;\n import org.nd4j.linalg.api.ndarray.INDArray;\n import org.nd4j.linalg.dataset.DataSet;\n import org.nd4j.linalg.factory.Nd4j;\n \n import org.nd4j.linalg.dataset.api.iterator.KFoldIterator;\n \n public class KFoldIteratorTest {\n \n \tprivate static final int NUM_EXAMPLES = 13;\n \tprivate static final int NUM_FEATURES = 3;\n \t\n \t@Test\n \tpublic void testTestFold() {\n \t\tINDArray features = Nd4j.rand(new int[] {NUM_EXAMPLES, NUM_FEATURES});\n \t\tINDArray labels = Nd4j.ones(NUM_EXAMPLES, 1);\n \t\tDataSet dataSet = new DataSet(features, labels);\n \t\t\n \t\tfor (int k = 2; k <= NUM_EXAMPLES; k++) {\n \t\t\tKFoldIterator kFoldIterator = new KFoldIterator(k, dataSet);\n \t\t\tint numTestExamples = 0;\n \t\t\tfor (int i = 0; i < k; i++) {\n \t\t\t\tkFoldIterator.next();\n \t\t\t\tnumTestExamples += kFoldIterator.testFold().numExamples();\n \t\t\t}\n \t\t\tassertEquals(NUM_EXAMPLES, numTestExamples);\n \t\t}\n \t}\n \t\n }\n The above test of KFoldIterator (version 1.0.0-beta3) fails with the following exception stack trace:\n <denchmark-code>java.lang.IllegalArgumentException: Beginning index (15) in range must be less than or equal to end (13)\n \tat org.nd4j.base.Preconditions.throwEx(Preconditions.java:636)\n \tat org.nd4j.base.Preconditions.checkArgument(Preconditions.java:110)\n \tat org.nd4j.linalg.indexing.NDArrayIndex.interval(NDArrayIndex.java:666)\n \tat org.nd4j.linalg.indexing.NDArrayIndex.interval(NDArrayIndex.java:698)\n \tat org.nd4j.linalg.dataset.DataSet.getRange(DataSet.java:237)\n \tat org.nd4j.linalg.dataset.api.iterator.KFoldIterator.nextFold(KFoldIterator.java:188)\n \tat org.nd4j.linalg.dataset.api.iterator.KFoldIterator.next(KFoldIterator.java:158)\n \tat hu.printnet.anne.node.task.impl.KFoldIteratorTest.testTestFold(KFoldIteratorTest.java:28)\n \tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n \tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n \tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n \tat java.lang.reflect.Method.invoke(Method.java:498)\n \tat org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)\n \tat org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)\n \tat org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)\n \tat org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)\n \tat org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)\n \tat org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)\n \tat org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)\n \tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)\n \tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)\n \tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)\n \tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)\n \tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)\n \tat org.junit.runners.ParentRunner.run(ParentRunner.java:363)\n \tat org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:86)\n \tat org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)\n \tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:459)\n \tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:678)\n \tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:382)\n \tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:192)\n </denchmark-code>\n \n \t"}, "comments": {"comments_0": {"comment_id": 1, "comment_author": "printomi", "commentT": "2018-11-29T00:00:00Z", "comment_text": "\n \t\t<denchmark-link:https://github.com/printomi>@printomi</denchmark-link>\n  What wersion of DL4J/ND4J are you using?\n This looks like an issue that was fixed a few releases ago.\n Maybe try upgrading to 1.0.0-beta3 and try again?\n \t\t"}, "comments_1": {"comment_id": 2, "comment_author": "printomi", "commentT": "2018-11-29T07:31:11Z", "comment_text": "\n \t\t<denchmark-link:https://github.com/AlexDBlack>@AlexDBlack</denchmark-link>\n  I use 1.0.0-beta3 version of ND4J and DL4J. The KFoldIterator constructor that I quoted above is from <denchmark-link:https://github.com/deeplearning4j/deeplearning4j/blob/release/1.0.0-beta3/nd4j/nd4j-backends/nd4j-api-parent/nd4j-api/src/main/java/org/nd4j/linalg/dataset/api/iterator/KFoldIterator.java>here</denchmark-link>\n \n The problem with the current implementation is that in case of allData.numExamples() % k != 0 i.e. (N mod k) > 0, the size of the first k-1 batch is larger by one, and the last batch size is calculated from this, which can result in 0 or negative batch size in the last batch.\n The correct approach would be to use always the integer part (floor) of N / k for the first k-1 batch, and use N / k + (N mod k) for the last batch. This way, we can eliminate an if clause from the current implementation.\n \t\t"}, "comments_2": {"comment_id": 3, "comment_author": "printomi", "commentT": "2018-11-30T08:11:09Z", "comment_text": "\n \t\tThe following equations may make my approach more easy to understood:\n N = allData.numExamples()\n N = k*(N / k) + (N % k)\n N = (k-1)*(N / k) + (N / k) + (N % k)\n batch=N / k\n lastBatch=(N / k) + (N % k)\n where N / k is the quotient, and N % k is the remainder (modulo) of the division\n \t\t"}, "comments_3": {"comment_id": 4, "comment_author": "printomi", "commentT": "2018-12-04T00:25:35Z", "comment_text": "\n \t\tHello <denchmark-link:https://github.com/printomi>@printomi</denchmark-link>\n  , Thanks for creating the issue, you clearly put a lot of effort in it which we appreciate. I was able to reproduce the failing test. The new implementation passes this test so would be an improvement.\n However all the <denchmark-link:https://github.com/deeplearning4j/deeplearning4j/blob/master/nd4j/nd4j-backends/nd4j-tests/src/test/java/org/nd4j/linalg/dataset/KFoldIteratorTest.java>existing tests</denchmark-link>\n  fail with the new implementation.\n Please have a look at those. Then we can work on doing a pull request to improve the KFoldIterator.\n \t\t"}, "comments_4": {"comment_id": 5, "comment_author": "printomi", "commentT": "2018-12-05T14:21:51Z", "comment_text": "\n \t\tI reviewed the <denchmark-link:https://github.com/deeplearning4j/deeplearning4j/blob/master/nd4j/nd4j-backends/nd4j-tests/src/test/java/org/nd4j/linalg/dataset/KFoldIteratorTest.java>existing tests</denchmark-link>\n , and found some problems:\n \n \n The test checkFolds() has a problem with the following line: https://github.com/deeplearning4j/deeplearning4j/blob/d9f8836dd64e3346906a50ff0d4cdfd21a30f37d/nd4j/nd4j-backends/nd4j-tests/src/test/java/org/nd4j/linalg/dataset/KFoldIteratorTest.java#L42\n On this line, a RandomDataSet is created, which will consist of preset sized (3, 3, 3, 2) folds, resulting in\n 3+3+3+2=11 examples in the next line: https://github.com/deeplearning4j/deeplearning4j/blob/d9f8836dd64e3346906a50ff0d4cdfd21a30f37d/nd4j/nd4j-backends/nd4j-tests/src/test/java/org/nd4j/linalg/dataset/KFoldIteratorTest.java#L43\n Then, it creates a KFoldIterator with k = 4: https://github.com/deeplearning4j/deeplearning4j/blob/d9f8836dd64e3346906a50ff0d4cdfd21a30f37d/nd4j/nd4j-backends/nd4j-tests/src/test/java/org/nd4j/linalg/dataset/KFoldIteratorTest.java#L44\n Here is the difference, which causes this test to fail:\n \n the current implementation will calculate batch = 3 and lastBatch = 2\n https://github.com/deeplearning4j/deeplearning4j/blob/41f220fbc2410efe71d535f8344f74e11ea8a44a/nd4j/nd4j-backends/nd4j-api-parent/nd4j-api/src/main/java/org/nd4j/linalg/dataset/api/iterator/KFoldIterator.java#L58\n my proposed implementation would calculate batch = 2 and lastBatch = 5 (see code in my first comment)\n So I would replace the line creating randomDS with the following:\n RandomDataSet randomDS = new RandomDataSet(new int[] {2, 3}, new int[] {2, 2, 2, 5});\n \n \n \n For the same reason, I would replace the following line of checkCornerCaseA() https://github.com/deeplearning4j/deeplearning4j/blob/d9f8836dd64e3346906a50ff0d4cdfd21a30f37d/nd4j/nd4j-backends/nd4j-tests/src/test/java/org/nd4j/linalg/dataset/KFoldIteratorTest.java#L89 with the following code:\n  RandomDataSet randomDS = new RandomDataSet(new int[] {2, 3}, new int[] {1, 2});\n \n \n For the same reason, test5974() will have to be modified to the following:\n \n \n     @Test\n     public void test5974(){\n         int N = 99;\n         int k = 10;\n         DataSet ds = new DataSet(Nd4j.linspace(1,N,N).transpose(), Nd4j.linspace(1,N,N).transpose());\n \n         KFoldIterator iter = new KFoldIterator(k, ds);\n \n         int count = 0;\n         while(iter.hasNext()){\n             DataSet fold = iter.next();\n             INDArray testFold;\n             int countTrain;\n             int rem = N % k;\n             if(count < k-1){\n                 //Folds 0 to 8: should have 9 examples for test (N=99,k=10)\n                 testFold = Nd4j.linspace(rem*count+1, rem*count+rem, k).transpose();\n                 countTrain = N - rem;\n             } else {\n                 //Fold 9 should have 18 examples for test (N=99,k=10)\n                 int lastBatch = N-(k-1)*rem;\n                 testFold = Nd4j.linspace(rem*count+1, rem*count+lastBatch, lastBatch).transpose();\n                 countTrain = N - lastBatch;\n             }\n             String s = String.valueOf(count);\n             DataSet test = iter.testFold();\n             assertEquals(s, testFold, test.getFeatures());\n             assertEquals(s, testFold, test.getLabels());\n             assertEquals(s, countTrain, fold.getFeatures().length());\n             assertEquals(s, countTrain, fold.getLabels().length());\n             count++;\n         }\n     }\n I created an Excel worksheet camparing the batch sizes of two implementations: <denchmark-link:https://github.com/deeplearning4j/deeplearning4j/files/2648988/KFoldIterator_batch_sizes.xlsx>KFoldIterator_batch_sizes.xlsx</denchmark-link>\n \n TL-DR: the current implementation's batch sizes are hard-coded in the current unit tests (by <denchmark-link:https://github.com/eraly>@eraly</denchmark-link>\n  ). That's why they all fail with my proposed implementation of .\n \t\t"}, "comments_5": {"comment_id": 6, "comment_author": "printomi", "commentT": "2018-12-05T23:52:57Z", "comment_text": "\n \t\tWell, that is an impressive effort.Thanks again. Would you submit a Pull Request for KFoldIterator.java and\n KFoldIteratorTest.java ? You can ping us here if you need any help.\n \t\t"}, "comments_6": {"comment_id": 7, "comment_author": "printomi", "commentT": "2018-12-06T14:24:04Z", "comment_text": "\n \t\tI will be happy to create a Pull Request. However, I was not satisfied with my previously proposed implementation, because of the large differences of batch sizes in case of . For example, with  = 11 and  = 6,  = 1 and  = 6.\n I found a better implementation <denchmark-link:https://github.com/scikit-learn/scikit-learn/blob/55bf5d93e5674f13a1134d93a11fd0cd11aabcd1/sklearn/model_selection/_split.py#L438>in scikit-learn</denchmark-link>\n , which sets the size of every batch to  , and then increments the size of the first  batches by 1. This way, the difference between batch sizes will be at most 1, which is a good news, if we expect that the cross-validation would consist of similar sized training and test sets.\n We can implement this with this  constructor and  method:\n // new fields\n private int N;\n private int baseBatchSize;\n private int numIncrementedBatches;\n /* ... */\n // modified constructor\n public KFoldIterator(int k, DataSet allData) {\n     if (k <= 1) {\n         throw new IllegalArgumentException();\n     }\n     this.k = k;\n     this.N = allData.numExamples();\n     this.baseBatchSize = N / k;\n     this.numIncrementedBatches = N % k;\n     this.allData = allData.copy();\n }\n /* ... */\n private void nextFold() {\n     int left;\n     int right;\n     if (kCursor < numIncrementedBatches) {\n         left = kCursor * (baseBatchSize + 1);\n         right = left + (baseBatchSize + 1);\n     } else {\n         left = rem * (baseBatchSize + 1) + (kCursor - numIncrementedBatches) * baseBatchSize;\n         right = left + rem;\n     }\n \n     List<DataSet> kMinusOneFoldList = new ArrayList<DataSet>();\n     if (right < totalExamples()) {\n         if (left > 0) {\n             kMinusOneFoldList.add((DataSet) allData.getRange(0, left));\n         }\n         kMinusOneFoldList.add((DataSet) allData.getRange(right, totalExamples()));\n         train = DataSet.merge(kMinusOneFoldList);\n     } else {\n         train = (DataSet) allData.getRange(0, left);\n     }\n     test = (DataSet) allData.getRange(left, right);\n \n     kCursor++;\n \n }\n We will then have to modify the tests also.\n \t\t"}, "comments_7": {"comment_id": 8, "comment_author": "printomi", "commentT": "2018-12-06T23:44:21Z", "comment_text": "\n \t\tLooks good. Lets take the conversation to the PR.  No point copying and pasting code here. I am not closing this issue yet as I am not sure if WIP Pull Requests are the way to go. We will find out quickly if we are not supposed to.\n \t\t"}, "comments_8": {"comment_id": 9, "comment_author": "printomi", "commentT": "2019-01-13T05:40:36Z", "comment_text": "\n \t\tThis thread has been automatically locked since there has not been any recent activity after it was closed. Please open a new issue for related bugs.\n \t\t"}}}, "commit": {"commit_id": "4670eee4f25cef84afca2ba2e2ebf46577968308", "commit_author": "Tam\u00e1s Fenyvesi", "commitT": "2018-12-14 11:52:33+09:00", "changed_files": {"file_0": {"file_change_type": "MODIFY", "file_Nmethod": 5, "file_old_name": "nd4j\\nd4j-backends\\nd4j-api-parent\\nd4j-api\\src\\main\\java\\org\\nd4j\\linalg\\dataset\\api\\iterator\\KFoldIterator.java", "file_new_name": "nd4j\\nd4j-backends\\nd4j-api-parent\\nd4j-api\\src\\main\\java\\org\\nd4j\\linalg\\dataset\\api\\iterator\\KFoldIterator.java", "hunks": {"hunk_0": {"Ismethod": 1, "added_lines": "144", "deleted_lines": null, "method_info": {"method_name": "KFoldIterator::batch", "method_params": "", "method_startline": "143", "method_endline": "145"}}, "hunk_1": {"Ismethod": 1, "added_lines": "98", "deleted_lines": null, "method_info": {"method_name": "KFoldIterator::totalExamples", "method_params": "", "method_startline": "97", "method_endline": "99"}}, "hunk_2": {"Ismethod": 1, "added_lines": "178,179,180", "deleted_lines": null, "method_info": {"method_name": "KFoldIterator::nextFold", "method_params": "", "method_startline": "178", "method_endline": "196"}}, "hunk_3": {"Ismethod": 1, "added_lines": null, "deleted_lines": "132,133", "method_info": {"method_name": "KFoldIterator::lastBatch", "method_params": "", "method_startline": "132", "method_endline": "134"}}, "hunk_4": {"Ismethod": 1, "added_lines": "64,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84", "deleted_lines": "77,78", "method_info": {"method_name": "KFoldIterator::KFoldIterator", "method_params": "k,allData", "method_startline": "63", "method_endline": "85"}}}}, "file_1": {"file_change_type": "MODIFY", "file_Nmethod": 14, "file_old_name": "nd4j\\nd4j-backends\\nd4j-tests\\src\\test\\java\\org\\nd4j\\linalg\\dataset\\KFoldIteratorTest.java", "file_new_name": "nd4j\\nd4j-backends\\nd4j-tests\\src\\test\\java\\org\\nd4j\\linalg\\dataset\\KFoldIteratorTest.java", "hunks": {"hunk_0": {"Ismethod": 1, "added_lines": "165,168,169,170,171,172,174,176,177,178,179,180,181,183,184,186,187,190", "deleted_lines": "166,169,172,175,176,179,186,191", "method_info": {"method_name": "KFoldIteratorTest::KBatchRandomDataSet::KBatchRandomDataSet", "method_params": "dataShape,batchSizes", "method_startline": "165", "method_endline": "191"}}, "hunk_1": {"Ismethod": 1, "added_lines": "121,122,123,130,131,133,134,135,136,142,143,144,145,146,147,148,149", "deleted_lines": "121,124,125,126,127,128,129,131,132,134,135,136,137,138,139,141,142,144,145,148", "method_info": {"method_name": "KFoldIteratorTest::RandomDataSet::RandomDataSet", "method_params": "dataShape,ks", "method_startline": "121", "method_endline": "149"}}, "hunk_2": {"Ismethod": 1, "added_lines": "160,161,162,163,164,165,168,169,170,171,172", "deleted_lines": "159,160,162,166,169,172", "method_info": {"method_name": "KFoldIteratorTest::RandomDataSet::getFoldbutk", "method_params": "k,feat", "method_startline": "159", "method_endline": "173"}}, "hunk_3": {"Ismethod": 1, "added_lines": "110,111,112,113,114,115", "deleted_lines": "113,114,115", "method_info": {"method_name": "KFoldIteratorTest::checkCornerCaseException", "method_params": "", "method_startline": "110", "method_endline": "116"}}, "hunk_4": {"Ismethod": 1, "added_lines": "119,120,121,122,123,130,131,133,134,135,136", "deleted_lines": "119,121,124,125,126,127,128,129,131,132,134,135,136,137,138,139", "method_info": {"method_name": "KFoldIteratorTest::checkCornerCase", "method_params": "", "method_startline": "119", "method_endline": "140"}}, "hunk_5": {"Ismethod": 1, "added_lines": "157", "deleted_lines": "155,156", "method_info": {"method_name": "KFoldIteratorTest::RandomDataSet::getfoldK", "method_params": "k,feat", "method_startline": "155", "method_endline": "157"}}, "hunk_6": {"Ismethod": 1, "added_lines": "84,85,86,87,94,96,99,100,101,102", "deleted_lines": "83,84,86,89,90,91,98,99,101,102,104", "method_info": {"method_name": "KFoldIteratorTest::checkFolds", "method_params": "", "method_startline": "83", "method_endline": "106"}}, "hunk_7": {"Ismethod": 1, "added_lines": "51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79", "deleted_lines": "51,53,56,57,59,63,64,65,66,67,68,69,70,71,72,73,74,76,77,78,79", "method_info": {"method_name": "KFoldIteratorTest::checkTestFoldContent", "method_params": "", "method_startline": "51", "method_endline": "79"}}, "hunk_8": {"Ismethod": 1, "added_lines": "211,212,214,218,221,224", "deleted_lines": null, "method_info": {"method_name": "KFoldIteratorTest::KBatchRandomDataSet::getBatchButK", "method_params": "k,feat", "method_startline": "211", "method_endline": "225"}}, "hunk_9": {"Ismethod": 1, "added_lines": "193,194", "deleted_lines": "195", "method_info": {"method_name": "KFoldIteratorTest::KBatchRandomDataSet::getAllBatches", "method_params": "", "method_startline": "193", "method_endline": "195"}}, "hunk_10": {"Ismethod": 1, "added_lines": "202,203", "deleted_lines": null, "method_info": {"method_name": "KFoldIteratorTest::KBatchRandomDataSet::getBatchK", "method_params": "k,feat", "method_startline": "202", "method_endline": "204"}}, "hunk_11": {"Ismethod": 1, "added_lines": "231,232,243,247", "deleted_lines": null, "method_info": {"method_name": "KFoldIteratorTest::test5974", "method_params": "", "method_startline": "230", "method_endline": "258"}}, "hunk_12": {"Ismethod": 1, "added_lines": "153", "deleted_lines": "151,152", "method_info": {"method_name": "KFoldIteratorTest::RandomDataSet::getAllFolds", "method_params": "", "method_startline": "151", "method_endline": "153"}}, "hunk_13": {"Ismethod": 1, "added_lines": "94,96,99,100,101,102", "deleted_lines": "89,90,91,98,99,101,102,104", "method_info": {"method_name": "KFoldIteratorTest::checkCornerCaseA", "method_params": "", "method_startline": "89", "method_endline": "107"}}}}}}}