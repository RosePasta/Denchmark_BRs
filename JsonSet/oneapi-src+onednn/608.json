{"BR": {"BR_id": "608", "BR_author": "pinzhenx", "BRopenT": "2019-11-29T06:20:38Z", "BRcloseT": "2019-12-04T15:54:15Z", "BR_text": {"BRsummary": "Reorder not work like 0.x on submemory?", "BRdescription": "\n As per this <denchmark-link:https://github.com/intel/mkl-dnn/issues/69#issuecomment-306867254>thread</denchmark-link>\n , this seems not to work anymore:\n #include <stdio.h>\n #include \"dnnl.hpp\"\n \n using namespace dnnl;\n using tag = memory::format_tag;\n using dt = memory::data_type;\n \n int main() {\n   engine eng(engine::kind::cpu, 0);\n   stream strm(eng);\n \n   float dst_buf[2] = {1, 0};\n   float src_buf[1] = {35};\n \n   memory dst({{2}, dt::f32, tag::a}, eng, dst_buf);\n   memory src({{1}, dt::f32, tag::a}, eng, src_buf);\n \n   auto dst_view = dst.get_desc().submemory_desc({1}, {1});\n   dnnl::reorder({src.get_engine(), src.get_desc(), dst.get_engine(), dst_view})\n     .execute(strm, src, dst);\n \n   for (size_t i = 0; i < dst.get_desc().get_size() / sizeof(float); i++)\n     printf(\"%g\\n\", ((float*)dst.get_data_handle())[i]);\n \n   return 0;\n }\n <denchmark-code>expect: [1, 35]\n actual: [35, 0]\n </denchmark-code>\n \n I'm not sure if I'm using it right. If the reorder indeed cannot work on submemory, how can I manipulate part of memory before insert and extract are provided?\n Update: It works on the v.1.1.1 release version\n \t"}, "comments": {"comments_0": {"comment_id": 1, "comment_author": "pinzhenx", "commentT": "2019-11-29T09:46:51Z", "comment_text": "\n \t\tHi <denchmark-link:https://github.com/pinzhenx>@pinzhenx</denchmark-link>\n ,\n Thank you very much for reporting the issue and for the reproducer!\n This is a bug, the behavior changes were introduced by me in <denchmark-link:https://github.com/oneapi-src/oneDNN/commit/ebeab4fc2f6d7c1e1d30f9f82984df0becbca4c5>ebeab4f</denchmark-link>\n  unintentionally.\n I am glad we catch this issue before we release DNNL v1.2 (thanks to you)! \n Could you please validate <denchmark-link:https://gist.github.com/emfomenk/eb07b8622cb3ece4262c265c5dd5cece>the fix</denchmark-link>\n ?\n If you are interested, below is the detailed explanation why this problem appeared in the first place and how it is fixed.\n <denchmark-h:hr></denchmark-h>\n \n \n Copy-pasted from the commit message to the potentional fix:\n https://gist.github.com/emfomenk/eb07b8622cb3ece4262c265c5dd5cece\n \n The unwanted change appeared with recent MatMul enabling, namely with the run-time dimensions support. In order to retrieve the run-time sizes and strides, the primitives started using memory descriptors from the memory arguments instead of the memory descriptors kept in the primitive descriptor.\n     // Before:\n     auto src_mdw = memory_descriptor_wrapper(pd()->src_md());\n \n     // After:\n     auto src_mdw = ctx.memory_mdw(DNNL_ARG_SRC);\n These two approaches are almost interchangeable when the original memory descriptor was fully defined (i.e. no run-time dimensions), except for the sub-memory case. The sub-memory workflow (as a successor of view from Intel MKL-DNN v0.x) assumes that it is used at primitive descriptor creation time only, while input memory should be used as is. Example:\n     memory src({{10, 10}, ...}, ...); // original src memory\n     memory::desc submemory_src_md\n             = src.get_desc().submemory_desc({5, 5}, {1, 1});\n \n     primitive_desc pd(submemory_src_md, ...); // use sub-memory\n     primitive p(pd);\n \n     p.execute(stream, {\n             {DNNL_ARG_SRC, src},  // use the original src memory,\n                                   // not a sub-memory based!\n             ...});\n To restore the original sub-memory behavior, the recently added function ctx.memory_mdw() is extended with new optional parameter md_from_primitive_desc that points to the memory descriptor stored in the primitive descriptor, and is used whenever it is fully defined (i.e. there is no intention to use run-time sizes and / or strides):\n memory_desc_wrapper memory_mdw(int arg,\n         const memory_desc_t *md_from_primitive_desc = nullptr) const;\n In general, the interaction between run-time defined memory descriptors and sub-memory seems to be broken. This should probably be revisited by DNNL v2 time-frame. All future extensions of the run-time memory descriptors support should be done with caution and this particular issue in mind.\n \t\t"}, "comments_1": {"comment_id": 2, "comment_author": "pinzhenx", "commentT": "2019-11-29T11:51:37Z", "comment_text": "\n \t\tHi <denchmark-link:https://github.com/emfomenk>@emfomenk</denchmark-link>\n \n Thanks so much for prompt reply. It works well on my models.\n \t\t"}}}, "commit": {"commit_id": "9b49a989102f015500031d5bedf522d76a08983b", "commit_author": "Fomenko, Evarist M", "commitT": "2019-12-03 10:32:26-08:00", "changed_files": {"file_0": {"file_change_type": "MODIFY", "file_Nmethod": 2, "file_old_name": "src\\common\\primitive_exec_types.cpp", "file_new_name": "src\\common\\primitive_exec_types.cpp", "hunks": {"hunk_0": {"Ismethod": 1, "added_lines": "86,87,88,89,90,91,92", "deleted_lines": "86", "method_info": {"method_name": "dnnl::impl::exec_ctx_t::memory_mdw", "method_params": "arg,md_from_primitive_desc", "method_startline": "86", "method_endline": "95"}}, "hunk_1": {"Ismethod": 1, "added_lines": "86,87,88,89", "deleted_lines": "86", "method_info": {"method_name": "dnnl::impl::exec_ctx_t::memory_mdw", "method_params": "arg", "method_startline": "86", "method_endline": "89"}}}}, "file_1": {"file_change_type": "MODIFY", "file_Nmethod": 0, "file_old_name": "src\\common\\primitive_exec_types.hpp", "file_new_name": "src\\common\\primitive_exec_types.hpp", "hunks": {"hunk_0": {"Ismethod": 0, "added_lines": "67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83", "deleted_lines": "67"}}}, "file_2": {"file_change_type": "MODIFY", "file_Nmethod": 1, "file_old_name": "src\\cpu\\matmul\\gemm_f32_matmul.cpp", "file_new_name": "src\\cpu\\matmul\\gemm_f32_matmul.cpp", "hunks": {"hunk_0": {"Ismethod": 1, "added_lines": "100,101,102", "deleted_lines": "100,101,102", "method_info": {"method_name": "dnnl::impl::cpu::gemm_f32_matmul_t::execute_ref", "method_params": "ctx", "method_startline": "92", "method_endline": "161"}}}}, "file_3": {"file_change_type": "MODIFY", "file_Nmethod": 1, "file_old_name": "src\\cpu\\matmul\\gemm_x8s8s32x_matmul.cpp", "file_new_name": "src\\cpu\\matmul\\gemm_x8s8s32x_matmul.cpp", "hunks": {"hunk_0": {"Ismethod": 1, "added_lines": "122,123,124", "deleted_lines": "122,123,124", "method_info": {"method_name": "dnnl::impl::cpu::gemm_x8s8s32x_matmul_t<src_type,weights_type,dst_type>::execute_ref", "method_params": "ctx", "method_startline": "98", "method_endline": "225"}}}}, "file_4": {"file_change_type": "MODIFY", "file_Nmethod": 1, "file_old_name": "src\\cpu\\matmul\\ref_matmul.cpp", "file_new_name": "src\\cpu\\matmul\\ref_matmul.cpp", "hunks": {"hunk_0": {"Ismethod": 1, "added_lines": "47,48,49,50", "deleted_lines": "47,48,49,50", "method_info": {"method_name": "dnnl::impl::cpu::ref_matmul_t<src_type,weights_type,dst_type,acc_type>::execute_ref", "method_params": "ctx", "method_startline": "35", "method_endline": "120"}}}}, "file_5": {"file_change_type": "MODIFY", "file_Nmethod": 1, "file_old_name": "src\\cpu\\simple_reorder.hpp", "file_new_name": "src\\cpu\\simple_reorder.hpp", "hunks": {"hunk_0": {"Ismethod": 1, "added_lines": "1245,1246", "deleted_lines": "1245,1246", "method_info": {"method_name": "dnnl::impl::cpu::simple_reorder_impl<SIMPLE_REORDER_TEMPL_CALL,typenameutils::enable_if<tag_i==format_tag::any&&tag_o==format_tag::any&&order_keep==fmt_order::any,spec::reference>::type>::execute", "method_params": "pd_object,ctx", "method_startline": "1230", "method_endline": "1277"}}}}, "file_6": {"file_change_type": "MODIFY", "file_Nmethod": 1, "file_old_name": "src\\ocl\\ref_matmul.cpp", "file_new_name": "src\\ocl\\ref_matmul.cpp", "hunks": {"hunk_0": {"Ismethod": 1, "added_lines": "47,48,49,50", "deleted_lines": "47,48,49,50", "method_info": {"method_name": "dnnl::impl::ocl::ref_matmul_t::execute_ref", "method_params": "ctx", "method_startline": "27", "method_endline": "127"}}}}, "file_7": {"file_change_type": "ADD", "file_Nmethod": 0, "file_old_name": "None", "file_new_name": "tests\\gtests\\api\\test_submemory.cpp"}}}}