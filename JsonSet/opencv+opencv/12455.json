{"BR": {"BR_id": "12455", "BR_author": "takotakot", "BRopenT": "2018-09-07T03:07:44Z", "BRcloseT": "2018-09-13T20:14:29Z", "BR_text": {"BRsummary": "FLT_EPSILON is too small for RotatedRect", "BRdescription": "\n <denchmark-h:h5>System information (version)</denchmark-h>\n \n \n OpenCV => 3.4.1 (master seems to be same)\n Operating System / Platform => cygwin 64 bit\n Compiler => g++ (gcc 7.3.0)\n \n <denchmark-h:h5>Detailed description</denchmark-h>\n \n In some (very rare) condition, \"Error: Assertion failed\" happens at:\n \n \n \n opencv/modules/core/src/types.cpp\n \n \n          Line 154\n       in\n       da7e1cf\n \n \n \n \n \n \n  CV_Assert( abs(vecs[0].dot(vecs[1])) / (norm(vecs[0]) * norm(vecs[1])) <= FLT_EPSILON ); \n \n \n \n \n \n CV_Assert(abs(vecs[0].dot(vecs[1])) / (cv::norm(vecs[0]) * cv::norm(vecs[1])) <= FLT_EPSILON);\n because FLT_EPSILON is too small to compare.\n <denchmark-h:h5>Steps to reproduce</denchmark-h>\n \n I made a reproducible example:\n <denchmark-link:https://github.com/takotakot/opencv_debug/tree/0a5d37dc2cc4aef22a33012bdcbb54597ae852a1>https://github.com/takotakot/opencv_debug/tree/0a5d37dc2cc4aef22a33012bdcbb54597ae852a1</denchmark-link>\n \n .\n If we have  rectangle, using  can eliminate the problem.\n Part of the code:\n     cv::Mat points = (cv::Mat_<double>(10, 2) <<\n                     1357., 1337.,\n                     1362., 1407.,\n                     1367., 1474.,\n                     1372., 1543.,\n                     1375., 1625.,\n                     1375., 1696.,\n                     1377., 1734.,\n                     1378., 1742.,\n                     1382., 1801.,\n                     1372., 1990.);\n \n     cv::PCA pca_points(points, cv::Mat(), CV_PCA_DATA_AS_ROW, 2);\n \n     cv::Point2d p1(564.45, 339.8819), p2, p3;\n     p2 = p1 - 1999 * cv::Point2d(pca_points.eigenvectors.row(0));\n     p3 = p2 - 1498.5295 * cv::Point2d(pca_points.eigenvectors.row(1));\n \n     cv::RotatedRect(p1, p2, p3);\n <denchmark-h:h5>Plans</denchmark-h>\n \n I have some plans:\n \n Multiple 2, 4 or some value to FLT_EPSILON\n Make another constructor using Point2d for Point2f (and Vec2d for Vec2f etc. inside)\n Note 1: If we use DBL_EPSILON, same problem may occur.\n Note 2: If we only have Point2f rectangle, we cannot avoid assertion.\n Calcurate the angle between two vectors and introduce another assersion.\n \n I want to create PR for solving this issue. But I want some direction.\n \t"}, "comments": {"comments_0": {"comment_id": 1, "comment_author": "takotakot", "commentT": "2018-09-07T05:39:16Z", "comment_text": "\n \t\tplease see <denchmark-link:https://github.com/opencv/opencv/issues/12221>the previous discussion about it</denchmark-link>\n  (duplicate ?)\n \t\t"}, "comments_1": {"comment_id": 2, "comment_author": "takotakot", "commentT": "2018-09-07T07:43:09Z", "comment_text": "\n \t\t<denchmark-link:https://github.com/berak>@berak</denchmark-link>\n  Thank you for commenting.\n I've already read the issue.\n <denchmark-link:https://github.com/opencv/opencv/issues/12221>#12221</denchmark-link>\n  is about intersections and <denchmark-link:https://github.com/opencv/opencv/pull/12222>#12222</denchmark-link>\n  is merged.\n The point that \"double is better\" is the same, but this is not not a duplicate bug.\n \t\t"}, "comments_2": {"comment_id": 3, "comment_author": "takotakot", "commentT": "2018-09-07T19:43:59Z", "comment_text": "\n \t\tPlease try something like this:\n <denchmark-code>CV_Assert(std::fabs(vecs[0].ddot(vecs[1])) <=\n           0.017 /*cos(89deg)*/ * cv::norm(vecs[0]) * cv::norm(vecs[1]));\n </denchmark-code>\n \n Changes:\n \n .ddot\n FLT_EPSILON ==> cos(89 deg) (almost 90 degrees)\n avoid division\n \n \t\t"}, "comments_3": {"comment_id": 4, "comment_author": "takotakot", "commentT": "2018-09-07T20:25:59Z", "comment_text": "\n \t\tI've tried .ddot and \"avoid division\" but nothing changes. I'll try once again for confirmation.\n cos(89 deg) is about 1.7 * 10^(-2) and FLT_EPSILON is about 1.19 * 10^(-7). cos(89 deg) is 10^5 times bigger. I think that change works.\n For my case, abs(vecs[0].dot(vecs[1])) / (cv::norm(vecs[0]) * cv::norm(vecs[1])) is less than 2 * FLT_EPSILON (as long as I remember). std::sqrt(FLT_EPSILON) or 2 * FLT_EPSILON can avoid assert.\n I did some experiments before reporting and got the result that \"increasing the value with small numerical change is very difficult\". (This is the reason why I said it's rare case.)\n I'll\n \n try the code provided\n report the value of my case\n \n \t\t"}, "comments_4": {"comment_id": 5, "comment_author": "takotakot", "commentT": "2018-09-08T00:07:36Z", "comment_text": "\n \t\tFor my environment:\n \n .ddot\n fabs\n avoid division\n \n does not solve this bug.\n \n FLT_EPSILON to 1.7\n \n is good.\n My Point2d version:\n <denchmark-code>ddot: -3.63797880709171e-10\n norm0: 1999\n norm1: 1498.5295\n prod: 2995560.4705\n 1.21445680797239e-16\n </denchmark-code>\n \n 1.21445680797239e-16 is smaller than FLT_EPSILON.\n My Point2f version:\n <denchmark-code>ddot: -0.406243801116943\n norm0: 1999.00007932771\n norm1: 1498.52945663236\n prod: 2995560.50268301\n 1.35615288275128e-07\n OpenCV(3.4.1) Error: Assertion failed (abs(vecs[0].dot(vecs[1])) / (norm(vecs[0]) * norm(vecs[1])) <= 1.19209289550781250000e-7F)\n </denchmark-code>\n \n 1.35615288275128e-07 is a bit larger than FLT_EPSILON.\n A patch that change FLT_EPSILON to std::sqrt(FLT_EPSILON) or some value is accepted?\n double version is better?\n \t\t"}, "comments_5": {"comment_id": 6, "comment_author": "takotakot", "commentT": "2018-09-08T05:20:49Z", "comment_text": "\n \t\t\n std::sqrt(FLT_EPSILON)\n \n This magic value doesn't have any sense.\n This expression is based on  calculation between two vectors: <denchmark-link:https://en.wikipedia.org/wiki/Dot_product#Complex_vectors>https://en.wikipedia.org/wiki/Dot_product#Complex_vectors</denchmark-link>\n \n to ensure that they are perpendicular ( should be almost zero)\n \t\t"}, "comments_6": {"comment_id": 7, "comment_author": "takotakot", "commentT": "2018-09-08T08:05:02Z", "comment_text": "\n \t\t\n This magic value doesn't have any sense.\n \n Yes, I konw that. But 89 degree does not have sense neither. How about 4*EPS?\n I will calculate a^2 + b^2 - c^2 using norm.\n \t\t"}, "comments_7": {"comment_id": 8, "comment_author": "takotakot", "commentT": "2018-09-09T02:26:45Z", "comment_text": "\n \t\tUsing a^2 = vecs[0].ddot(vecs[0]) and vec2 = p2 - p0:\n <denchmark-code>norm0: 1999.00014033596\n norm1: 1498.52945663236\n norm2: 2498.31772711755\n a^2 + b^2 - c^2: 0.627828244119883\n (a^2 + b^2 - c^2) / c^2: 1.00587846477474e-07\n fabs((a^2 + b^2) /c^2 - 1): 1.0058784649658e-07\n </denchmark-code>\n \n 0.627828244119883 is relatively small. So, fabs( a^2 + b^2 - c^2 ) <= FLT_EPSILON * c^2 passes.\n With double version, fabs((a^2 + b^2) /c^2 - 1) is just 0.\n <denchmark-h:h4>Proposal:</denchmark-h>\n \n CV_Assert((std::fabs(vecs[0].ddot(vecs[1])) <= FLT_EPSILON  * (cv::norm(vecs[0]) * cv::norm(vecs[1]))) || (std::fabs(vecs[0].ddot(vecs[0]) + vecs[1].ddot(vecs[1]) - vec2.ddot(vec2)) <= FLT_EPSILON * vec2.ddot(vec2)));\n This method is better when:\n \n corner case (I reported)\n width/height is relatively large/small than the other\n \n Replace FLT_EPSILON with FLT_EPSILON * 2 may be better, too.\n \t\t"}, "comments_8": {"comment_id": 9, "comment_author": "takotakot", "commentT": "2018-09-10T04:56:49Z", "comment_text": "\n \t\t<denchmark-h:h4>Estimate calculation (quantization) error:</denchmark-h>\n \n Define\n <denchmark-link:https://user-images.githubusercontent.com/10368878/45276350-abb00d00-b4fc-11e8-888e-12385b4b1ccc.png></denchmark-link>\n \n and\n ac+bd=0\n Squared order of s are denoted as \n Define\n <denchmark-link:https://user-images.githubusercontent.com/10368878/45276452-57f1f380-b4fd-11e8-9081-3dd9340076f2.png></denchmark-link>\n \n Inner product:\n <denchmark-link:https://user-images.githubusercontent.com/10368878/45276494-9d162580-b4fd-11e8-8c0b-b3d2df4d975f.png></denchmark-link>\n \n Thus\n <denchmark-link:https://user-images.githubusercontent.com/10368878/45276502-b0c18c00-b4fd-11e8-912b-d2c071d291fd.png></denchmark-link>\n \n Norm:\n <denchmark-link:https://user-images.githubusercontent.com/10368878/45276524-d484d200-b4fd-11e8-8881-95d8efd28c72.png></denchmark-link>\n \n <denchmark-link:https://user-images.githubusercontent.com/10368878/45276538-f3836400-b4fd-11e8-98d4-9b61cba04dfe.png></denchmark-link>\n \n In this way, (4 + alpha) | epsilon | (where alpha is some small value) seems to be sufficient.\n <denchmark-h:h4>Estimate cancellation of significant digits:</denchmark-h>\n \n If three points\n <denchmark-link:https://user-images.githubusercontent.com/10368878/45277074-e74cd600-b500-11e8-8300-3ea412cab1b4.png></denchmark-link>\n \n (k=0, 1, 2) are given. We can calculate v_0 = p_1 - p_0, v_1 = p_2 - p_1 .\n Assume | x_k | and | y_k | are relatively larger than | a | etc.\n For computer calcuration, quantization error exists ex.:\n <denchmark-link:https://user-images.githubusercontent.com/10368878/45277066-cedcbb80-b500-11e8-8d96-22d82d4b8664.png></denchmark-link>\n \n And we have cancellation of significant digits as follows:\n <denchmark-link:https://user-images.githubusercontent.com/10368878/45276720-eb77f400-b4fe-11e8-84f2-7e6588901b1a.png></denchmark-link>\n \n Then\n <denchmark-link:https://user-images.githubusercontent.com/10368878/45277127-3e52ab00-b501-11e8-9f16-9dc05c9118ad.png></denchmark-link>\n \n if | a | is relatively smaller than | b | we can ignore this.\n For convenience define:\n <denchmark-link:https://user-images.githubusercontent.com/10368878/45276767-3eea4200-b4ff-11e8-97aa-86e611f95850.png></denchmark-link>\n \n We can estimate:\n <denchmark-link:https://user-images.githubusercontent.com/10368878/45276793-5295a880-b4ff-11e8-8c38-41a31f2215b3.png></denchmark-link>\n \n <denchmark-h:h4>proposal 2</denchmark-h>\n \n <denchmark-link:https://user-images.githubusercontent.com/10368878/45276800-63deb500-b4ff-11e8-9dcc-401990aa4063.png></denchmark-link>\n \n \t\t"}, "comments_9": {"comment_id": 10, "comment_author": "takotakot", "commentT": "2018-09-13T02:23:34Z", "comment_text": "\n \t\t<denchmark-link:https://github.com/alalek>@alalek</denchmark-link>\n  Could you please point out what I can try or explain?\n \t\t"}, "comments_10": {"comment_id": 11, "comment_author": "takotakot", "commentT": "2018-09-13T12:07:24Z", "comment_text": "\n \t\tFeel free to prepare PR onto 3.4 branch.\n Assumption:\n <denchmark-code>x' = x * (1 + eps), where eps < FLT_EPS\n </denchmark-code>\n \n is not always true due calculations in caller function (they may use cos/sin approximations with 100+ ULP).\n \t\t"}, "comments_11": {"comment_id": 12, "comment_author": "takotakot", "commentT": "2018-09-13T13:01:00Z", "comment_text": "\n \t\tThank you.\n Yes. There are many factors.\n I've created <denchmark-link:https://github.com/opencv/opencv/pull/12523>#12523</denchmark-link>\n .\n \t\t"}, "comments_12": {"comment_id": 13, "comment_author": "takotakot", "commentT": "2018-09-13T20:14:29Z", "comment_text": "\n \t\tClosed via <denchmark-link:https://github.com/opencv/opencv/pull/12523>#12523</denchmark-link>\n .\n \t\t"}}}, "commit": {"commit_id": "451340fd3d2f20fb0f0f62402340bbba27314c75", "commit_author": "Takuho NAKANO", "commitT": "2018-09-13 22:26:05+03:00", "changed_files": {"file_0": {"file_change_type": "MODIFY", "file_Nmethod": 1, "file_old_name": "modules\\core\\src\\types.cpp", "file_new_name": "modules\\core\\src\\types.cpp", "hunks": {"hunk_0": {"Ismethod": 1, "added_lines": "153,154,156,161,164", "deleted_lines": "154,159,162", "method_info": {"method_name": "cv::RotatedRect::RotatedRect", "method_params": "_point1,_point2,_point3", "method_startline": "147", "method_endline": "171"}}}}}}}