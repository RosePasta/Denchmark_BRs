{"BR": {"BR_id": "4556", "BR_author": "Vozf", "BRopenT": "2020-11-06T19:52:04Z", "BRcloseT": "2020-11-10T21:13:43Z", "BR_text": {"BRsummary": "Gpu memory leak with self.log on_epoch=True", "BRdescription": "\n pl 1.0.5\n Using new logging api I want to log a metric in LightningModule\n <denchmark-code>self.log(\";;;;;;;;;;;;;;;;;;;\", 1, on_step=False, on_epoch=True)\n </denchmark-code>\n \n This is a dummy example but it is sufficient to add to LightningModule's training_step to cause a memory leak on gpu.\n What could go wrong? We want to log a metric which is not even a cuda tensor. How could it lead to a gpu memory leak?\n Well thanks to the magic of metric epoch aggregation stuff\n Let's dig in and take a look at here\n \n \n \n pytorch-lightning/pytorch_lightning/trainer/training_loop.py\n \n \n         Lines 550 to 569\n       in\n       b3db197\n \n \n \n \n \n \n  # ------------------------------------ \n \n \n \n  # TRAINING_STEP + TRAINING_STEP_END \n \n \n \n  # ------------------------------------ \n \n \n \n  batch_output = self.run_training_batch(batch, batch_idx, dataloader_idx) \n \n \n \n  \n \n \n \n  # when returning -1 from train_step, we end epoch early \n \n \n \n  if batch_output.signal == -1: \n \n \n \n  break \n \n \n \n  \n \n \n \n  # only track outputs when user implements training_epoch_end \n \n \n \n  # otherwise we will build up unnecessary memory \n \n \n \n  epoch_end_outputs = self.process_train_step_outputs( \n \n \n \n  batch_output.training_step_output_for_epoch_end, \n \n \n \n  self.early_stopping_accumulator, \n \n \n \n  self.checkpoint_accumulator, \n \n \n \n  ) \n \n \n \n  \n \n \n \n  # hook \n \n \n \n  # TODO: add outputs to batches \n \n \n \n  self.on_train_batch_end(epoch_output, epoch_end_outputs, batch, batch_idx, dataloader_idx) \n \n \n \n \n \n Here we run batch, convert batch_output to epoch_end_outputs if on_epoch was set and append epoch_end_outputs to epoch_output inside on_train_batch_end\n epoch_output is defined here\n \n \n \n pytorch-lightning/pytorch_lightning/trainer/training_loop.py\n \n \n          Line 540\n       in\n       b3db197\n \n \n \n \n \n \n  epoch_output = [[] for _ in range(self.num_optimizers)] \n \n \n \n \n \n Everything seems normal, but there is a problem inside  there is a surprise - loss value stored on gpu.\n <denchmark-link:https://user-images.githubusercontent.com/22998537/98406840-ba17f600-207f-11eb-9661-1535d90612a1.png></denchmark-link>\n \n I think you can guess by now what could go wrong if we store a lot of separate cuda tensors in a long long \n Yeah the gpu memory is going to end and you'll get a famous\n <denchmark-code>RuntimeError: CUDA out of memory. Tried to allocate 114.00 MiB (GPU 1; 10.92 GiB total capacity; 9.39 GiB already allocated; 27.38 MiB free; 10.24 GiB reserved in total by PyTorch)\n </denchmark-code>\n \n Where is the loss appended to output? Here\n \n \n \n pytorch-lightning/pytorch_lightning/trainer/training_loop.py\n \n \n         Lines 396 to 427\n       in\n       b3db197\n \n \n \n \n \n \n  def _process_training_step_output_1_0(self, training_step_output, split_batch): \n \n \n \n  result = self.trainer.get_model()._results \n \n \n \n  \n \n \n \n  loss = None \n \n \n \n  hiddens = None \n \n \n \n  \n \n \n \n  # handle dict return \n \n \n \n  if isinstance(training_step_output, dict): \n \n \n \n  loss = training_step_output.pop(\"loss\", None) \n \n \n \n  hiddens = training_step_output.pop(\"hiddens\", None) \n \n \n \n  result[\"extra\"] = training_step_output \n \n \n \n  \n \n \n \n  # handle scalar return \n \n \n \n  elif isinstance(training_step_output, torch.Tensor): \n \n \n \n  loss = training_step_output \n \n \n \n  result[\"extra\"] = {} \n \n \n \n  \n \n \n \n  # map to results under the hood \n \n \n \n  result.minimize = loss \n \n \n \n  result.hiddens = hiddens \n \n \n \n  \n \n \n \n  # track batch for manual reduction with result \n \n \n \n  result.track_batch_size(len(split_batch)) \n \n \n \n  \n \n \n \n  # track metrics without grads for epoch reduction \n \n \n \n  training_step_output_for_epoch_end = copy(result) \n \n \n \n  training_step_output_for_epoch_end.detach() \n \n \n \n  \n \n \n \n  # what flows back into the system \n \n \n \n  training_step_output = result \n \n \n \n  \n \n \n \n  return training_step_output_for_epoch_end, training_step_output \n \n \n \n \n \n In the first line we get a pretty result without the loss in it, and in line 414 the loss get appended and we start our memory leak chain of events\n How is it affecting the training? It can lead to error only on the first epoch of training. If you've got enough memory to hold a list of gpu losses during the 1st epoch there won't be any exceptions as subsequent epochs will have the same list of losses, if not you'll get it somewhere in the middle of 1st epoch. And of course the more steps you have in an epoch the more memory this list of gpu losses will require as one loss is stored per step\n Here is the comparison for my task. My gpu could hold 2k steps before memory error\n With \n <denchmark-link:https://user-images.githubusercontent.com/22998537/98408278-f51b2900-2081-11eb-92ae-ceeb80693753.png></denchmark-link>\n \n Without \n <denchmark-link:https://user-images.githubusercontent.com/22998537/98408336-10863400-2082-11eb-97d8-9d00f13c70ca.png></denchmark-link>\n \n You can see how there is a rapid growth in the first minute in both as the model is loaded and feeded the 1st batch.\n The difference is in subsequent minutes where in the former case the list of losses eats 7gb of gpu memory and leads to crash, and in the latter nothing happens and training goes on\n Pretty cool how one  could eat 2 times more gpu memory more than actual training process\n \t"}, "comments": {"comments_0": {"comment_id": 1, "comment_author": "Vozf", "commentT": "2020-11-09T06:02:01Z", "comment_text": "\n \t\tSame problem! However, I use self.log(\"log name\", (scalar tensor).item()) to avoid that OOM problem. Maybe you can log the data in the tensor instead of the tensor itself.\n \t\t"}, "comments_1": {"comment_id": 2, "comment_author": "Vozf", "commentT": "2020-11-09T06:36:43Z", "comment_text": "\n \t\tI'm logging just a python1 not a tensor as you can see from the example\n \t\t"}, "comments_2": {"comment_id": 3, "comment_author": "Vozf", "commentT": "2020-11-09T11:19:02Z", "comment_text": "\n \t\t<denchmark-link:https://github.com/tchaton>@tchaton</denchmark-link>\n , <denchmark-link:https://github.com/Borda>@Borda</denchmark-link>\n   Any thoughts on this?\n \t\t"}, "comments_3": {"comment_id": 4, "comment_author": "Vozf", "commentT": "2020-11-09T12:14:25Z", "comment_text": "\n \t\tFor anyone having the same problem, I monkeypatched like this to avoid setting loss\n <denchmark-code>    from pytorch_lightning.trainer.training_loop import TrainLoop\n \n     old_process_training_step_outputs = TrainLoop.process_train_step_outputs\n \n     def process_train_step_outputs_delete_loss(*args, **kwargs):\n         results = old_process_training_step_outputs(*args, **kwargs)\n         for result in results:\n             for res in result:\n                 res.minimize = None\n         return results\n \n     TrainLoop.process_train_step_outputs = process_train_step_outputs_delete_loss\n </denchmark-code>\n \n \t\t"}, "comments_4": {"comment_id": 5, "comment_author": "Vozf", "commentT": "2020-11-09T15:39:33Z", "comment_text": "\n \t\tValidation loop has the same issue cuda tensors are stored in a list, but they are detached compared to non-detached train loop so overhead isn't big, but it's still there. This can be fixed by loss.cpu() before returning it in validation_step or not returning anything at all\n \t\t"}, "comments_5": {"comment_id": 6, "comment_author": "Vozf", "commentT": "2020-11-09T17:44:31Z", "comment_text": "\n \t\tHey <denchmark-link:https://github.com/Vozf>@Vozf</denchmark-link>\n  and <denchmark-link:https://github.com/AristoYU>@AristoYU</denchmark-link>\n ,\n I deeply apologise for this bug. Let me work on it in priority !\n Best regards,\n Thomas Chaton.\n \t\t"}, "comments_6": {"comment_id": 7, "comment_author": "Vozf", "commentT": "2020-11-10T10:07:20Z", "comment_text": "\n \t\tI also had this issue\n \t\t"}}}, "commit": {"commit_id": "514cb22bd719e6ca056cacce730c8de875c9dbf6", "commit_author": "chaton", "commitT": "2020-11-10 21:13:41+00:00", "changed_files": {"file_0": {"file_change_type": "MODIFY", "file_Nmethod": 1, "file_old_name": "pytorch_lightning\\core\\step_result.py", "file_new_name": "pytorch_lightning\\core\\step_result.py", "hunks": {"hunk_0": {"Ismethod": 1, "added_lines": "398,399,400,401,402", "deleted_lines": null, "method_info": {"method_name": "cpu", "method_params": "self", "method_startline": "398", "method_endline": "402"}}}}, "file_1": {"file_change_type": "MODIFY", "file_Nmethod": 1, "file_old_name": "pytorch_lightning\\trainer\\connectors\\logger_connector\\epoch_result_store.py", "file_new_name": "pytorch_lightning\\trainer\\connectors\\logger_connector\\epoch_result_store.py", "hunks": {"hunk_0": {"Ismethod": 1, "added_lines": "395,396,397,398", "deleted_lines": null, "method_info": {"method_name": "cache_result", "method_params": "self", "method_startline": "368", "method_endline": "408"}}}}, "file_2": {"file_change_type": "MODIFY", "file_Nmethod": 2, "file_old_name": "pytorch_lightning\\trainer\\connectors\\logger_connector\\logger_connector.py", "file_new_name": "pytorch_lightning\\trainer\\connectors\\logger_connector\\logger_connector.py", "hunks": {"hunk_0": {"Ismethod": 1, "added_lines": "96", "deleted_lines": "96", "method_info": {"method_name": "on_trainer_init", "method_params": "self,logger,flush_logs_every_n_steps,log_every_n_steps", "method_startline": "96", "method_endline": "102"}}, "hunk_1": {"Ismethod": 1, "added_lines": "96,104", "deleted_lines": "96", "method_info": {"method_name": "on_trainer_init", "method_params": "self,logger,int,int,bool", "method_startline": "96", "method_endline": "104"}}}}, "file_3": {"file_change_type": "MODIFY", "file_Nmethod": 3, "file_old_name": "pytorch_lightning\\trainer\\trainer.py", "file_new_name": "pytorch_lightning\\trainer\\trainer.py", "hunks": {"hunk_0": {"Ismethod": 1, "added_lines": "616,617,620", "deleted_lines": "606,607,610,611", "method_info": {"method_name": "run_evaluation", "method_params": "self,bool,max_batches", "method_startline": "548", "method_endline": "644"}}, "hunk_1": {"Ismethod": 1, "added_lines": "646,647,648,649,650,651,652,653,654,655,656,657", "deleted_lines": null, "method_info": {"method_name": "track_output_for_epoch_end", "method_params": "self,outputs,output", "method_startline": "646", "method_endline": "657"}}, "hunk_2": {"Ismethod": 1, "added_lines": "139", "deleted_lines": null, "method_info": {"method_name": "__init__", "method_params": "self,LightningLoggerBase,True,bool,None,None,float,int,int,int,str,None,bool,str,None,None,int,int,0,int,float,1,int,bool,int,int,1,int,int,None,None,int,0,int,0,int,0,int,0,int,int,str,None,bool,int,None,int,None,None,BaseProfiler,bool,None,bool,bool,bool,bool,False,bool,bool,str,False,bool,None,str,str,None,bool,bool", "method_startline": "87", "method_endline": "139"}}}}, "file_4": {"file_change_type": "MODIFY", "file_Nmethod": 1, "file_old_name": "pytorch_lightning\\trainer\\training_loop.py", "file_new_name": "pytorch_lightning\\trainer\\training_loop.py", "hunks": {"hunk_0": {"Ismethod": 1, "added_lines": "437,438", "deleted_lines": null, "method_info": {"method_name": "_process_training_step_output_1_0", "method_params": "self,training_step_output,split_batch", "method_startline": "410", "method_endline": "443"}}}}, "file_5": {"file_change_type": "MODIFY", "file_Nmethod": 2, "file_old_name": "pytorch_lightning\\utilities\\memory.py", "file_new_name": "pytorch_lightning\\utilities\\memory.py", "hunks": {"hunk_0": {"Ismethod": 1, "added_lines": "20,29,39,40,41", "deleted_lines": "20,38", "method_info": {"method_name": "recursive_detach", "method_params": "dict", "method_startline": "20", "method_endline": "41"}}, "hunk_1": {"Ismethod": 1, "added_lines": "20,29,39,40,41,42,43", "deleted_lines": "20,38", "method_info": {"method_name": "recursive_detach", "method_params": "dict,bool", "method_startline": "20", "method_endline": "46"}}}}}}}