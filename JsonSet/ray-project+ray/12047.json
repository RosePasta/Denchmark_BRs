{"BR": {"BR_id": "12047", "BR_author": "felipeeeantunes", "BRopenT": "2020-11-16T20:13:10Z", "BRcloseT": "2020-11-20T07:59:44Z", "BR_text": {"BRsummary": "[rllib] OffPolicyEstimator returning negative values for action_prob", "BRdescription": "\n <denchmark-h:h3>What is the problem?</denchmark-h>\n \n OffPolicyEstimator class is using log_likelihoods instead of action probabilities, leading to negative values for action_prob. This bug affects the IS and WIS OPE results.\n Ray version and other system information (Python version, TensorFlow version, OS):\n \n ray==1.0.1dev commit hash d1182b827af9fc94be0cd9a6a3211c096aa4c0e3\n numpy==1.19.2\n tf-nightly-cpu==2.4.0.dev20201023\n tb-nightly==2.4.0a20201001\n \n <denchmark-h:h3>Reproduction (REQUIRED)</denchmark-h>\n \n It's a conceptual problem, so we just need to look to at the code to understand:\n def action_prob(self, batch: SampleBatchType) -> np.ndarray:\n         \"\"\"Returns the probs for the batch actions for the current policy.\"\"\"\n \n         num_state_inputs = 0\n         for k in batch.keys():\n             if k.startswith(\"state_in_\"):\n                 num_state_inputs += 1\n         state_keys = [\"state_in_{}\".format(i) for i in range(num_state_inputs)]\n         \n         log_likelihoods: TensorType = self.policy.compute_log_likelihoods(\n             actions=batch[SampleBatch.ACTIONS],\n             obs_batch=batch[SampleBatch.CUR_OBS],\n             state_batches=[batch[k] for k in state_keys],\n             prev_action_batch=batch.data.get(SampleBatch.PREV_ACTIONS),\n             prev_reward_batch=batch.data.get(SampleBatch.PREV_REWARDS))\n         \n         return convert_to_numpy(log_likelihoods)\n A possible solution is to change the method to:\n def action_prob(self, batch: SampleBatchType) -> np.ndarray:\n         \"\"\"Returns the probs for the batch actions for the current policy.\"\"\"\n \n         num_state_inputs = 0\n         for k in batch.keys():\n             if k.startswith(\"state_in_\"):\n                 num_state_inputs += 1\n         state_keys = [\"state_in_{}\".format(i) for i in range(num_state_inputs)]\n       \n         actions = self.policy.compute_actions(\n               obs_batch=batch[SampleBatch.CUR_OBS],\n               state_batches=[batch[k] for k in state_keys],\n               prev_action_batch=batch.data.get(SampleBatch.PREV_ACTIONS),\n               prev_reward_batch=batch.data.get(SampleBatch.PREV_REWARDS),\n               full_fetch=True\n               )\n         # Categorical case (e.g. DQN).\n         if self.policy.dist_class in (Categorical, TorchCategorical):\n             action_prob_dist = softmax(actions[2][SampleBatch.ACTION_DIST_INPUTS])\n         # Deterministic (Gaussian actions, e.g. DDPG).\n         elif self.policy.dist_class in [Deterministic, TorchDeterministic]:\n             action_prob_dist = actions[2][SampleBatch.ACTION_DIST_INPUTS]\n         else:\n             raise NotImplementedError  # TODO(sven): Other action-dist cases.\n         \n         cur_action = batch[SampleBatch.ACTIONS]\n         cur_action_prob = action_prob_dist[np.arange(cur_action.shape[0]), cur_action]\n         \n         return cur_action_prob \n \n  I have verified my script runs in a clean environment and reproduces the issue.\n  I have verified the issue also occurs with the latest wheels.\n \n \t"}, "comments": {"comments_0": {"comment_id": 1, "comment_author": "felipeeeantunes", "commentT": "2020-11-17T16:33:55Z", "comment_text": "\n \t\tThis bug is related to the issue <denchmark-link:https://github.com/ray-project/ray/issues/10458>#10458</denchmark-link>\n .\n \t\t"}, "comments_1": {"comment_id": 2, "comment_author": "felipeeeantunes", "commentT": "2020-11-19T12:32:55Z", "comment_text": "\n \t\tYeah, I think returning the logp instead of the prob is indeed a bug. I'll fix it. However, I still think we should use policy.compute_log_likelihood() for that, for the following reason:\n Let's take a look at rllib/offline/is_estimator.py:\n What we are trying to do here inside the  estimate method is to calculate the importance sampling ratios (IS): p_old(actions)/p_new(actions), where actions are the actions from the historic(!) batch (not newly calculated ones). p_old(actions) is the probability that the old policy (the one used to collect the batch) calculated for the actions in the batch (not newly calculated actions!).\n You can see this in this line here in rllib/offline/is_estimator.py:\n rewards, old_prob = batch[\"rewards\"], batch[\"action_prob\"]\n p_new(actions) is the probability computed by the current/updated policy (but for the exact same historic actions in the batch!). And this is why we have to use policy.compute_log_likelihoods(), to be able to pass in the actions from the batch, not re-calculate new actions, which may be different due to the policy having changed and outputting different actions for the observations in the batch than the old policy would have.\n So the fix should rather be:\n Keep compute_log_likelihoods(), but translate to probs by simply doing np.exp before returning from OffPolicyEstimator::action_probs().\n The whole point of calculating these weights is to weight less those (historic) actions that the new policy would not produce that much anymore anyways and weight more those (historic) actions, which the new policy would produce a lot (compared to the old policy).\n So even if some actions show up a lot in the historic data, we may still weight these less for our loss/updates b/c the new policy has learned that these are not great actions to pick from and it won't output these actions that much anymore.\n \t\t"}}}, "commit": {"commit_id": "f6b84cb2f76188d0e77bc293d8662379609edd0e", "commit_author": "Sven Mika", "commitT": "2020-11-20 08:59:43+01:00", "changed_files": {"file_0": {"file_change_type": "MODIFY", "file_Nmethod": 1, "file_old_name": "rllib\\offline\\off_policy_estimator.py", "file_new_name": "rllib\\offline\\off_policy_estimator.py", "hunks": {"hunk_0": {"Ismethod": 1, "added_lines": "73,74", "deleted_lines": "73", "method_info": {"method_name": "action_prob", "method_params": "self,SampleBatchType", "method_startline": "59", "method_endline": "74"}}}}}}}