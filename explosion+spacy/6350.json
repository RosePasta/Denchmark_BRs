{"BR": {"BR_id": "6350", "BR_author": "maxtrem", "BRopenT": "2020-11-05T14:03:46Z", "BRcloseT": "2020-11-12T09:44:20Z", "BR_text": {"BRsummary": "POS/Morph annotation empty with trained Transformer model", "BRdescription": "\n <denchmark-h:h3>How to reproduce the behaviour</denchmark-h>\n \n I have trained a Swedish Transformer model on UD-Treebank Talbanken using mainly the <denchmark-link:https://nightly.spacy.io/usage/training#quickstart>Quickstart Config</denchmark-link>\n  from the Spacy website. I only added  and  to the model. So the full pipeline looks like this:\n ['transformer', 'tagger', 'morphologizer', 'lemmatizer', 'parser'] \n With normal sentences everything seems to work fine, but when very short sequences (such as nlp('Privat')) are passed through the model the POS and Morph annotation can be missing for some tokens.\n Here are some examples with first the text sequence and then a list with respective POS and Morph annotations returned by token.pos_ and token.morph:\n <denchmark-code>Privat [''] []\n A-\u00d6 ['PROPN', 'SYM', ''] [Case=Nom, , ]\n A [''] []\n B [''] []\n C ['NOUN'] [Abbr=Yes]\n D [''] []\n E [''] []\n F [''] []\n G ['PROPN'] [Case=Nom]\n H [''] []\n I ['ADP'] []\n J [''] []\n K [''] []\n L ['ADP'] []\n M [''] []\n N ['PROPN'] [Case=Nom]\n O ['PUNCT'] []\n P [''] []\n Q [''] []\n R [''] []\n S ['ADP'] []\n T [''] []\n U [''] []\n V [''] []\n W [''] []\n X [''] []\n Y [''] []\n Z [''] []\n \u00c5 ['INTJ'] []\n \u00c4 [''] []\n \u00d6 [''] []\n </denchmark-code>\n \n I also trained a model on both the UD-Talbanken and UD-Lines corpora. That model has the issue as well, but it seems to occur not that frequently:\n <denchmark-code>Privat ['PUNCT'] []\n A ['NOUN'] [Case=Nom|Definite=Ind|Gender=Neut|Number=Sing]\n -\u00d6 ['SYM', ''] [, ]\n A ['ADV'] []\n B ['PUNCT'] []\n C ['PUNCT'] []\n D ['PUNCT'] []\n E ['PUNCT'] []\n F ['PUNCT'] []\n G ['PUNCT'] []\n H ['PUNCT'] []\n I ['PUNCT'] []\n J ['PUNCT'] []\n K ['PUNCT'] []\n L ['PUNCT'] []\n M [''] []\n N ['PUNCT'] []\n O ['PUNCT'] []\n P ['PUNCT'] []\n Q ['PUNCT'] []\n R ['PUNCT'] []\n S ['PUNCT'] []\n T ['PUNCT'] []\n U ['PUNCT'] []\n V ['PUNCT'] []\n W ['PUNCT'] []\n X ['NOUN'] []\n Y ['PUNCT'] []\n Z ['PUNCT'] []\n \u00c5 ['INTJ'] []\n \u00c4 ['ADV'] []\n \u00d6 ['PUNCT'] []\n </denchmark-code>\n \n (Please note that the list containing the morph annotation actually contains a spacy.tokens.morphanalysis.MorphAnalysis  object where the __str__/__repr__ method returns an empty string.)\n TAG and dep annotations seem to be okay from what I can see.\n Is there maybe some threshold for certainty/entropy that prevents predicting POS tags for uncertain cases?\n If that is the case, than I would rather prefer uncertain tags over no tags, because currently I'm getting an error message from Spacy Matcher:\n <denchmark-code>ValueError: [E155] The pipeline needs to include a morphologizer in order to use Matcher or PhraseMatcher with the attribute POS. Try using `nlp()` instead of `nlp.make_doc()` or `list(nlp.pipe())` instead of `list(nlp.tokenizer.pipe())`.\n </denchmark-code>\n \n Please let me know if you need additional information. Thanks!\n <denchmark-h:h3>Your Environment</denchmark-h>\n \n \n Operating System:\n Ubuntu 20.04.1 LTS \n Python Version Used:\n \n <denchmark-code>Python 3.8.3 (default, May 19 2020, 18:47:26) \n [GCC 7.3.0] :: Anaconda, Inc. on linux\n </denchmark-code>\n \n \n spaCy Version Used:\n 3.0.0rc2\n \n \t"}, "comments": {"comments_0": {"comment_id": 1, "comment_author": "maxtrem", "commentT": "2020-11-05T14:46:20Z", "comment_text": "\n \t\tEmpty morphs are normal (maybe half of Talbanken tokens have an empty morph tag), but empty POS shouldn't happen when training from a UD corpus. Can you attach morphologizer/cfg from the trained model (you'll have to rename it cfg.txt to be able to attach it)?\n \t\t"}, "comments_1": {"comment_id": 2, "comment_author": "maxtrem", "commentT": "2020-11-05T14:56:11Z", "comment_text": "\n \t\tThanks, here comes the : <denchmark-link:https://github.com/explosion/spaCy/files/5495125/cfg.txt>cfg.txt</denchmark-link>\n \n \t\t"}, "comments_2": {"comment_id": 3, "comment_author": "maxtrem", "commentT": "2020-11-05T15:25:39Z", "comment_text": "\n \t\tOkay, the training data conversion isn't the problem. How many epochs did you train for? The colab notebook just shows an aborted example that hasn't actually trained at all? Then you might end up with the default empty morphs instead of the morphs learned from the training data, which won't have empty POS tags.\n The morphologizer can be run with or without POS tags, but the default POS mapping for an empty internal POS+morph tag is only to \"\" rather than a POS like \"X\". I need to think about whether there's a good way to handle this, since I think it's where this unexpected behavior is coming from.\n \t\t"}, "comments_3": {"comment_id": 4, "comment_author": "maxtrem", "commentT": "2020-11-05T16:02:54Z", "comment_text": "\n \t\tNo, I trained until the training script stopped by itself. The notebook shows a later test that I aborted.\n Here is an older training output also trained on Talbanken. The training script is the same, I only used different lemma_exc data.\n The model performance itself, also on other data is also not all too bad. POS and DEP labels look reasonable.\n However the <denchmark-link:https://universaldependencies.org/treebanks/sv_talbanken/index.html>UD-Talbanken</denchmark-link>\n  treebank is not very large and the problem was less common when I added the <denchmark-link:https://universaldependencies.org/treebanks/sv_lines/index.html>UD-Lines</denchmark-link>\n  treebank, which doubled the amount of training data. So there could be a correlation with the amount of training data.\n I don't know how the morph model works, but could it be that even after training some morphs remained empty?\n <denchmark-code>2020-11-02 16:03:39.495695: I tensorflow/stream_executor/platform/default/dso_loader.cc:48] Successfully opened dynamic library libcudart.so.10.1\n \u2139 Using GPU: 0\n \n =========================== Initializing pipeline ===========================\n Set up nlp object from config\n Pipeline: ['transformer', 'tagger', 'morphologizer', 'lemmatizer', 'parser']\n Created vocabulary\n Finished initializing nlp object\n Initialized pipeline components: ['transformer', 'tagger', 'morphologizer', 'lemmatizer', 'parser']\n \u2714 Initialized pipeline\n \n ============================= Training pipeline =============================\n \u2139 Pipeline: ['transformer', 'tagger', 'morphologizer', 'lemmatizer',\n 'parser']\n \u2139 Initial learn rate: 0.0\n E    #       LOSS TRANS...  LOSS TAGGER  LOSS MORPH...  LOSS PARSER  TAG_ACC  POS_ACC  MORPH_ACC  LEMMA_ACC  DEP_UAS  DEP_LAS  SENTS_F  SCORE \n ---  ------  -------------  -----------  -------------  -----------  -------  -------  ---------  ---------  -------  -------  -------  ------\n   0       0        2649.04      1292.14        1295.62      1904.61     5.65     0.00      35.63      62.41    19.15     0.73     0.00    0.24\n   5     200      414165.46    349024.56      351501.46    314286.58    53.23    87.09      58.23      83.65    81.44    74.00    92.64    0.70\n  11     400      101147.58    163143.18      171550.76     81703.36    93.33    98.01      93.74      87.00    89.05    85.09    96.27    0.89\n  16     600       44678.66     13504.81       16589.89     31378.16    97.37    98.66      97.37      87.01    91.48    88.54    97.53    0.91\n  21     800       19743.16      3001.88        4720.89     11772.16    97.62    98.76      97.61      87.06    92.69    89.84    97.82    0.92\n  27    1000        8006.59      1393.63        2429.80      4405.85    97.76    98.82      97.87      87.01    92.39    89.73    97.63    0.92\n  32    1200        4936.63       643.29        1296.42      2246.22    97.73    98.85      97.84      87.04    92.40    89.82    97.72    0.92\n  38    1400        4526.94       384.91         717.74      1607.24    97.68    98.86      97.90      87.03    92.11    89.56    97.92    0.92\n  43    1600        2703.55       255.31         425.99       984.58    97.82    98.89      97.99      87.08    92.47    89.99    97.33    0.92\n  49    1800        2387.74       189.04         294.65       831.95    97.64    98.89      97.94      87.08    92.16    89.71    97.34    0.92\n  54    2000        2428.07       102.84         140.88       803.04    97.86    98.87      97.95      87.04    92.40    89.92    96.95    0.92\n  60    2200        1544.83       109.84         136.95       519.11    97.73    98.85      97.92      87.14    92.58    90.12    97.04    0.92\n  65    2400        1946.26       105.30         133.34       605.98    97.92    98.86      98.06      87.06    92.35    89.76    96.95    0.92\n  71    2600        1434.08       104.13         129.62       394.13    97.77    98.80      97.94      87.11    91.95    89.32    97.83    0.92\n  76    2800        1201.01        94.52          90.80       323.93    97.74    98.94      97.94      87.05    92.34    89.85    97.24    0.92\n  82    3000        1499.74        90.62          90.63       343.52    97.69    98.83      97.92      87.13    92.27    89.75    97.92    0.92\n  87    3200        1562.12        92.26          91.54       350.25    97.82    98.82      98.01      87.11    92.32    89.92    97.44    0.92\n  92    3400        1219.65        97.56          96.69       284.64    97.74    98.94      97.87      87.05    92.79    90.14    98.22    0.92\n  98    3600        1179.11        66.65          98.81       278.46    97.81    98.87      97.94      87.05    92.55    89.97    97.24    0.92\n 103    3800        1515.70        57.46          58.29       321.78    97.83    98.82      97.99      87.03    92.37    89.74    98.12    0.92\n 109    4000        1071.01        36.30          44.84       208.29    97.83    98.89      97.98      87.07    92.36    89.86    97.83    0.92\n 114    4200         986.62        78.65          75.49       204.65    97.81    98.84      97.97      87.04    92.41    89.90    97.83    0.92\n 120    4400        1073.68        58.29          70.97       205.42    97.72    98.84      97.93      87.08    92.40    90.00    97.63    0.92\n 125    4600         798.90        56.53          63.53       156.42    97.71    98.94      97.97      87.05    92.64    90.04    98.52    0.92\n 131    4800         688.09        29.01          32.98       152.94    97.75    98.86      97.91      87.09    92.63    90.16    98.22    0.92\n 136    5000         979.26        26.85          30.70       192.99    97.87    98.93      98.05      87.03    92.53    89.97    98.52    0.92\n \u2714 Saved pipeline to output directory\n output/model-last\n </denchmark-code>\n \n \t\t"}, "comments_4": {"comment_id": 5, "comment_author": "maxtrem", "commentT": "2020-11-05T18:57:48Z", "comment_text": "\n \t\tHmm, I trained the same model in colab (except with max_steps = 600 to speed things up) and I can't replicate the missing POS tags.\n This is a frustrating thing for me to say, but I think you may be mixing up a trained model and an \"aborted\" model in your evaluation in the top report with the missing tags. The behavior in the top report is what I'd expect from a model that has barely seen any training examples and it doesn't match the training logs in the comment above. If I train a model with a very small max_steps (I tried 20), I do see missing POS tags.\n I can replicate the kind of weird behavior (but with POS tags for all tokens!) for short documents:\n <denchmark-code>a ADV Abbr=Yes\n b PUNCT \n c PUNCT \n d ADV Abbr=Yes\n e ADV Abbr=Yes\n f PUNCT \n g ADV Abbr=Yes\n h ADV Abbr=Yes\n i ADP \n j PUNCT \n k ADV Abbr=Yes\n l PROPN Case=Nom\n m ADV Abbr=Yes\n n ADV Abbr=Yes\n o CCONJ \n p PUNCT \n q PUNCT \n r ADV Abbr=Yes\n s PUNCT \n t ADV \n u ADV Abbr=Yes\n v ADV Abbr=Yes\n w ADV Abbr=Yes\n x PUNCT \n y PUNCT \n z PUNCT \n A PUNCT \n B PUNCT \n C PROPN Case=Nom\n D PUNCT \n E PUNCT \n F PUNCT \n G PUNCT \n H PUNCT \n I ADP \n J PUNCT \n K PUNCT \n L PROPN Case=Nom\n M PUNCT \n N PUNCT \n O PUNCT \n P PUNCT \n Q PUNCT \n R PUNCT \n S PUNCT \n T PUNCT \n U PUNCT \n V PUNCT \n W PUNCT \n X PUNCT \n Y PUNCT \n Z PUNCT \n </denchmark-code>\n \n I'm guessing this is related to what short texts look like in the training data and some strong influence (from the special boundary tokens?) that the last token is often PUNCT or a short text is often an abbreviation. I'm not extremely familiar with transformers, though, so this may not be the whole story.\n \t\t"}, "comments_5": {"comment_id": 6, "comment_author": "maxtrem", "commentT": "2020-11-06T07:45:21Z", "comment_text": "\n \t\tGod morning <denchmark-link:https://github.com/adrianeboyd>@adrianeboyd</denchmark-link>\n  and thank you for testing!\n \n This is a frustrating thing for me to say, but I think you may be mixing up a trained model and an \"aborted\" model in your evaluation in the top report with the missing tags.\n \n I really wish that would be the case! But as mentioned, this did happen as well on the model with the combined corpora of Lines and Talbanken. I did also some quick testing previous models, with no much difference.\n Finally I did run another training yesterday and checked it just now (therefore I loaded it from google drive, but it's the same model) - unfortunately with similar issues.\n <denchmark-code>Privat ['PUNCT'] []\n Id-kort ['NOUN'] [Case=Nom|Definite=Ind|Gender=Neut|Number=Sing]\n E ['PUNCT'] []\n -\u00d6 ['PUNCT'] []\n SKV 120 ['NOUN', 'NUM'] [Abbr=Yes, Case=Nom|NumType=Card]\n 20 dec ['NUM', ''] [Case=Nom|NumType=Card, ]\n 19 dec ['NUM', ''] [Case=Nom|NumType=Card, ]\n 19 dec ['NUM', ''] [Case=Nom|NumType=Card, ]\n 14 dec ['NUM', ''] [Case=Nom|NumType=Card, ]\n A ['PUNCT'] []\n -\u00d6 ['PUNCT'] []\n A ['PUNCT'] []\n B ['PUNCT'] []\n C ['PROPN'] []\n D [''] []\n E ['PUNCT'] []\n F ['PUNCT'] []\n G [''] []\n H [''] []\n I ['PUNCT'] []\n J [''] []\n K [''] []\n L ['PROPN'] []\n M [''] []\n N [''] []\n O ['PUNCT'] []\n P ['PUNCT'] []\n Q ['PUNCT'] []\n R ['PUNCT'] []\n S ['ADP'] []\n T ['PUNCT'] []\n U ['PUNCT'] []\n V ['PUNCT'] []\n W ['PUNCT'] []\n X ['PUNCT'] []\n Y ['PUNCT'] []\n Z [''] []\n \u00c5 ['PUNCT'] []\n \u00c4 ['PUNCT'] []\n \u00d6 ['PUNCT'] []\n </denchmark-code>\n \n <denchmark-link:https://colab.research.google.com/drive/1LWxP8EuI9btUEY3AcDDBnTMOCebsMX5D?usp=sharing>Here is the respective notebook. This time with the correct respective outputs.</denchmark-link>\n  I attached some test cases to the notebook as well.\n The training script was running for quite a while 207epochs/7600steps. Though I did not check which model was actually the  model, that could have been worth checking.\n \n I will run another test with ~600-1000 steps. As you did not experience any issues with a low number of training steps, maybe the problem is actually less prominent with fewer steps?\n \t\t"}, "comments_6": {"comment_id": 7, "comment_author": "maxtrem", "commentT": "2020-11-06T08:53:54Z", "comment_text": "\n \t\tAn update: I did now two test trainings with both 600 and 1000 training steps and I could not reproduce this issue there with the given test cases (of course it could still be there, just less often).\n Since the models where I experienced this issue all have been trained for much longer with low losses, there could be a correlation in this direction. Meaning that models with higher convergence could increase the likelihood of seeing this issue, at least for Swedish.\n \t\t"}, "comments_7": {"comment_id": 8, "comment_author": "maxtrem", "commentT": "2020-11-06T09:59:41Z", "comment_text": "\n \t\tHmm, that would be really weird because the models should never see a missing POS during training from this data. I'll try training for longer to see if I can see the same behavior.\n It's possible we'll need to add an option to the morphologizer about whether it should always assign a POS (X) or not.\n \t\t"}, "comments_8": {"comment_id": 9, "comment_author": "maxtrem", "commentT": "2020-11-06T11:53:00Z", "comment_text": "\n \t\tOkay, I can replicate this with a model that's trained for longer. We'll look into it.\n \t\t"}, "comments_9": {"comment_id": 10, "comment_author": "maxtrem", "commentT": "2020-11-06T12:34:48Z", "comment_text": "\n \t\t\n Okay, I can replicate this with a model that's trained for longer. We'll look into it.\n \n Thanks!\n :\n Where is the  attribute actually set? I couldn't find it in <denchmark-link:https://github.com/explosion/spaCy/blob/nightly.spacy.io/spacy/pipeline/tagger.pyx>pipeline/tagger</denchmark-link>\n .\n \t\t"}, "comments_10": {"comment_id": 11, "comment_author": "maxtrem", "commentT": "2020-11-06T12:37:43Z", "comment_text": "\n \t\tThis is something that's changed in v3. The morphologizer sets both morph and POS here:\n \n \n \n spaCy/spacy/pipeline/morphologizer.pyx\n \n \n         Lines 204 to 205\n       in\n       8ef056c\n \n \n \n \n \n \n  doc.c[j].morph = self.vocab.morphology.add(self.cfg[\"labels_morph\"][morph]) \n \n \n \n  doc.c[j].pos = self.cfg[\"labels_pos\"][morph] \n \n \n \n \n \n \t\t"}, "comments_11": {"comment_id": 12, "comment_author": "maxtrem", "commentT": "2020-11-06T13:31:14Z", "comment_text": "\n \t\tDisclaimer: I probably know too little about how Spacy works behind the scenes.\n But on a first glance it does not seem too strange that the Morphologizer predicts _ as this occurs quite often in the corpus. And _ is mapped to 0, and that in turn results in an empty string, after the lookup.\n But I guess the POS=... prediction is (should be) handled somehow differently by the model since this does not appear in the original data.\n <denchmark-link:https://user-images.githubusercontent.com/51746838/98371358-53bdb400-203c-11eb-87f9-ee4d82c7adaf.png></denchmark-link>\n \n \t\t"}, "comments_12": {"comment_id": 13, "comment_author": "maxtrem", "commentT": "2020-11-06T13:39:17Z", "comment_text": "\n \t\t_ doesn't actually appear in the training data because the model is trained on POS+morph tags, so the underlying tags learned by the model should (in theory) all contain at least POS=.... The _ label is added internally to make sure that the mapping from internal POS+morph->POS doesn't fail even if the model hasn't learned any labels, but this is probably the wrong way to handle things.\n So technically _ is always a valid morphologizer label in 3.0.0rc2, but I don't understand why the transformer model in particular is predicting it when it's never seen it in the training data.\n \t\t"}, "comments_13": {"comment_id": 14, "comment_author": "maxtrem", "commentT": "2020-11-06T13:58:11Z", "comment_text": "\n \t\tAh, I think the logic is wrong when the gold annotation is misaligned.\n \t\t"}, "comments_14": {"comment_id": 15, "comment_author": "maxtrem", "commentT": "2020-11-06T14:33:54Z", "comment_text": "\n \t\t\n _ doesn't actually appear in the training data because the model is trained on POS+morph tags, so the underlying tags learned by the model should (in theory) all contain at least POS=.... The _ label is added internally to make sure that the mapping from internal POS+morph->POS doesn't fail even if the model hasn't learned any labels, but this is probably the wrong way to handle things.\n So technically _ is always a valid morphologizer label in 3.0.0rc2, but I don't understand why the transformer model in particular is predicting it when it's never seen it in the training data.\n \n Thanks for the explanation!\n \n Ah, I think the logic is wrong when the gold annotation is misaligned.\n \n What kind of misalignment?\n When the data is tokenized via wordpiece tokenizer? Is there actually a way of accessing the wordpiece-token/spacy-token alignment?\n doc._.trf_data.tokens['input_texts'] only returns the whole wordpiece tokenized document.\n \t\t"}, "comments_15": {"comment_id": 16, "comment_author": "maxtrem", "commentT": "2020-11-06T19:10:54Z", "comment_text": "\n \t\tThe misalignment doesn't have to do with transformers in the end (although maybe the weird PUNCT results are from some transformer-related overfitting, I'm not sure).\n A common type of misalignment is that spacy tokenizes A. into ['A.'] and the gold data annotates A. as two tokens ['A', '.']. For token-level tags like POS tags, if the model says POS=Y and the gold data says POS=Y, POS=Y we count this as aligned and let the model learn that this was correct (or not, if the model had said POS=X). If the model says POS=Y and the gold data says POS=Y, POS=Z (for this example the real case might be POS=NOUN, POS=PUNCT), then we treat it as misaligned, because we can't really know what the correct annotation would be for the single token. And the idea is that the misaligned cases should be ignored while training.\n What the current code was doing wrong was learning the default empty label (no POS, no morph) for these cases rather than ignoring them when updating the model, so it did effectively have the empty label as input.\n I'll remove the unneeded default empty label, so the model can only predict POS+morphs that were seen in the training data and update the code that handles misalignments so these cases are ignored.\n The model trained with the modified code has these results for your test cases:\n <denchmark-code>Privat ['PUNCT'] []\n Id-kort ['NOUN'] [Case=Nom|Definite=Ind|Gender=Neut|Number=Sing]\n E ['PUNCT'] []\n -\u00d6 ['PUNCT'] []\n SKV 120 ['NOUN', 'NUM'] [Abbr=Yes, Case=Nom|NumType=Card]\n 20 dec ['NUM', 'NOUN'] [Case=Nom|NumType=Card, Abbr=Yes]\n 19 dec ['NUM', 'NOUN'] [Case=Nom|NumType=Card, Abbr=Yes]\n 19 dec ['NUM', 'NOUN'] [Case=Nom|NumType=Card, Abbr=Yes]\n 14 dec ['NUM', 'NOUN'] [Case=Nom|NumType=Card, Abbr=Yes]\n A ['NUM'] [Case=Nom|NumType=Card]\n -\u00d6 ['PUNCT'] []\n A ['NUM'] [Case=Nom|NumType=Card]\n B ['PUNCT'] []\n C ['NUM'] [Case=Nom|NumType=Card]\n D ['PUNCT'] []\n E ['PUNCT'] []\n F ['PUNCT'] []\n G ['PUNCT'] []\n H ['PUNCT'] []\n I ['PUNCT'] []\n J ['PUNCT'] []\n K ['PUNCT'] []\n L ['ADJ'] [Case=Nom|Degree=Cmp]\n M ['PUNCT'] []\n N ['NUM'] [Case=Nom|NumType=Card]\n O ['NUM'] [Case=Nom|NumType=Card]\n P ['PUNCT'] []\n Q ['NUM'] [Case=Nom|NumType=Card]\n R ['PUNCT'] []\n S ['NUM'] [Case=Nom|NumType=Card]\n T ['PUNCT'] []\n U ['PUNCT'] []\n V ['PUNCT'] []\n W ['PUNCT'] []\n X ['PUNCT'] []\n Y ['NUM'] [Case=Nom|NumType=Card]\n Z ['PUNCT'] []\n \u00c5 ['PUNCT'] []\n \u00c4 ['NUM'] [Case=Nom|NumType=Card]\n \u00d6 ['PUNCT'] []\n </denchmark-code>\n \n Kind of strange still, but at least all with POS tags.\n Thanks for the report and being persistent, this is a pretty bad bug...\n \t\t"}, "comments_16": {"comment_id": 17, "comment_author": "maxtrem", "commentT": "2020-11-09T07:38:03Z", "comment_text": "\n \t\tHi again and thank you for the explanation!\n Great to hear that you already found a fix! Having these strange POS tags is still far better than having an empty field. :) But I guess it's not that surprising to have bad predictions if those kind of tokens never were seen during training time.\n Just out of curiosity: Do you know roughly how often do those token misalignments appear (for example in your english training data)?\n When do you expect this to be fixed in the nightly-branch?\n Would it be possible to share the respective fix, so that I can fix that locally?\n \t\t"}, "comments_17": {"comment_id": 18, "comment_author": "maxtrem", "commentT": "2020-11-09T08:51:46Z", "comment_text": "\n \t\tLook at the tokenization evaluation (token_acc/p/r/f) with nlp.evaluate or just for tokenization with scorer.score_tokenization:\n <denchmark-link:https://nightly.spacy.io/api/scorer#score_tokenization>https://nightly.spacy.io/api/scorer#score_tokenization</denchmark-link>\n \n You have to do your own debugging to get it to output the misaligned cases (which you can also just do outside of spacy based on the gold vs. spacy tokenization), but one place is where it's counting the false positives here:\n \n \n \n spaCy/spacy/scorer.py\n \n \n         Lines 162 to 165\n       in\n       363ac73\n \n \n \n \n \n \n  if align.x2y.lengths[token.i] != 1: \n \n \n \n  acc_score.fp += 1 \n \n \n \n  else: \n \n \n \n  acc_score.tp += 1 \n \n \n \n \n \n \t\t"}, "comments_18": {"comment_id": 19, "comment_author": "maxtrem", "commentT": "2020-11-09T16:09:14Z", "comment_text": "\n \t\t<denchmark-link:https://github.com/adrianeboyd>@adrianeboyd</denchmark-link>\n  Thanks a lot!\n \t\t"}, "comments_19": {"comment_id": 20, "comment_author": "maxtrem", "commentT": "2020-11-12T09:44:19Z", "comment_text": "\n \t\tI think this one can be closed, as PR <denchmark-link:https://github.com/explosion/spaCy/pull/6363>#6363</denchmark-link>\n  fixes it?\n I've noticed lately on Github that issues are not being linked properly anymore when the PR description has something like Fixes #6350 :(\n \t\t"}}}, "commit": {"commit_id": "a7e7d6c6c902055b66b208c299cfe8b578a497d8", "commit_author": "Adriane Boyd", "commitT": "2020-11-10 20:15:09+08:00", "changed_files": {"file_0": {"file_change_type": "MODIFY", "file_Nmethod": 0, "file_old_name": "spacy\\pipeline\\morphologizer.pyx", "file_new_name": "spacy\\pipeline\\morphologizer.pyx", "hunks": {"hunk_0": {"Ismethod": 0, "added_lines": "201,202,228,229,230,231,232,233", "deleted_lines": "95,96,97,204,205,231,232,233,234,235,236"}}}, "file_1": {"file_change_type": "MODIFY", "file_Nmethod": 1, "file_old_name": "spacy\\tests\\pipeline\\test_morphologizer.py", "file_new_name": "spacy\\tests\\pipeline\\test_morphologizer.py", "hunks": {"hunk_0": {"Ismethod": 1, "added_lines": "119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138", "deleted_lines": null, "method_info": {"method_name": "test_overfitting_IO", "method_params": "", "method_startline": "77", "method_endline": "138"}}}}}}}