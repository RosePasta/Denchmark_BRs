{"BR": {"BR_id": "7106", "BR_author": "elpollouk", "BRopenT": "2020-02-10T13:13:17Z", "BRcloseT": "2020-02-14T06:30:45Z", "BR_text": {"BRsummary": "[RLlib] Errors originating from environment workers cause training to stall", "BRdescription": "\n <denchmark-h:h3>What is the problem?</denchmark-h>\n \n Ray: 0.8.0/0.8.1\n OS: Ubuntu 16.04/18.04\n Errors originating from environment step() or reset() functions cause training to stall when using  AsyncSamplesOptimizer (e.g. IMPALA) even if ignore_worker_failures: True is set in the experiment config.\n If an environment request fails, the generator returned by  never runs to completion and so  isn't cleared down properly. This results in stale object ids being used on the next training iteration causing <denchmark-link:https://github.com/ray-project/ray/issues/7105>#7105</denchmark-link>\n  to manifest itself, stalling the experiment.\n <denchmark-h:h3>Reproduction</denchmark-h>\n \n \n Set up an IMPALA experiment with external environments\n After a few training iterations, kill one of the external environments\n \n <denchmark-h:h4>Result:</denchmark-h>\n \n After Trainer._try_recover() has black listed the failed worker, the experiment will stall with the following call stack:\n <denchmark-code>Thread 46562 (idle): \"MainThread\"\n     get_objects (ray/worker.py:318)\n     get (ray/worker.py:1450)\n     ray_get_and_free (ray/rllib/utils/memory.py:33)\n     _augment_with_replay (ray/rllib/optimizers/aso_aggregator.py:170)\n     iter_train_batches (ray/rllib/optimizers/aso_aggregator.py:117)\n     _step (ray/rllib/optimizers/async_samples_optimizer.py:178)\n     step (ray/rllib/optimizers/async_samples_optimizer.py:136)\n     _train (ray/rllib/agents/trainer_template.py:129)\n     train (ray/tune/trainable.py:176)\n     train (ray/rllib/agents/trainer.py:433)\n     actor_method_executor (ray/function_manager.py:766)\n     main_loop (ray/worker.py:433)\n     <module> (ray/workers/default_worker.py:118)\n </denchmark-code>\n \n <denchmark-h:h3>Potential Fix</denchmark-h>\n \n Rather than using a list for self._fetching in TaskPool, you can use a queue so that items that are going to be freed are automatically removed from the list of tasks to be fetched. This also ensures that the fetching list is always up to date, even if the generator is stopped early.\n Here's a example fix that I'm currently testing:\n <denchmark-link:https://gist.github.com/elpollouk/1d0cb83bd98c7a9fa4c9226c66ea07ee>actors.py.diff</denchmark-link>\n \n I haven't dug into the access pattern for TaskPool beyond my current scenario, so I'm not sure if a lock should be added around modifications to self._fetching. I'm also unaware if there are any subtle side effects of removing items from the fetching list that the original authors were considering when implementing the current logic, so any thoughts here would be greatly appreciated.\n \t"}, "comments": {"comments_0": {"comment_id": 1, "comment_author": "elpollouk", "commentT": "2020-02-11T06:57:01Z", "comment_text": "\n \t\t<denchmark-link:https://github.com/elpollouk>@elpollouk</denchmark-link>\n  could you try out the latest wheel and see if this is still an issue? The hang fix is merged in master as of <denchmark-link:https://github.com/ray-project/ray/pull/7117>#7117</denchmark-link>\n \n \t\t"}, "comments_1": {"comment_id": 2, "comment_author": "elpollouk", "commentT": "2020-02-11T10:31:08Z", "comment_text": "\n \t\tTrying the latest nightly and the experiment does continue to run after knocking out workers.\n However, it does appear that you're still re-using object ids for sample batches you've already processed after an error. Is this a concern?\n The issue I was attempting to fix with my patch was that you are relying on the  generator to run to completion in order to maintain correct state in the . However, generator completion is never guaranteed as iteration can be stopped at any time either by an exception or other coded stopping condition. Although fixing the symptom of <denchmark-link:https://github.com/ray-project/ray/issues/7105>#7105</denchmark-link>\n  is working now, the fact that it possible for  to get itself into an inconsistent state will likely manifest itself again in the future via other non-obvious bugs.\n \t\t"}, "comments_2": {"comment_id": 3, "comment_author": "elpollouk", "commentT": "2020-02-12T04:35:02Z", "comment_text": "\n \t\tThe patch makes sense. Do you want to make a PR for it?\n \t\t"}, "comments_3": {"comment_id": 4, "comment_author": "elpollouk", "commentT": "2020-02-12T17:26:33Z", "comment_text": "\n \t\tPR submitted, have fun!\n \t\t"}}}, "commit": {"commit_id": "fe6ce714a046e1b6a7c1e525208f1a8b27a51d67", "commit_author": "Adrian OGrady", "commitT": "2020-02-13 22:30:44-08:00", "changed_files": {"file_0": {"file_change_type": "MODIFY", "file_Nmethod": 0, "file_old_name": "rllib\\BUILD", "file_new_name": "rllib\\BUILD", "hunks": {"hunk_0": {"Ismethod": 0, "added_lines": "51,52,53,54,55,56,57,58,59,60,61", "deleted_lines": null}}}, "file_1": {"file_change_type": "MODIFY", "file_Nmethod": 3, "file_old_name": "rllib\\utils\\actors.py", "file_new_name": "rllib\\utils\\actors.py", "hunks": {"hunk_0": {"Ismethod": 1, "added_lines": "54,55,56,57,58,60,61", "deleted_lines": "48,49,57,58,60,61", "method_info": {"method_name": "reset_workers", "method_params": "self,workers", "method_startline": "48", "method_endline": "61"}}, "hunk_1": {"Ismethod": 1, "added_lines": "15", "deleted_lines": "14", "method_info": {"method_name": "__init__", "method_params": "self", "method_startline": "12", "method_endline": "15"}}, "hunk_2": {"Ismethod": 1, "added_lines": "42,43,44,45,46", "deleted_lines": "41,42,43,44,45,46", "method_info": {"method_name": "completed_prefetch", "method_params": "self,blocking_wait,max_yield", "method_startline": "34", "method_endline": "46"}}}}, "file_2": {"file_change_type": "ADD", "file_Nmethod": 0, "file_old_name": "None", "file_new_name": "rllib\\utils\\tests\\test_taskpool.py"}}}}